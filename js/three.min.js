!function(e, t) {
    "object" == typeof exports && "undefined" != typeof module ? t(exports) : "function" == typeof define && define.amd ? define(["exports"], t) : t(e.THREE = {})
}(this, function(e) {
    function L() {}
    function Y(e, t) {
        this.x = e || 0,
        this.y = t || 0
    }
    function _e() {
        this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1],
        0 < arguments.length && console.error("THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.")
    }
    function M(e, t, i, n) {
        this._x = e || 0,
        this._y = t || 0,
        this._z = i || 0,
        this._w = void 0 !== n ? n : 1
    }
    function Me(e, t, i) {
        this.x = e || 0,
        this.y = t || 0,
        this.z = i || 0
    }
    function g() {
        this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1],
        0 < arguments.length && console.error("THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.")
    }
    function p(e, t, i, n, r, a, o, s, c, h) {
        Object.defineProperty(this, "id", {
            value: $a++
        }),
        this.uuid = Se.generateUUID(),
        this.name = "",
        this.image = void 0 !== e ? e : p.DEFAULT_IMAGE,
        this.mipmaps = [],
        this.mapping = void 0 !== t ? t : p.DEFAULT_MAPPING,
        this.wrapS = void 0 !== i ? i : 1001,
        this.wrapT = void 0 !== n ? n : 1001,
        this.magFilter = void 0 !== r ? r : 1006,
        this.minFilter = void 0 !== a ? a : 1008,
        this.anisotropy = void 0 !== c ? c : 1,
        this.format = void 0 !== o ? o : 1023,
        this.type = void 0 !== s ? s : 1009,
        this.offset = new Y(0,0),
        this.repeat = new Y(1,1),
        this.center = new Y(0,0),
        this.rotation = 0,
        this.matrixAutoUpdate = !0,
        this.matrix = new g,
        this.generateMipmaps = !0,
        this.premultiplyAlpha = !1,
        this.flipY = !0,
        this.unpackAlignment = 4,
        this.encoding = void 0 !== h ? h : 3e3,
        this.version = 0,
        this.onUpdate = null
    }
    function Ee(e, t, i, n) {
        this.x = e || 0,
        this.y = t || 0,
        this.z = i || 0,
        this.w = void 0 !== n ? n : 1
    }
    function P(e, t, i) {
        this.width = e,
        this.height = t,
        this.scissor = new Ee(0,0,e,t),
        this.scissorTest = !1,
        this.viewport = new Ee(0,0,e,t),
        this.texture = new p(void 0,void 0,(i = i || {}).wrapS,i.wrapT,i.magFilter,i.minFilter,i.format,i.type,i.anisotropy,i.encoding),
        this.texture.generateMipmaps = void 0 !== i.generateMipmaps && i.generateMipmaps,
        this.texture.minFilter = void 0 !== i.minFilter ? i.minFilter : 1006,
        this.depthBuffer = void 0 === i.depthBuffer || i.depthBuffer,
        this.stencilBuffer = void 0 === i.stencilBuffer || i.stencilBuffer,
        this.depthTexture = void 0 !== i.depthTexture ? i.depthTexture : null
    }
    function R(e, t, i) {
        P.call(this, e, t, i),
        this.samples = 4
    }
    function C(e, t, i) {
        P.call(this, e, t, i),
        this.activeMipMapLevel = this.activeCubeFace = 0
    }
    function Ae(e, t, i, n, r, a, o, s, c, h, l, u) {
        p.call(this, null, a, o, s, c, h, n, r, l, u),
        this.image = {
            data: e,
            width: t,
            height: i
        },
        this.magFilter = void 0 !== c ? c : 1003,
        this.minFilter = void 0 !== h ? h : 1003,
        this.flipY = this.generateMipmaps = !1,
        this.unpackAlignment = 1
    }
    function O(e, t) {
        this.min = void 0 !== e ? e : new Me(1 / 0,1 / 0,1 / 0),
        this.max = void 0 !== t ? t : new Me(-1 / 0,-1 / 0,-1 / 0)
    }
    function I(e, t) {
        this.center = void 0 !== e ? e : new Me,
        this.radius = void 0 !== t ? t : 0
    }
    function D(e, t) {
        this.normal = void 0 !== e ? e : new Me(1,0,0),
        this.constant = void 0 !== t ? t : 0
    }
    function Le(e, t, i, n, r, a) {
        this.planes = [void 0 !== e ? e : new D, void 0 !== t ? t : new D, void 0 !== i ? i : new D, void 0 !== n ? n : new D, void 0 !== r ? r : new D, void 0 !== a ? a : new D]
    }
    function Pe(e) {
        var t, i = {};
        for (t in e)
            for (var n in i[t] = {},
            e[t]) {
                var r = e[t][n];
                r && (r.isColor || r.isMatrix3 || r.isMatrix4 || r.isVector2 || r.isVector3 || r.isVector4 || r.isTexture) ? i[t][n] = r.clone() : Array.isArray(r) ? i[t][n] = r.slice() : i[t][n] = r
            }
        return i
    }
    function t(e) {
        for (var t = {}, i = 0; i < e.length; i++) {
            var n, r = Pe(e[i]);
            for (n in r)
                t[n] = r[n]
        }
        return t
    }
    function d(e, t, i) {
        return void 0 === t && void 0 === i ? this.set(e) : this.setRGB(e, t, i)
    }
    function Re() {
        function i(e, t) {
            !1 !== r && (a(e, t),
            n.requestAnimationFrame(i))
        }
        var n = null
          , r = !1
          , a = null;
        return {
            start: function() {
                !0 !== r && null !== a && (n.requestAnimationFrame(i),
                r = !0)
            },
            stop: function() {
                r = !1
            },
            setAnimationLoop: function(e) {
                a = e
            },
            setContext: function(e) {
                n = e
            }
        }
    }
    function Ce(c) {
        var h = new WeakMap;
        return {
            get: function(e) {
                return e.isInterleavedBufferAttribute && (e = e.data),
                h.get(e)
            },
            remove: function(e) {
                e.isInterleavedBufferAttribute && (e = e.data);
                var t = h.get(e);
                t && (c.deleteBuffer(t.buffer),
                h.delete(e))
            },
            update: function(e, t) {
                e.isInterleavedBufferAttribute && (e = e.data);
                var i, n, r, a, o, s = h.get(e);
                void 0 === s ? h.set(e, (n = t,
                r = (i = e).array,
                a = i.dynamic ? 35048 : 35044,
                o = c.createBuffer(),
                c.bindBuffer(n, o),
                c.bufferData(n, r, a),
                i.onUploadCallback(),
                n = 5126,
                r instanceof Float32Array ? n = 5126 : r instanceof Float64Array ? console.warn("THREE.WebGLAttributes: Unsupported data buffer format: Float64Array.") : r instanceof Uint16Array ? n = 5123 : r instanceof Int16Array ? n = 5122 : r instanceof Uint32Array ? n = 5125 : r instanceof Int32Array ? n = 5124 : r instanceof Int8Array ? n = 5120 : r instanceof Uint8Array && (n = 5121),
                {
                    buffer: o,
                    type: n,
                    bytesPerElement: r.BYTES_PER_ELEMENT,
                    version: i.version
                })) : s.version < e.version && (o = (a = e).array,
                n = a.updateRange,
                c.bindBuffer(t, s.buffer),
                !1 === a.dynamic ? c.bufferData(t, o, 35044) : -1 === n.count ? c.bufferSubData(t, 0, o) : 0 === n.count ? console.error("THREE.WebGLObjects.updateBuffer: dynamic THREE.BufferAttribute marked as needsUpdate but updateRange.count is 0, ensure you are using set methods or updating manually.") : (c.bufferSubData(t, n.offset * o.BYTES_PER_ELEMENT, o.subarray(n.offset, n.offset + n.count)),
                n.count = -1),
                s.version = e.version)
            }
        }
    }
    function B(e, t, i, n, r, a) {
        this.a = e,
        this.b = t,
        this.c = i,
        this.normal = n && n.isVector3 ? n : new Me,
        this.vertexNormals = Array.isArray(n) ? n : [],
        this.color = r && r.isColor ? r : new d,
        this.vertexColors = Array.isArray(r) ? r : [],
        this.materialIndex = void 0 !== a ? a : 0
    }
    function N(e, t, i, n) {
        this._x = e || 0,
        this._y = t || 0,
        this._z = i || 0,
        this._order = n || N.DefaultOrder
    }
    function G() {
        this.mask = 1
    }
    function u() {
        Object.defineProperty(this, "id", {
            value: Ds++
        }),
        this.uuid = Se.generateUUID(),
        this.name = "",
        this.type = "Object3D",
        this.parent = null,
        this.children = [],
        this.up = u.DefaultUp.clone();
        var e = new Me
          , t = new N
          , i = new M
          , n = new Me(1,1,1);
        t.onChange(function() {
            i.setFromEuler(t, !1)
        }),
        i.onChange(function() {
            t.setFromQuaternion(i, void 0, !1)
        }),
        Object.defineProperties(this, {
            position: {
                configurable: !0,
                enumerable: !0,
                value: e
            },
            rotation: {
                configurable: !0,
                enumerable: !0,
                value: t
            },
            quaternion: {
                configurable: !0,
                enumerable: !0,
                value: i
            },
            scale: {
                configurable: !0,
                enumerable: !0,
                value: n
            },
            modelViewMatrix: {
                value: new _e
            },
            normalMatrix: {
                value: new g
            }
        }),
        this.matrix = new _e,
        this.matrixWorld = new _e,
        this.matrixAutoUpdate = u.DefaultMatrixAutoUpdate,
        this.matrixWorldNeedsUpdate = !1,
        this.layers = new G,
        this.visible = !0,
        this.receiveShadow = this.castShadow = !1,
        this.frustumCulled = !0,
        this.renderOrder = 0,
        this.userData = {}
    }
    function f() {
        Object.defineProperty(this, "id", {
            value: Bs += 2
        }),
        this.uuid = Se.generateUUID(),
        this.name = "",
        this.type = "Geometry",
        this.vertices = [],
        this.colors = [],
        this.faces = [],
        this.faceVertexUvs = [[]],
        this.morphTargets = [],
        this.morphNormals = [],
        this.skinWeights = [],
        this.skinIndices = [],
        this.lineDistances = [],
        this.boundingSphere = this.boundingBox = null,
        this.groupsNeedUpdate = this.lineDistancesNeedUpdate = this.colorsNeedUpdate = this.normalsNeedUpdate = this.uvsNeedUpdate = this.verticesNeedUpdate = this.elementsNeedUpdate = !1
    }
    function m(e, t, i) {
        if (Array.isArray(e))
            throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
        this.name = "",
        this.array = e,
        this.itemSize = t,
        this.count = void 0 !== e ? e.length / t : 0,
        this.normalized = !0 === i,
        this.dynamic = !1,
        this.updateRange = {
            offset: 0,
            count: -1
        },
        this.version = 0
    }
    function F(e, t, i) {
        m.call(this, new Int8Array(e), t, i)
    }
    function H(e, t, i) {
        m.call(this, new Uint8Array(e), t, i)
    }
    function k(e, t, i) {
        m.call(this, new Uint8ClampedArray(e), t, i)
    }
    function V(e, t, i) {
        m.call(this, new Int16Array(e), t, i)
    }
    function j(e, t, i) {
        m.call(this, new Uint16Array(e), t, i)
    }
    function W(e, t, i) {
        m.call(this, new Int32Array(e), t, i)
    }
    function q(e, t, i) {
        m.call(this, new Uint32Array(e), t, i)
    }
    function z(e, t, i) {
        m.call(this, new Float32Array(e), t, i)
    }
    function X(e, t, i) {
        m.call(this, new Float64Array(e), t, i)
    }
    function J() {
        this.vertices = [],
        this.normals = [],
        this.colors = [],
        this.uvs = [],
        this.uvs2 = [],
        this.groups = [],
        this.morphTargets = {},
        this.skinWeights = [],
        this.skinIndices = [],
        this.boundingSphere = this.boundingBox = null,
        this.groupsNeedUpdate = this.uvsNeedUpdate = this.colorsNeedUpdate = this.normalsNeedUpdate = this.verticesNeedUpdate = !1
    }
    function Z(e) {
        if (0 === e.length)
            return -1 / 0;
        for (var t = e[0], i = 1, n = e.length; i < n; ++i)
            e[i] > t && (t = e[i]);
        return t
    }
    function U() {
        Object.defineProperty(this, "id", {
            value: Ns += 2
        }),
        this.uuid = Se.generateUUID(),
        this.name = "",
        this.type = "BufferGeometry",
        this.index = null,
        this.attributes = {},
        this.morphAttributes = {},
        this.groups = [],
        this.boundingSphere = this.boundingBox = null,
        this.drawRange = {
            start: 0,
            count: 1 / 0
        },
        this.userData = {}
    }
    function Q(e, t, i, n, r, a) {
        f.call(this),
        this.type = "BoxGeometry",
        this.parameters = {
            width: e,
            height: t,
            depth: i,
            widthSegments: n,
            heightSegments: r,
            depthSegments: a
        },
        this.fromBufferGeometry(new K(e,t,i,n,r,a)),
        this.mergeVertices()
    }
    function K(e, t, i, n, r, a) {
        function o(e, t, i, n, r, a, o, s, c, h, l) {
            for (var u = a / c, p = o / h, d = a / 2, f = o / 2, m = s / 2, g = (o = c + 1,
            h + 1), v = a = 0, y = new Me, x = 0; x < g; x++)
                for (var b = x * p - f, w = 0; w < o; w++)
                    y[e] = (w * u - d) * n,
                    y[t] = b * r,
                    y[i] = m,
                    E.push(y.x, y.y, y.z),
                    y[e] = 0,
                    y[t] = 0,
                    y[i] = 0 < s ? 1 : -1,
                    S.push(y.x, y.y, y.z),
                    T.push(w / c),
                    T.push(1 - x / h),
                    a += 1;
            for (x = 0; x < h; x++)
                for (w = 0; w < c; w++)
                    e = A + w + o * (x + 1),
                    t = A + (w + 1) + o * (x + 1),
                    i = A + (w + 1) + o * x,
                    M.push(A + w + o * x, e, i),
                    M.push(e, t, i),
                    v += 6;
            _.addGroup(L, v, l),
            L += v,
            A += a
        }
        U.call(this),
        this.type = "BoxBufferGeometry",
        this.parameters = {
            width: e,
            height: t,
            depth: i,
            widthSegments: n,
            heightSegments: r,
            depthSegments: a
        };
        var _ = this
          , M = (e = e || 1,
        t = t || 1,
        i = i || 1,
        n = Math.floor(n) || 1,
        r = Math.floor(r) || 1,
        a = Math.floor(a) || 1,
        [])
          , E = []
          , S = []
          , T = []
          , A = 0
          , L = 0;
        o("z", "y", "x", -1, -1, i, t, e, a, r, 0),
        o("z", "y", "x", 1, -1, i, t, -e, a, r, 1),
        o("x", "z", "y", 1, 1, e, i, t, n, a, 2),
        o("x", "z", "y", 1, -1, e, i, -t, n, a, 3),
        o("x", "y", "z", 1, -1, e, t, i, n, r, 4),
        o("x", "y", "z", -1, -1, e, t, -i, n, r, 5),
        this.setIndex(M),
        this.addAttribute("position", new z(E,3)),
        this.addAttribute("normal", new z(S,3)),
        this.addAttribute("uv", new z(T,2))
    }
    function $(e, t, i, n) {
        f.call(this),
        this.type = "PlaneGeometry",
        this.parameters = {
            width: e,
            height: t,
            widthSegments: i,
            heightSegments: n
        },
        this.fromBufferGeometry(new ee(e,t,i,n)),
        this.mergeVertices()
    }
    function ee(e, t, i, n) {
        U.call(this),
        this.type = "PlaneBufferGeometry",
        this.parameters = {
            width: e,
            height: t,
            widthSegments: i,
            heightSegments: n
        };
        var r = (e = e || 1) / 2
          , a = (t = t || 1) / 2
          , o = (i = Math.floor(i) || 1) + 1
          , s = (n = Math.floor(n) || 1) + 1
          , c = e / i
          , h = t / n
          , l = []
          , u = []
          , p = []
          , d = [];
        for (e = 0; e < s; e++) {
            var f = e * h - a;
            for (t = 0; t < o; t++)
                u.push(t * c - r, -f, 0),
                p.push(0, 0, 1),
                d.push(t / i),
                d.push(1 - e / n)
        }
        for (e = 0; e < n; e++)
            for (t = 0; t < i; t++)
                a = t + 1 + o * (e + 1),
                l.push(t + o * e, r = t + o * (e + 1), s = t + 1 + o * e),
                l.push(r, a, s);
        this.setIndex(l),
        this.addAttribute("position", new z(u,3)),
        this.addAttribute("normal", new z(p,3)),
        this.addAttribute("uv", new z(d,2))
    }
    function a() {
        Object.defineProperty(this, "id", {
            value: zs++
        }),
        this.uuid = Se.generateUUID(),
        this.name = "",
        this.type = "Material",
        this.lights = this.fog = !0,
        this.blending = 1,
        this.side = 0,
        this.flatShading = !1,
        this.vertexColors = 0,
        this.opacity = 1,
        this.transparent = !1,
        this.blendSrc = 204,
        this.blendDst = 205,
        this.blendEquation = 100,
        this.blendEquationAlpha = this.blendDstAlpha = this.blendSrcAlpha = null,
        this.depthFunc = 3,
        this.depthWrite = this.depthTest = !0,
        this.clippingPlanes = null,
        this.clipShadows = this.clipIntersection = !1,
        this.shadowSide = null,
        this.colorWrite = !0,
        this.precision = null,
        this.polygonOffset = !1,
        this.polygonOffsetUnits = this.polygonOffsetFactor = 0,
        this.dithering = !1,
        this.alphaTest = 0,
        this.premultipliedAlpha = !1,
        this.visible = !0,
        this.userData = {},
        this.needsUpdate = !0
    }
    function te(e) {
        a.call(this),
        this.type = "ShaderMaterial",
        this.defines = {},
        this.uniforms = {},
        this.vertexShader = "void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}",
        this.fragmentShader = "void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}",
        this.linewidth = 1,
        this.wireframe = !1,
        this.wireframeLinewidth = 1,
        this.morphNormals = this.morphTargets = this.skinning = this.clipping = this.lights = this.fog = !1,
        this.extensions = {
            derivatives: !1,
            fragDepth: !1,
            drawBuffers: !1,
            shaderTextureLOD: !1
        },
        this.defaultAttributeValues = {
            color: [1, 1, 1],
            uv: [0, 0],
            uv2: [0, 0]
        },
        this.index0AttributeName = void 0,
        this.uniformsNeedUpdate = !1,
        void 0 !== e && (void 0 !== e.attributes && console.error("THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead."),
        this.setValues(e))
    }
    function ie(e, t) {
        this.origin = void 0 !== e ? e : new Me,
        this.direction = void 0 !== t ? t : new Me
    }
    function w(e, t, i) {
        this.a = void 0 !== e ? e : new Me,
        this.b = void 0 !== t ? t : new Me,
        this.c = void 0 !== i ? i : new Me
    }
    function ne(e) {
        a.call(this),
        this.type = "MeshBasicMaterial",
        this.color = new d(16777215),
        this.lightMap = this.map = null,
        this.lightMapIntensity = 1,
        this.aoMap = null,
        this.aoMapIntensity = 1,
        this.envMap = this.alphaMap = this.specularMap = null,
        this.combine = 0,
        this.reflectivity = 1,
        this.refractionRatio = .98,
        this.wireframe = !1,
        this.wireframeLinewidth = 1,
        this.wireframeLinejoin = this.wireframeLinecap = "round",
        this.lights = this.morphTargets = this.skinning = !1,
        this.setValues(e)
    }
    function v(e, t) {
        u.call(this),
        this.type = "Mesh",
        this.geometry = void 0 !== e ? e : new U,
        this.material = void 0 !== t ? t : new ne({
            color: 16777215 * Math.random()
        }),
        this.drawMode = 0,
        this.updateMorphTargets()
    }
    function Oe(r, i, a, n) {
        function o(e, t) {
            i.buffers.color.setClear(e.r, e.g, e.b, t, n)
        }
        var s, c, h = new d(0), l = 0, u = null, p = 0;
        return {
            getClearColor: function() {
                return h
            },
            setClearColor: function(e, t) {
                h.set(e),
                o(h, l = void 0 !== t ? t : 1)
            },
            getClearAlpha: function() {
                return l
            },
            setClearAlpha: function(e) {
                o(h, l = e)
            },
            render: function(e, t, i, n) {
                null === (t = t.background) ? (o(h, l),
                u = null,
                p = 0) : t && t.isColor && (o(t, 1),
                n = !0,
                u = null,
                p = 0),
                (r.autoClear || n) && r.clear(r.autoClearColor, r.autoClearDepth, r.autoClearStencil),
                t && (t.isCubeTexture || t.isWebGLRenderTargetCube) ? (void 0 === c && ((c = new v(new K(1,1,1),new te({
                    type: "BackgroundCubeMaterial",
                    uniforms: Pe(Is.cube.uniforms),
                    vertexShader: Is.cube.vertexShader,
                    fragmentShader: Is.cube.fragmentShader,
                    side: 1,
                    depthTest: !1,
                    depthWrite: !1,
                    fog: !1
                }))).geometry.removeAttribute("normal"),
                c.geometry.removeAttribute("uv"),
                c.onBeforeRender = function(e, t, i) {
                    this.matrixWorld.copyPosition(i.matrixWorld)
                }
                ,
                Object.defineProperty(c.material, "map", {
                    get: function() {
                        return this.uniforms.tCube.value
                    }
                }),
                a.update(c)),
                n = t.isWebGLRenderTargetCube ? t.texture : t,
                c.material.uniforms.tCube.value = n,
                c.material.uniforms.tFlip.value = t.isWebGLRenderTargetCube ? 1 : -1,
                u === t && p === n.version || (c.material.needsUpdate = !0,
                u = t,
                p = n.version),
                e.unshift(c, c.geometry, c.material, 0, 0, null)) : t && t.isTexture && (void 0 === s && ((s = new v(new ee(2,2),new te({
                    type: "BackgroundMaterial",
                    uniforms: Pe(Is.background.uniforms),
                    vertexShader: Is.background.vertexShader,
                    fragmentShader: Is.background.fragmentShader,
                    side: 0,
                    depthTest: !1,
                    depthWrite: !1,
                    fog: !1
                }))).geometry.removeAttribute("normal"),
                Object.defineProperty(s.material, "map", {
                    get: function() {
                        return this.uniforms.t2D.value
                    }
                }),
                a.update(s)),
                !0 === (s.material.uniforms.t2D.value = t).matrixAutoUpdate && t.updateMatrix(),
                s.material.uniforms.uvTransform.value.copy(t.matrix),
                u === t && p === t.version || (s.material.needsUpdate = !0,
                p = (u = t).version),
                e.unshift(s, s.geometry, s.material, 0, 0, null))
            }
        }
    }
    function Ie(r, a, o, s) {
        var c;
        this.setMode = function(e) {
            c = e
        }
        ,
        this.render = function(e, t) {
            r.drawArrays(c, e, t),
            o.update(t, c)
        }
        ,
        this.renderInstances = function(e, t, i) {
            if (s.isWebGL2)
                var n = r;
            else if (null === (n = a.get("ANGLE_instanced_arrays")))
                return void console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
            n[s.isWebGL2 ? "drawArraysInstanced" : "drawArraysInstancedANGLE"](c, t, i, e.maxInstancedCount),
            o.update(i, c, e.maxInstancedCount)
        }
    }
    function De(t, i, e) {
        function n(e) {
            if ("highp" === e) {
                if (0 < t.getShaderPrecisionFormat(35633, 36338).precision && 0 < t.getShaderPrecisionFormat(35632, 36338).precision)
                    return "highp";
                e = "mediump"
            }
            return "mediump" === e && 0 < t.getShaderPrecisionFormat(35633, 36337).precision && 0 < t.getShaderPrecisionFormat(35632, 36337).precision ? "mediump" : "lowp"
        }
        var r, a = "undefined" != typeof WebGL2RenderingContext && t instanceof WebGL2RenderingContext, o = void 0 !== e.precision ? e.precision : "highp", s = n(o), c = (s !== o && (console.warn("THREE.WebGLRenderer:", o, "not supported, using", s, "instead."),
        o = s),
        e = !0 === e.logarithmicDepthBuffer,
        s = t.getParameter(34930),
        t.getParameter(35660)), h = t.getParameter(3379), l = t.getParameter(34076), u = t.getParameter(34921), p = t.getParameter(36347), d = t.getParameter(36348), f = t.getParameter(36349), m = 0 < c, g = a || !!i.get("OES_texture_float");
        return {
            isWebGL2: a,
            getMaxAnisotropy: function() {
                var e;
                return void 0 !== r ? r : (e = i.get("EXT_texture_filter_anisotropic"),
                r = null !== e ? t.getParameter(e.MAX_TEXTURE_MAX_ANISOTROPY_EXT) : 0)
            },
            getMaxPrecision: n,
            precision: o,
            logarithmicDepthBuffer: e,
            maxTextures: s,
            maxVertexTextures: c,
            maxTextureSize: h,
            maxCubemapSize: l,
            maxAttributes: u,
            maxVertexUniforms: p,
            maxVaryings: d,
            maxFragmentUniforms: f,
            vertexTextures: m,
            floatFragmentTextures: g,
            floatVertexTextures: m && g,
            maxSamples: a ? t.getParameter(36183) : 0
        }
    }
    function Be() {
        function c() {
            m.value !== l && (m.value = l,
            m.needsUpdate = 0 < u),
            o.numPlanes = u,
            o.numIntersection = 0
        }
        function h(e, t, i, n) {
            var r = null !== e ? e.length : 0
              , a = null;
            if (0 !== r) {
                if (a = m.value,
                !0 !== n || null === a)
                    for (n = i + 4 * r,
                    t = t.matrixWorldInverse,
                    f.getNormalMatrix(t),
                    (null === a || a.length < n) && (a = new Float32Array(n)),
                    n = 0; n !== r; ++n,
                    i += 4)
                        s.copy(e[n]).applyMatrix4(t, f),
                        s.normal.toArray(a, i),
                        a[i + 3] = s.constant;
                m.value = a,
                m.needsUpdate = !0
            }
            return o.numPlanes = r,
            a
        }
        var o = this
          , l = null
          , u = 0
          , p = !1
          , d = !1
          , s = new D
          , f = new g
          , m = {
            value: null,
            needsUpdate: !1
        };
        this.uniform = m,
        this.numIntersection = this.numPlanes = 0,
        this.init = function(e, t, i) {
            var n = 0 !== e.length || t || 0 !== u || p;
            return p = t,
            l = h(e, i, 0),
            u = e.length,
            n
        }
        ,
        this.beginShadows = function() {
            d = !0,
            h(null)
        }
        ,
        this.endShadows = function() {
            d = !1,
            c()
        }
        ,
        this.setState = function(e, t, i, n, r, a) {
            if (!p || null === e || 0 === e.length || d && !i)
                d ? h(null) : c();
            else {
                var o = 4 * (i = d ? 0 : u)
                  , s = r.clippingState || null;
                for (m.value = s,
                s = h(e, n, o, a),
                e = 0; e !== o; ++e)
                    s[e] = l[e];
                r.clippingState = s,
                this.numIntersection = t ? this.numPlanes : 0,
                this.numPlanes += i
            }
        }
    }
    function Ne(i) {
        var n = {};
        return {
            get: function(e) {
                if (void 0 !== n[e])
                    return n[e];
                switch (e) {
                case "WEBGL_depth_texture":
                    var t = i.getExtension("WEBGL_depth_texture") || i.getExtension("MOZ_WEBGL_depth_texture") || i.getExtension("WEBKIT_WEBGL_depth_texture");
                    break;
                case "EXT_texture_filter_anisotropic":
                    t = i.getExtension("EXT_texture_filter_anisotropic") || i.getExtension("MOZ_EXT_texture_filter_anisotropic") || i.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
                    break;
                case "WEBGL_compressed_texture_s3tc":
                    t = i.getExtension("WEBGL_compressed_texture_s3tc") || i.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || i.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
                    break;
                case "WEBGL_compressed_texture_pvrtc":
                    t = i.getExtension("WEBGL_compressed_texture_pvrtc") || i.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
                    break;
                default:
                    t = i.getExtension(e)
                }
                return null === t && console.warn("THREE.WebGLRenderer: " + e + " extension not supported."),
                n[e] = t
            }
        }
    }
    function ze(e, c, n) {
        function r(e) {
            var t, i = e.target;
            for (t in null !== (e = a[i.id]).index && c.remove(e.index),
            e.attributes)
                c.remove(e.attributes[t]);
            i.removeEventListener("dispose", r),
            delete a[i.id],
            (t = h[e.id]) && (c.remove(t),
            delete h[e.id]),
            n.memory.geometries--
        }
        var a = {}
          , h = {};
        return {
            get: function(e, t) {
                var i = a[t.id];
                return i || (t.addEventListener("dispose", r),
                t.isBufferGeometry ? i = t : t.isGeometry && (void 0 === t._bufferGeometry && (t._bufferGeometry = (new U).setFromObject(e)),
                i = t._bufferGeometry),
                a[t.id] = i,
                n.memory.geometries++),
                i
            },
            update: function(e) {
                var t, i = e.index, n = e.attributes;
                for (t in null !== i && c.update(i, 34963),
                n)
                    c.update(n[t], 34962);
                for (t in e = e.morphAttributes)
                    for (var n = 0, r = (i = e[t]).length; n < r; n++)
                        c.update(i[n], 34962)
            },
            getWireframeAttribute: function(e) {
                if (t = h[e.id])
                    return t;
                var t = []
                  , i = e.index
                  , n = e.attributes;
                if (null !== i)
                    for (var n = 0, r = (i = i.array).length; n < r; n += 3) {
                        var a = i[n + 0]
                          , o = i[n + 1]
                          , s = i[n + 2];
                        t.push(a, o, o, s, s, a)
                    }
                else
                    for (i = n.position.array,
                    n = 0,
                    r = i.length / 3 - 1; n < r; n += 3)
                        t.push(a = n + 0, o = n + 1, o, s = n + 2, s, a);
                return t = new (65535 < Z(t) ? q : j)(t,1),
                c.update(t, 34963),
                h[e.id] = t
            }
        }
    }
    function Ue(r, a, o, s) {
        var c, h, l;
        this.setMode = function(e) {
            c = e
        }
        ,
        this.setIndex = function(e) {
            h = e.type,
            l = e.bytesPerElement
        }
        ,
        this.render = function(e, t) {
            r.drawElements(c, t, h, e * l),
            o.update(t, c)
        }
        ,
        this.renderInstances = function(e, t, i) {
            if (s.isWebGL2)
                var n = r;
            else if (null === (n = a.get("ANGLE_instanced_arrays")))
                return void console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
            n[s.isWebGL2 ? "drawElementsInstanced" : "drawElementsInstancedANGLE"](c, i, h, t * l, e.maxInstancedCount),
            o.update(i, c, e.maxInstancedCount)
        }
    }
    function Ge(e) {
        var n = {
            frame: 0,
            calls: 0,
            triangles: 0,
            points: 0,
            lines: 0
        };
        return {
            memory: {
                geometries: 0,
                textures: 0
            },
            render: n,
            programs: null,
            autoReset: !0,
            reset: function() {
                n.frame++,
                n.calls = 0,
                n.triangles = 0,
                n.points = 0,
                n.lines = 0
            },
            update: function(e, t, i) {
                switch (i = i || 1,
                n.calls++,
                t) {
                case 4:
                    n.triangles += e / 3 * i;
                    break;
                case 5:
                case 6:
                    n.triangles += i * (e - 2);
                    break;
                case 1:
                    n.lines += e / 2 * i;
                    break;
                case 3:
                    n.lines += i * (e - 1);
                    break;
                case 2:
                    n.lines += i * e;
                    break;
                case 0:
                    n.points += i * e;
                    break;
                default:
                    console.error("THREE.WebGLInfo: Unknown draw mode:", t)
                }
            }
        }
    }
    function re(e, t) {
        return Math.abs(t[1]) - Math.abs(e[1])
    }
    function Fe(h) {
        var l = {}
          , u = new Float32Array(8);
        return {
            update: function(e, t, i, n) {
                var r = e.morphTargetInfluences
                  , a = r.length;
                if (void 0 === (e = l[t.id])) {
                    e = [];
                    for (var o = 0; o < a; o++)
                        e[o] = [o, 0];
                    l[t.id] = e
                }
                var s = i.morphTargets && t.morphAttributes.position;
                for (i = i.morphNormals && t.morphAttributes.normal,
                o = 0; o < a; o++) {
                    var c = e[o];
                    0 !== c[1] && (s && t.removeAttribute("morphTarget" + o),
                    i) && t.removeAttribute("morphNormal" + o)
                }
                for (o = 0; o < a; o++)
                    (c = e[o])[0] = o,
                    c[1] = r[o];
                for (e.sort(re),
                o = 0; o < 8; o++)
                    (c = e[o]) && (r = c[0],
                    a = c[1]) ? (s && t.addAttribute("morphTarget" + o, s[r]),
                    i && t.addAttribute("morphNormal" + o, i[r]),
                    u[o] = a) : u[o] = 0;
                n.getUniforms().setValue(h, "morphTargetInfluences", u)
            }
        }
    }
    function He(r, a) {
        var o = {};
        return {
            update: function(e) {
                var t = a.render.frame
                  , i = e.geometry
                  , n = r.get(e, i);
                return o[n.id] !== t && (i.isGeometry && n.updateFromObject(e),
                r.update(n),
                o[n.id] = t),
                n
            },
            dispose: function() {
                o = {}
            }
        }
    }
    function ae(e, t, i, n, r, a, o, s, c, h) {
        p.call(this, e = void 0 !== e ? e : [], void 0 !== t ? t : 301, i, n, r, a, o, s, c, h),
        this.flipY = !1
    }
    function oe(e, t, i, n) {
        p.call(this, null),
        this.image = {
            data: e,
            width: t,
            height: i,
            depth: n
        },
        this.minFilter = this.magFilter = 1003,
        this.flipY = this.generateMipmaps = !1
    }
    function se(e, t, i) {
        var n = e[0];
        if (n <= 0 || 0 < n)
            return e;
        var r = t * i
          , a = vc[r];
        if (void 0 === a && (a = new Float32Array(r),
        vc[r] = a),
        0 !== t)
            for (n.toArray(a, 0),
            n = 1,
            r = 0; n !== t; ++n)
                e[n].toArray(a, r += i);
        return a
    }
    function o(e, t) {
        if (e.length !== t.length)
            return !1;
        for (var i = 0, n = e.length; i < n; i++)
            if (e[i] !== t[i])
                return !1;
        return !0
    }
    function s(e, t) {
        for (var i = 0, n = t.length; i < n; i++)
            e[i] = t[i]
    }
    function ce(e, t) {
        var i = yc[t];
        void 0 === i && (i = new Int32Array(t),
        yc[t] = i);
        for (var n = 0; n !== t; ++n)
            i[n] = e.allocTextureUnit();
        return i
    }
    function he(e, t) {
        var i = this.cache;
        i[0] !== t && (e.uniform1f(this.addr, t),
        i[0] = t)
    }
    function le(e, t) {
        var i = this.cache;
        i[0] !== t && (e.uniform1i(this.addr, t),
        i[0] = t)
    }
    function ue(e, t) {
        var i = this.cache;
        void 0 !== t.x ? i[0] === t.x && i[1] === t.y || (e.uniform2f(this.addr, t.x, t.y),
        i[0] = t.x,
        i[1] = t.y) : o(i, t) || (e.uniform2fv(this.addr, t),
        s(i, t))
    }
    function pe(e, t) {
        var i = this.cache;
        void 0 !== t.x ? i[0] === t.x && i[1] === t.y && i[2] === t.z || (e.uniform3f(this.addr, t.x, t.y, t.z),
        i[0] = t.x,
        i[1] = t.y,
        i[2] = t.z) : void 0 !== t.r ? i[0] === t.r && i[1] === t.g && i[2] === t.b || (e.uniform3f(this.addr, t.r, t.g, t.b),
        i[0] = t.r,
        i[1] = t.g,
        i[2] = t.b) : o(i, t) || (e.uniform3fv(this.addr, t),
        s(i, t))
    }
    function de(e, t) {
        var i = this.cache;
        void 0 !== t.x ? i[0] === t.x && i[1] === t.y && i[2] === t.z && i[3] === t.w || (e.uniform4f(this.addr, t.x, t.y, t.z, t.w),
        i[0] = t.x,
        i[1] = t.y,
        i[2] = t.z,
        i[3] = t.w) : o(i, t) || (e.uniform4fv(this.addr, t),
        s(i, t))
    }
    function fe(e, t) {
        var i = this.cache
          , n = t.elements;
        void 0 === n ? o(i, t) || (e.uniformMatrix2fv(this.addr, !1, t),
        s(i, t)) : o(i, n) || (wc.set(n),
        e.uniformMatrix2fv(this.addr, !1, wc),
        s(i, n))
    }
    function me(e, t) {
        var i = this.cache
          , n = t.elements;
        void 0 === n ? o(i, t) || (e.uniformMatrix3fv(this.addr, !1, t),
        s(i, t)) : o(i, n) || (bc.set(n),
        e.uniformMatrix3fv(this.addr, !1, bc),
        s(i, n))
    }
    function ge(e, t) {
        var i = this.cache
          , n = t.elements;
        void 0 === n ? o(i, t) || (e.uniformMatrix4fv(this.addr, !1, t),
        s(i, t)) : o(i, n) || (xc.set(n),
        e.uniformMatrix4fv(this.addr, !1, xc),
        s(i, n))
    }
    function ve(e, t, i) {
        var n = this.cache
          , r = i.allocTextureUnit();
        n[0] !== r && (e.uniform1i(this.addr, r),
        n[0] = r),
        i.setTexture2D(t || fc, r)
    }
    function ye(e, t, i) {
        var n = this.cache
          , r = i.allocTextureUnit();
        n[0] !== r && (e.uniform1i(this.addr, r),
        n[0] = r),
        i.setTexture3D(t || mc, r)
    }
    function xe(e, t, i) {
        var n = this.cache
          , r = i.allocTextureUnit();
        n[0] !== r && (e.uniform1i(this.addr, r),
        n[0] = r),
        i.setTextureCube(t || gc, r)
    }
    function be(e, t) {
        var i = this.cache;
        o(i, t) || (e.uniform2iv(this.addr, t),
        s(i, t))
    }
    function we(e, t) {
        var i = this.cache;
        o(i, t) || (e.uniform3iv(this.addr, t),
        s(i, t))
    }
    function ke(e, t) {
        var i = this.cache;
        o(i, t) || (e.uniform4iv(this.addr, t),
        s(i, t))
    }
    function Ve(e, t) {
        var i = this.cache;
        o(i, t) || (e.uniform1fv(this.addr, t),
        s(i, t))
    }
    function je(e, t) {
        var i = this.cache;
        o(i, t) || (e.uniform1iv(this.addr, t),
        s(i, t))
    }
    function We(e, t) {
        o(this.cache, t = se(t, this.size, 2)) || (e.uniform2fv(this.addr, t),
        this.updateCache(t))
    }
    function qe(e, t) {
        o(this.cache, t = se(t, this.size, 3)) || (e.uniform3fv(this.addr, t),
        this.updateCache(t))
    }
    function Xe(e, t) {
        o(this.cache, t = se(t, this.size, 4)) || (e.uniform4fv(this.addr, t),
        this.updateCache(t))
    }
    function Ye(e, t) {
        o(this.cache, t = se(t, this.size, 4)) || (e.uniformMatrix2fv(this.addr, !1, t),
        this.updateCache(t))
    }
    function Je(e, t) {
        o(this.cache, t = se(t, this.size, 9)) || (e.uniformMatrix3fv(this.addr, !1, t),
        this.updateCache(t))
    }
    function Ze(e, t) {
        o(this.cache, t = se(t, this.size, 16)) || (e.uniformMatrix4fv(this.addr, !1, t),
        this.updateCache(t))
    }
    function Qe(e, t, i) {
        var n = this.cache
          , r = t.length
          , a = ce(i, r);
        for (!1 === o(n, a) && (e.uniform1iv(this.addr, a),
        s(n, a)),
        e = 0; e !== r; ++e)
            i.setTexture2D(t[e] || fc, a[e])
    }
    function Ke(e, t, i) {
        var n = this.cache
          , r = t.length
          , a = ce(i, r);
        for (!1 === o(n, a) && (e.uniform1iv(this.addr, a),
        s(n, a)),
        e = 0; e !== r; ++e)
            i.setTextureCube(t[e] || gc, a[e])
    }
    function $e(e, t, i) {
        this.id = e,
        this.addr = i,
        this.cache = [],
        this.setValue = function(e) {
            switch (e) {
            case 5126:
                return he;
            case 35664:
                return ue;
            case 35665:
                return pe;
            case 35666:
                return de;
            case 35674:
                return fe;
            case 35675:
                return me;
            case 35676:
                return ge;
            case 35678:
            case 36198:
                return ve;
            case 35679:
                return ye;
            case 35680:
                return xe;
            case 5124:
            case 35670:
                return le;
            case 35667:
            case 35671:
                return be;
            case 35668:
            case 35672:
                return we;
            case 35669:
            case 35673:
                return ke
            }
        }(t.type)
    }
    function et(e, t, i) {
        this.id = e,
        this.addr = i,
        this.cache = [],
        this.size = t.size,
        this.setValue = function(e) {
            switch (e) {
            case 5126:
                return Ve;
            case 35664:
                return We;
            case 35665:
                return qe;
            case 35666:
                return Xe;
            case 35674:
                return Ye;
            case 35675:
                return Je;
            case 35676:
                return Ze;
            case 35678:
                return Qe;
            case 35680:
                return Ke;
            case 5124:
            case 35670:
                return je;
            case 35667:
            case 35671:
                return be;
            case 35668:
            case 35672:
                return we;
            case 35669:
            case 35673:
                return ke
            }
        }(t.type)
    }
    function tt(e) {
        this.id = e,
        this.seq = [],
        this.map = {}
    }
    function it(e, t, i) {
        this.seq = [],
        this.map = {},
        this.renderer = i,
        i = e.getProgramParameter(t, 35718);
        for (var n = 0; n < i; ++n) {
            var r = e.getActiveUniform(t, n)
              , a = e.getUniformLocation(t, r.name)
              , o = this
              , s = r.name
              , c = s.length;
            for (_c.lastIndex = 0; ; ) {
                var h = _c.exec(s)
                  , l = _c.lastIndex
                  , u = h[1]
                  , p = h[3];
                if ("]" === h[2] && (u |= 0),
                void 0 === p || "[" === p && l + 2 === c) {
                    s = o,
                    r = new (void 0 === p ? $e : et)(u,r,a),
                    s.seq.push(r),
                    s.map[r.id] = r;
                    break
                }
                void 0 === (p = o.map[u]) && (p = new tt(u),
                u = o,
                o = p,
                u.seq.push(o),
                u.map[o.id] = o),
                o = p
            }
        }
    }
    function nt(e, t, i) {
        var n = e.createShader(t);
        return e.shaderSource(n, i),
        e.compileShader(n),
        !1 === e.getShaderParameter(n, 35713) && console.error("THREE.WebGLShader: Shader couldn't compile."),
        "" !== e.getShaderInfoLog(n) && console.warn("THREE.WebGLShader: gl.getShaderInfoLog()", 35633 === t ? "vertex" : "fragment", e.getShaderInfoLog(n), function(e) {
            e = e.split("\n");
            for (var t = 0; t < e.length; t++)
                e[t] = t + 1 + ": " + e[t];
            return e.join("\n")
        }(i)),
        n
    }
    function rt(e) {
        switch (e) {
        case 3e3:
            return ["Linear", "( value )"];
        case 3001:
            return ["sRGB", "( value )"];
        case 3002:
            return ["RGBE", "( value )"];
        case 3004:
            return ["RGBM", "( value, 7.0 )"];
        case 3005:
            return ["RGBM", "( value, 16.0 )"];
        case 3006:
            return ["RGBD", "( value, 256.0 )"];
        case 3007:
            return ["Gamma", "( value, float( GAMMA_FACTOR ) )"];
        default:
            throw Error("unsupported encoding: " + e)
        }
    }
    function at(e, t) {
        return "vec4 " + e + "( vec4 value ) { return " + (t = rt(t))[0] + "ToLinear" + t[1] + "; }"
    }
    function ot(e) {
        return "" !== e
    }
    function st(e, t) {
        return e.replace(/NUM_DIR_LIGHTS/g, t.numDirLights).replace(/NUM_SPOT_LIGHTS/g, t.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g, t.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, t.numPointLights).replace(/NUM_HEMI_LIGHTS/g, t.numHemiLights)
    }
    function ct(e, t) {
        return e.replace(/NUM_CLIPPING_PLANES/g, t.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, t.numClippingPlanes - t.numClipIntersection)
    }
    function ht(e) {
        return e.replace(/^[ \t]*#include +<([\w\d./]+)>/gm, function(e, t) {
            if (void 0 === (e = T[t]))
                throw Error("Can not resolve #include <" + t + ">");
            return ht(e)
        })
    }
    function lt(e) {
        return e.replace(/#pragma unroll_loop[\s]+?for \( int i = (\d+); i < (\d+); i \+\+ \) \{([\s\S]+?)(?=\})\}/g, function(e, t, i, n) {
            for (e = "",
            t = parseInt(t); t < parseInt(i); t++)
                e += n.replace(/\[ i \]/g, "[ " + t + " ]");
            return e
        })
    }
    function ut(e, t, i, n, r, a, o) {
        var s = e.context
          , c = n.defines
          , h = r.vertexShader
          , l = r.fragmentShader
          , u = "SHADOWMAP_TYPE_BASIC"
          , p = (1 === a.shadowMapType ? u = "SHADOWMAP_TYPE_PCF" : 2 === a.shadowMapType && (u = "SHADOWMAP_TYPE_PCF_SOFT"),
        "ENVMAP_TYPE_CUBE")
          , d = "ENVMAP_MODE_REFLECTION"
          , f = "ENVMAP_BLENDING_MULTIPLY";
        if (a.envMap) {
            switch (n.envMap.mapping) {
            case 301:
            case 302:
                p = "ENVMAP_TYPE_CUBE";
                break;
            case 306:
            case 307:
                p = "ENVMAP_TYPE_CUBE_UV";
                break;
            case 303:
            case 304:
                p = "ENVMAP_TYPE_EQUIREC";
                break;
            case 305:
                p = "ENVMAP_TYPE_SPHERE"
            }
            switch (n.envMap.mapping) {
            case 302:
            case 304:
                d = "ENVMAP_MODE_REFRACTION"
            }
            switch (n.combine) {
            case 0:
                f = "ENVMAP_BLENDING_MULTIPLY";
                break;
            case 1:
                f = "ENVMAP_BLENDING_MIX";
                break;
            case 2:
                f = "ENVMAP_BLENDING_ADD"
            }
        }
        var m, g, v, y = 0 < e.gammaFactor ? e.gammaFactor : 1, x = o.isWebGL2 ? "" : (x = n.extensions,
        b = a,
        m = t,
        [(x = x || {}).derivatives || b.envMapCubeUV || b.bumpMap || b.normalMap && !b.objectSpaceNormalMap || b.flatShading ? "#extension GL_OES_standard_derivatives : enable" : "", (x.fragDepth || b.logarithmicDepthBuffer) && m.get("EXT_frag_depth") ? "#extension GL_EXT_frag_depth : enable" : "", x.drawBuffers && m.get("WEBGL_draw_buffers") ? "#extension GL_EXT_draw_buffers : require" : "", (x.shaderTextureLOD || b.envMap) && m.get("EXT_shader_texture_lod") ? "#extension GL_EXT_shader_texture_lod : enable" : ""].filter(ot).join("\n")), b = function(e) {
            var t, i = [];
            for (t in e) {
                var n = e[t];
                !1 !== n && i.push("#define " + t + " " + n)
            }
            return i.join("\n")
        }(c), w = s.createProgram();
        return n.isRawShaderMaterial ? (0 < (c = [b].filter(ot).join("\n")).length && (c += "\n"),
        0 < (t = [x, b].filter(ot).join("\n")).length && (t += "\n")) : (c = ["precision " + a.precision + " float;", "precision " + a.precision + " int;", "#define SHADER_NAME " + r.name, b, a.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "", "#define GAMMA_FACTOR " + y, "#define MAX_BONES " + a.maxBones, a.useFog && a.fog ? "#define USE_FOG" : "", a.useFog && a.fogExp ? "#define FOG_EXP2" : "", a.map ? "#define USE_MAP" : "", a.envMap ? "#define USE_ENVMAP" : "", a.envMap ? "#define " + d : "", a.lightMap ? "#define USE_LIGHTMAP" : "", a.aoMap ? "#define USE_AOMAP" : "", a.emissiveMap ? "#define USE_EMISSIVEMAP" : "", a.bumpMap ? "#define USE_BUMPMAP" : "", a.normalMap ? "#define USE_NORMALMAP" : "", a.normalMap && a.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", a.displacementMap && a.supportsVertexTextures ? "#define USE_DISPLACEMENTMAP" : "", a.specularMap ? "#define USE_SPECULARMAP" : "", a.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", a.metalnessMap ? "#define USE_METALNESSMAP" : "", a.alphaMap ? "#define USE_ALPHAMAP" : "", a.vertexColors ? "#define USE_COLOR" : "", a.flatShading ? "#define FLAT_SHADED" : "", a.skinning ? "#define USE_SKINNING" : "", a.useVertexTexture ? "#define BONE_TEXTURE" : "", a.morphTargets ? "#define USE_MORPHTARGETS" : "", a.morphNormals && !1 === a.flatShading ? "#define USE_MORPHNORMALS" : "", a.doubleSided ? "#define DOUBLE_SIDED" : "", a.flipSided ? "#define FLIP_SIDED" : "", a.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", a.shadowMapEnabled ? "#define " + u : "", a.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", a.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", a.logarithmicDepthBuffer && (o.isWebGL2 || t.get("EXT_frag_depth")) ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 modelMatrix;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;", "uniform mat3 normalMatrix;", "uniform vec3 cameraPosition;", "attribute vec3 position;", "attribute vec3 normal;", "attribute vec2 uv;", "#ifdef USE_COLOR", "\tattribute vec3 color;", "#endif", "#ifdef USE_MORPHTARGETS", "\tattribute vec3 morphTarget0;", "\tattribute vec3 morphTarget1;", "\tattribute vec3 morphTarget2;", "\tattribute vec3 morphTarget3;", "\t#ifdef USE_MORPHNORMALS", "\t\tattribute vec3 morphNormal0;", "\t\tattribute vec3 morphNormal1;", "\t\tattribute vec3 morphNormal2;", "\t\tattribute vec3 morphNormal3;", "\t#else", "\t\tattribute vec3 morphTarget4;", "\t\tattribute vec3 morphTarget5;", "\t\tattribute vec3 morphTarget6;", "\t\tattribute vec3 morphTarget7;", "\t#endif", "#endif", "#ifdef USE_SKINNING", "\tattribute vec4 skinIndex;", "\tattribute vec4 skinWeight;", "#endif", "\n"].filter(ot).join("\n"),
        t = [x, "precision " + a.precision + " float;", "precision " + a.precision + " int;", "#define SHADER_NAME " + r.name, b, a.alphaTest ? "#define ALPHATEST " + a.alphaTest + (a.alphaTest % 1 ? "" : ".0") : "", "#define GAMMA_FACTOR " + y, a.useFog && a.fog ? "#define USE_FOG" : "", a.useFog && a.fogExp ? "#define FOG_EXP2" : "", a.map ? "#define USE_MAP" : "", a.matcap ? "#define USE_MATCAP" : "", a.envMap ? "#define USE_ENVMAP" : "", a.envMap ? "#define " + p : "", a.envMap ? "#define " + d : "", a.envMap ? "#define " + f : "", a.lightMap ? "#define USE_LIGHTMAP" : "", a.aoMap ? "#define USE_AOMAP" : "", a.emissiveMap ? "#define USE_EMISSIVEMAP" : "", a.bumpMap ? "#define USE_BUMPMAP" : "", a.normalMap ? "#define USE_NORMALMAP" : "", a.normalMap && a.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", a.specularMap ? "#define USE_SPECULARMAP" : "", a.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", a.metalnessMap ? "#define USE_METALNESSMAP" : "", a.alphaMap ? "#define USE_ALPHAMAP" : "", a.vertexColors ? "#define USE_COLOR" : "", a.gradientMap ? "#define USE_GRADIENTMAP" : "", a.flatShading ? "#define FLAT_SHADED" : "", a.doubleSided ? "#define DOUBLE_SIDED" : "", a.flipSided ? "#define FLIP_SIDED" : "", a.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", a.shadowMapEnabled ? "#define " + u : "", a.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "", a.physicallyCorrectLights ? "#define PHYSICALLY_CORRECT_LIGHTS" : "", a.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", a.logarithmicDepthBuffer && (o.isWebGL2 || t.get("EXT_frag_depth")) ? "#define USE_LOGDEPTHBUF_EXT" : "", a.envMap && (o.isWebGL2 || t.get("EXT_shader_texture_lod")) ? "#define TEXTURE_LOD_EXT" : "", "uniform mat4 viewMatrix;", "uniform vec3 cameraPosition;", 0 !== a.toneMapping ? "#define TONE_MAPPING" : "", 0 !== a.toneMapping ? T.tonemapping_pars_fragment : "", 0 !== a.toneMapping ? function(e, t) {
            switch (t) {
            case 1:
                t = "Linear";
                break;
            case 2:
                t = "Reinhard";
                break;
            case 3:
                t = "Uncharted2";
                break;
            case 4:
                t = "OptimizedCineon";
                break;
            case 5:
                t = "ACESFilmic";
                break;
            default:
                throw Error("unsupported toneMapping: " + t)
            }
            return "vec3 " + e + "( vec3 color ) { return " + t + "ToneMapping( color ); }"
        }("toneMapping", a.toneMapping) : "", a.dithering ? "#define DITHERING" : "", a.outputEncoding || a.mapEncoding || a.matcapEncoding || a.envMapEncoding || a.emissiveMapEncoding ? T.encodings_pars_fragment : "", a.mapEncoding ? at("mapTexelToLinear", a.mapEncoding) : "", a.matcapEncoding ? at("matcapTexelToLinear", a.matcapEncoding) : "", a.envMapEncoding ? at("envMapTexelToLinear", a.envMapEncoding) : "", a.emissiveMapEncoding ? at("emissiveMapTexelToLinear", a.emissiveMapEncoding) : "", a.outputEncoding ? (m = "linearToOutputTexel",
        y = a.outputEncoding,
        "vec4 " + m + "( vec4 value ) { return LinearTo" + (y = rt(y))[0] + y[1] + "; }") : "", a.depthPacking ? "#define DEPTH_PACKING " + n.depthPacking : "", "\n"].filter(ot).join("\n")),
        h = ct(h = st(h = ht(h), a), a),
        l = ct(l = st(l = ht(l), a), a),
        h = lt(h),
        l = lt(l),
        o.isWebGL2 && !n.isRawShaderMaterial && (o = !1,
        u = /^\s*#version\s+300\s+es\s*\n/,
        n.isShaderMaterial && null !== h.match(u) && null !== l.match(u) && (o = !0,
        h = h.replace(u, ""),
        l = l.replace(u, "")),
        c = "#version 300 es\n\n#define attribute in\n#define varying out\n#define texture2D texture\n" + c,
        t = ["#version 300 es\n\n#define varying in", o ? "" : "out highp vec4 pc_fragColor;", o ? "" : "#define gl_FragColor pc_fragColor", "#define gl_FragDepthEXT gl_FragDepth\n#define texture2D texture\n#define textureCube texture\n#define texture2DProj textureProj\n#define texture2DLodEXT textureLod\n#define texture2DProjLodEXT textureProjLod\n#define textureCubeLodEXT textureLod\n#define texture2DGradEXT textureGrad\n#define texture2DProjGradEXT textureProjGrad\n#define textureCubeGradEXT textureGrad"].join("\n") + "\n" + t),
        l = t + l,
        h = nt(s, 35633, c + h),
        l = nt(s, 35632, l),
        s.attachShader(w, h),
        s.attachShader(w, l),
        void 0 !== n.index0AttributeName ? s.bindAttribLocation(w, 0, n.index0AttributeName) : !0 === a.morphTargets && s.bindAttribLocation(w, 0, "position"),
        s.linkProgram(w),
        a = s.getProgramInfoLog(w).trim(),
        o = s.getShaderInfoLog(h).trim(),
        u = s.getShaderInfoLog(l).trim(),
        !(d = p = !0) === s.getProgramParameter(w, 35714) ? (p = !1,
        console.error("THREE.WebGLProgram: shader error: ", s.getError(), "35715", s.getProgramParameter(w, 35715), "gl.getProgramInfoLog", a, o, u)) : "" !== a ? console.warn("THREE.WebGLProgram: gl.getProgramInfoLog()", a) : "" !== o && "" !== u || (d = !1),
        d && (this.diagnostics = {
            runnable: p,
            material: n,
            programLog: a,
            vertexShader: {
                log: o,
                prefix: c
            },
            fragmentShader: {
                log: u,
                prefix: t
            }
        }),
        s.deleteShader(h),
        s.deleteShader(l),
        this.getUniforms = function() {
            return g = void 0 === g ? new it(s,w,e) : g
        }
        ,
        this.getAttributes = function() {
            if (void 0 === v) {
                for (var e = {}, t = s.getProgramParameter(w, 35721), i = 0; i < t; i++) {
                    var n = s.getActiveAttrib(w, i).name;
                    e[n] = s.getAttribLocation(w, n)
                }
                v = e
            }
            return v
        }
        ,
        this.destroy = function() {
            s.deleteProgram(w),
            this.program = void 0
        }
        ,
        Object.defineProperties(this, {
            uniforms: {
                get: function() {
                    return console.warn("THREE.WebGLProgram: .uniforms is now .getUniforms()."),
                    this.getUniforms()
                }
            },
            attributes: {
                get: function() {
                    return console.warn("THREE.WebGLProgram: .attributes is now .getAttributes()."),
                    this.getAttributes()
                }
            }
        }),
        this.name = r.name,
        this.id = Mc++,
        this.code = i,
        this.usedTimes = 1,
        this.program = w,
        this.vertexShader = h,
        this.fragmentShader = l,
        this
    }
    function pt(u, c, p) {
        function d(e, t) {
            var i;
            return e ? e.isTexture ? i = e.encoding : e.isWebGLRenderTarget && (console.warn("THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead."),
            i = e.texture.encoding) : i = 3e3,
            i = 3e3 === i && t ? 3007 : i
        }
        var h = []
          , f = {
            MeshDepthMaterial: "depth",
            MeshDistanceMaterial: "distanceRGBA",
            MeshNormalMaterial: "normal",
            MeshBasicMaterial: "basic",
            MeshLambertMaterial: "lambert",
            MeshPhongMaterial: "phong",
            MeshToonMaterial: "phong",
            MeshStandardMaterial: "physical",
            MeshPhysicalMaterial: "physical",
            MeshMatcapMaterial: "matcap",
            LineBasicMaterial: "basic",
            LineDashedMaterial: "dashed",
            PointsMaterial: "points",
            ShadowMaterial: "shadow",
            SpriteMaterial: "sprite"
        }
          , r = "precision supportsVertexTextures map mapEncoding matcap matcapEncoding envMap envMapMode envMapEncoding lightMap aoMap emissiveMap emissiveMapEncoding bumpMap normalMap objectSpaceNormalMap displacementMap specularMap roughnessMap metalnessMap gradientMap alphaMap combine vertexColors fog useFog fogExp flatShading sizeAttenuation logarithmicDepthBuffer skinning maxBones useVertexTexture morphTargets morphNormals maxMorphTargets maxMorphNormals premultipliedAlpha numDirLights numPointLights numSpotLights numHemiLights numRectAreaLights shadowMapEnabled shadowMapType toneMapping physicallyCorrectLights alphaTest doubleSided flipSided numClippingPlanes numClipIntersection depthPacking dithering".split(" ");
        this.getParameters = function(e, t, i, n, r, a, o) {
            var s, c, h = f[e.type], l = (c = o.isSkinnedMesh ? (c = o.skeleton.bones,
            p.floatVertexTextures ? 1024 : (s = Math.min(Math.floor((p.maxVertexUniforms - 20) / 4), c.length)) < c.length ? (console.warn("THREE.WebGLRenderer: Skeleton has " + c.length + " bones. This GPU supports " + s + "."),
            0) : s) : 0,
            s = p.precision,
            null !== e.precision && (s = p.getMaxPrecision(e.precision)) !== e.precision && console.warn("THREE.WebGLProgram.getParameters:", e.precision, "not supported, using", s, "instead."),
            u.getRenderTarget());
            return {
                shaderID: h,
                precision: s,
                supportsVertexTextures: p.vertexTextures,
                outputEncoding: d(l ? l.texture : null, u.gammaOutput),
                map: !!e.map,
                mapEncoding: d(e.map, u.gammaInput),
                matcap: !!e.matcap,
                matcapEncoding: d(e.matcap, u.gammaInput),
                envMap: !!e.envMap,
                envMapMode: e.envMap && e.envMap.mapping,
                envMapEncoding: d(e.envMap, u.gammaInput),
                envMapCubeUV: !!e.envMap && (306 === e.envMap.mapping || 307 === e.envMap.mapping),
                lightMap: !!e.lightMap,
                aoMap: !!e.aoMap,
                emissiveMap: !!e.emissiveMap,
                emissiveMapEncoding: d(e.emissiveMap, u.gammaInput),
                bumpMap: !!e.bumpMap,
                normalMap: !!e.normalMap,
                objectSpaceNormalMap: 1 === e.normalMapType,
                displacementMap: !!e.displacementMap,
                roughnessMap: !!e.roughnessMap,
                metalnessMap: !!e.metalnessMap,
                specularMap: !!e.specularMap,
                alphaMap: !!e.alphaMap,
                gradientMap: !!e.gradientMap,
                combine: e.combine,
                vertexColors: e.vertexColors,
                fog: !!n,
                useFog: e.fog,
                fogExp: n && n.isFogExp2,
                flatShading: e.flatShading,
                sizeAttenuation: e.sizeAttenuation,
                logarithmicDepthBuffer: p.logarithmicDepthBuffer,
                skinning: e.skinning && 0 < c,
                maxBones: c,
                useVertexTexture: p.floatVertexTextures,
                morphTargets: e.morphTargets,
                morphNormals: e.morphNormals,
                maxMorphTargets: u.maxMorphTargets,
                maxMorphNormals: u.maxMorphNormals,
                numDirLights: t.directional.length,
                numPointLights: t.point.length,
                numSpotLights: t.spot.length,
                numRectAreaLights: t.rectArea.length,
                numHemiLights: t.hemi.length,
                numClippingPlanes: r,
                numClipIntersection: a,
                dithering: e.dithering,
                shadowMapEnabled: u.shadowMap.enabled && o.receiveShadow && 0 < i.length,
                shadowMapType: u.shadowMap.type,
                toneMapping: u.toneMapping,
                physicallyCorrectLights: u.physicallyCorrectLights,
                premultipliedAlpha: e.premultipliedAlpha,
                alphaTest: e.alphaTest,
                doubleSided: 2 === e.side,
                flipSided: 1 === e.side,
                depthPacking: void 0 !== e.depthPacking && e.depthPacking
            }
        }
        ,
        this.getProgramCode = function(e, t) {
            var i = [];
            if (t.shaderID ? i.push(t.shaderID) : (i.push(e.fragmentShader),
            i.push(e.vertexShader)),
            void 0 !== e.defines)
                for (var n in e.defines)
                    i.push(n),
                    i.push(e.defines[n]);
            for (n = 0; n < r.length; n++)
                i.push(t[r[n]]);
            return i.push(e.onBeforeCompile.toString()),
            i.push(u.gammaOutput),
            i.push(u.gammaFactor),
            i.join()
        }
        ,
        this.acquireProgram = function(e, t, i, n) {
            for (var r, a = 0, o = h.length; a < o; a++) {
                var s = h[a];
                if (s.code === n) {
                    ++(r = s).usedTimes;
                    break
                }
            }
            return void 0 === r && (r = new ut(u,c,n,e,t,i,p),
            h.push(r)),
            r
        }
        ,
        this.releaseProgram = function(e) {
            var t;
            0 == --e.usedTimes && (t = h.indexOf(e),
            h[t] = h[h.length - 1],
            h.pop(),
            e.destroy())
        }
        ,
        this.programs = h
    }
    function dt() {
        var n = new WeakMap;
        return {
            get: function(e) {
                var t = n.get(e);
                return void 0 === t && n.set(e, t = {}),
                t
            },
            remove: function(e) {
                n.delete(e)
            },
            update: function(e, t, i) {
                n.get(e)[t] = i
            },
            dispose: function() {
                n = new WeakMap
            }
        }
    }
    function ft(e, t) {
        return e.groupOrder !== t.groupOrder ? e.groupOrder - t.groupOrder : e.renderOrder !== t.renderOrder ? e.renderOrder - t.renderOrder : e.program && t.program && e.program !== t.program ? e.program.id - t.program.id : e.material.id !== t.material.id ? e.material.id - t.material.id : e.z !== t.z ? e.z - t.z : e.id - t.id
    }
    function mt(e, t) {
        return e.groupOrder !== t.groupOrder ? e.groupOrder - t.groupOrder : e.renderOrder !== t.renderOrder ? e.renderOrder - t.renderOrder : e.z !== t.z ? t.z - e.z : e.id - t.id
    }
    function gt() {
        function o(e, t, i, n, r, a) {
            var o = s[c];
            return void 0 === o ? (o = {
                id: e.id,
                object: e,
                geometry: t,
                material: i,
                program: i.program,
                groupOrder: n,
                renderOrder: e.renderOrder,
                z: r,
                group: a
            },
            s[c] = o) : (o.id = e.id,
            o.object = e,
            o.geometry = t,
            o.material = i,
            o.program = i.program,
            o.groupOrder = n,
            o.renderOrder = e.renderOrder,
            o.z = r,
            o.group = a),
            c++,
            o
        }
        var s = []
          , c = 0
          , h = []
          , l = [];
        return {
            opaque: h,
            transparent: l,
            init: function() {
                c = 0,
                l.length = h.length = 0
            },
            push: function(e, t, i, n, r, a) {
                e = o(e, t, i, n, r, a),
                (!0 === i.transparent ? l : h).push(e)
            },
            unshift: function(e, t, i, n, r, a) {
                e = o(e, t, i, n, r, a),
                (!0 === i.transparent ? l : h).unshift(e)
            },
            sort: function() {
                1 < h.length && h.sort(ft),
                1 < l.length && l.sort(mt)
            }
        }
    }
    function vt() {
        function r(e) {
            (e = e.target).removeEventListener("dispose", r),
            delete a[e.id]
        }
        var a = {};
        return {
            get: function(e, t) {
                var i, n = a[e.id];
                return void 0 === n ? (i = new gt,
                a[e.id] = {},
                a[e.id][t.id] = i,
                e.addEventListener("dispose", r)) : void 0 === (i = n[t.id]) && (i = new gt,
                n[t.id] = i),
                i
            },
            dispose: function() {
                a = {}
            }
        }
    }
    function yt() {
        var i = {};
        return {
            get: function(e) {
                if (void 0 !== i[e.id])
                    return i[e.id];
                switch (e.type) {
                case "DirectionalLight":
                    var t = {
                        direction: new Me,
                        color: new d,
                        shadow: !1,
                        shadowBias: 0,
                        shadowRadius: 1,
                        shadowMapSize: new Y
                    };
                    break;
                case "SpotLight":
                    t = {
                        position: new Me,
                        direction: new Me,
                        color: new d,
                        distance: 0,
                        coneCos: 0,
                        penumbraCos: 0,
                        decay: 0,
                        shadow: !1,
                        shadowBias: 0,
                        shadowRadius: 1,
                        shadowMapSize: new Y
                    };
                    break;
                case "PointLight":
                    t = {
                        position: new Me,
                        color: new d,
                        distance: 0,
                        decay: 0,
                        shadow: !1,
                        shadowBias: 0,
                        shadowRadius: 1,
                        shadowMapSize: new Y,
                        shadowCameraNear: 1,
                        shadowCameraFar: 1e3
                    };
                    break;
                case "HemisphereLight":
                    t = {
                        direction: new Me,
                        skyColor: new d,
                        groundColor: new d
                    };
                    break;
                case "RectAreaLight":
                    t = {
                        color: new d,
                        position: new Me,
                        halfWidth: new Me,
                        halfHeight: new Me
                    }
                }
                return i[e.id] = t
            }
        }
    }
    function xt() {
        var x = new yt
          , b = {
            id: Ec++,
            hash: {
                stateID: -1,
                directionalLength: -1,
                pointLength: -1,
                spotLength: -1,
                rectAreaLength: -1,
                hemiLength: -1,
                shadowsLength: -1
            },
            ambient: [0, 0, 0],
            directional: [],
            directionalShadowMap: [],
            directionalShadowMatrix: [],
            spot: [],
            spotShadowMap: [],
            spotShadowMatrix: [],
            rectArea: [],
            point: [],
            pointShadowMap: [],
            pointShadowMatrix: [],
            hemi: []
        }
          , w = new Me
          , _ = new _e
          , M = new _e;
        return {
            setup: function(e, t, i) {
                var n = 0
                  , r = 0
                  , a = 0
                  , o = 0
                  , s = 0
                  , c = 0
                  , h = 0
                  , l = 0;
                i = i.matrixWorldInverse;
                for (var u = 0, p = e.length; u < p; u++) {
                    var d, f = e[u], m = f.color, g = f.intensity, v = f.distance, y = f.shadow && f.shadow.map ? f.shadow.map.texture : null;
                    f.isAmbientLight ? (n += m.r * g,
                    r += m.g * g,
                    a += m.b * g) : f.isDirectionalLight ? ((d = x.get(f)).color.copy(f.color).multiplyScalar(f.intensity),
                    d.direction.setFromMatrixPosition(f.matrixWorld),
                    w.setFromMatrixPosition(f.target.matrixWorld),
                    d.direction.sub(w),
                    d.direction.transformDirection(i),
                    (d.shadow = f.castShadow) && (m = f.shadow,
                    d.shadowBias = m.bias,
                    d.shadowRadius = m.radius,
                    d.shadowMapSize = m.mapSize),
                    b.directionalShadowMap[o] = y,
                    b.directionalShadowMatrix[o] = f.shadow.matrix,
                    b.directional[o] = d,
                    o++) : f.isSpotLight ? ((d = x.get(f)).position.setFromMatrixPosition(f.matrixWorld),
                    d.position.applyMatrix4(i),
                    d.color.copy(m).multiplyScalar(g),
                    d.distance = v,
                    d.direction.setFromMatrixPosition(f.matrixWorld),
                    w.setFromMatrixPosition(f.target.matrixWorld),
                    d.direction.sub(w),
                    d.direction.transformDirection(i),
                    d.coneCos = Math.cos(f.angle),
                    d.penumbraCos = Math.cos(f.angle * (1 - f.penumbra)),
                    d.decay = f.decay,
                    (d.shadow = f.castShadow) && (m = f.shadow,
                    d.shadowBias = m.bias,
                    d.shadowRadius = m.radius,
                    d.shadowMapSize = m.mapSize),
                    b.spotShadowMap[c] = y,
                    b.spotShadowMatrix[c] = f.shadow.matrix,
                    b.spot[c] = d,
                    c++) : f.isRectAreaLight ? ((d = x.get(f)).color.copy(m).multiplyScalar(g),
                    d.position.setFromMatrixPosition(f.matrixWorld),
                    d.position.applyMatrix4(i),
                    M.identity(),
                    _.copy(f.matrixWorld),
                    _.premultiply(i),
                    M.extractRotation(_),
                    d.halfWidth.set(.5 * f.width, 0, 0),
                    d.halfHeight.set(0, .5 * f.height, 0),
                    d.halfWidth.applyMatrix4(M),
                    d.halfHeight.applyMatrix4(M),
                    b.rectArea[h] = d,
                    h++) : f.isPointLight ? ((d = x.get(f)).position.setFromMatrixPosition(f.matrixWorld),
                    d.position.applyMatrix4(i),
                    d.color.copy(f.color).multiplyScalar(f.intensity),
                    d.distance = f.distance,
                    d.decay = f.decay,
                    (d.shadow = f.castShadow) && (m = f.shadow,
                    d.shadowBias = m.bias,
                    d.shadowRadius = m.radius,
                    d.shadowMapSize = m.mapSize,
                    d.shadowCameraNear = m.camera.near,
                    d.shadowCameraFar = m.camera.far),
                    b.pointShadowMap[s] = y,
                    b.pointShadowMatrix[s] = f.shadow.matrix,
                    b.point[s] = d,
                    s++) : f.isHemisphereLight && ((d = x.get(f)).direction.setFromMatrixPosition(f.matrixWorld),
                    d.direction.transformDirection(i),
                    d.direction.normalize(),
                    d.skyColor.copy(f.color).multiplyScalar(g),
                    d.groundColor.copy(f.groundColor).multiplyScalar(g),
                    b.hemi[l] = d,
                    l++)
                }
                b.ambient[0] = n,
                b.ambient[1] = r,
                b.ambient[2] = a,
                b.directional.length = o,
                b.spot.length = c,
                b.rectArea.length = h,
                b.point.length = s,
                b.hemi.length = l,
                b.hash.stateID = b.id,
                b.hash.directionalLength = o,
                b.hash.pointLength = s,
                b.hash.spotLength = c,
                b.hash.rectAreaLength = h,
                b.hash.hemiLength = l,
                b.hash.shadowsLength = t.length
            },
            state: b
        }
    }
    function bt() {
        var t = new xt
          , i = []
          , n = [];
        return {
            init: function() {
                n.length = i.length = 0
            },
            state: {
                lightsArray: i,
                shadowsArray: n,
                lights: t
            },
            setupLights: function(e) {
                t.setup(i, n, e)
            },
            pushLight: function(e) {
                i.push(e)
            },
            pushShadow: function(e) {
                n.push(e)
            }
        }
    }
    function wt() {
        function n(e) {
            (e = e.target).removeEventListener("dispose", n),
            delete r[e.id]
        }
        var r = {};
        return {
            get: function(e, t) {
                var i;
                return void 0 === r[e.id] ? (i = new bt,
                r[e.id] = {},
                r[e.id][t.id] = i,
                e.addEventListener("dispose", n)) : void 0 === r[e.id][t.id] ? (i = new bt,
                r[e.id][t.id] = i) : i = r[e.id][t.id],
                i
            },
            dispose: function() {
                r = {}
            }
        }
    }
    function _t(e) {
        a.call(this),
        this.type = "MeshDepthMaterial",
        this.depthPacking = 3200,
        this.morphTargets = this.skinning = !1,
        this.displacementMap = this.alphaMap = this.map = null,
        this.displacementScale = 1,
        this.displacementBias = 0,
        this.wireframe = !1,
        this.wireframeLinewidth = 1,
        this.lights = this.fog = !1,
        this.setValues(e)
    }
    function Mt(e) {
        a.call(this),
        this.type = "MeshDistanceMaterial",
        this.referencePosition = new Me,
        this.nearDistance = 1,
        this.farDistance = 1e3,
        this.morphTargets = this.skinning = !1,
        this.displacementMap = this.alphaMap = this.map = null,
        this.displacementScale = 1,
        this.displacementBias = 0,
        this.lights = this.fog = !1,
        this.setValues(e)
    }
    function Et(p, d, e) {
        function f(e, t, i, n, r, a) {
            var o = e.geometry
              , s = h
              , c = e.customDepthMaterial;
            return i && (s = l,
            c = e.customDistanceMaterial),
            s = c || (c = !1,
            t.morphTargets && (o && o.isBufferGeometry ? c = o.morphAttributes && o.morphAttributes.position && 0 < o.morphAttributes.position.length : o && o.isGeometry && (c = o.morphTargets && 0 < o.morphTargets.length)),
            e.isSkinnedMesh && !1 === t.skinning && console.warn("THREE.WebGLShadowMap: THREE.SkinnedMesh with material.skinning set to false:", e),
            o = 0,
            c && (o |= 1),
            (e = e.isSkinnedMesh && t.skinning) && (o |= 2),
            s[o]),
            p.localClippingEnabled && !0 === t.clipShadows && 0 !== t.clippingPlanes.length && (o = s.uuid,
            c = t.uuid,
            void 0 === (e = u[o]) && (u[o] = e = {}),
            void 0 === (o = e[c]) && (o = s.clone(),
            e[c] = o),
            s = o),
            s.visible = t.visible,
            s.wireframe = t.wireframe,
            s.side = null != t.shadowSide ? t.shadowSide : w[t.side],
            s.clipShadows = t.clipShadows,
            s.clippingPlanes = t.clippingPlanes,
            s.clipIntersection = t.clipIntersection,
            s.wireframeLinewidth = t.wireframeLinewidth,
            s.linewidth = t.linewidth,
            i && s.isMeshDistanceMaterial && (s.referencePosition.copy(n),
            s.nearDistance = r,
            s.farDistance = a),
            s
        }
        var m = new Le
          , g = new _e
          , v = new Y
          , y = new Y(e,e)
          , x = new Me
          , b = new Me
          , h = Array(4)
          , l = Array(4)
          , u = {}
          , w = {
            0: 1,
            1: 0,
            2: 2
        }
          , _ = [new Me(1,0,0), new Me(-1,0,0), new Me(0,0,1), new Me(0,0,-1), new Me(0,1,0), new Me(0,-1,0)]
          , M = [new Me(0,1,0), new Me(0,1,0), new Me(0,1,0), new Me(0,1,0), new Me(0,0,1), new Me(0,0,-1)]
          , E = [new Ee, new Ee, new Ee, new Ee, new Ee, new Ee];
        for (e = 0; 4 !== e; ++e) {
            var t = 0 != (1 & e)
              , i = 0 != (2 & e)
              , n = new _t({
                depthPacking: 3201,
                morphTargets: t,
                skinning: i
            });
            h[e] = n,
            t = new Mt({
                morphTargets: t,
                skinning: i
            }),
            l[e] = t
        }
        var S = this;
        this.enabled = !1,
        this.autoUpdate = !0,
        this.needsUpdate = !1,
        this.type = 1,
        this.render = function(e, t, i) {
            if (!1 !== S.enabled && (!1 !== S.autoUpdate || !1 !== S.needsUpdate) && 0 !== e.length) {
                var n = p.state;
                n.setBlending(0),
                n.buffers.color.setClear(1, 1, 1, 1),
                n.buffers.depth.setTest(!0),
                n.setScissorTest(!1);
                for (var r = 0, a = e.length; r < a; r++) {
                    var o = e[r]
                      , s = o.shadow
                      , c = o && o.isPointLight;
                    if (void 0 === s)
                        console.warn("THREE.WebGLShadowMap:", o, "has no shadow.");
                    else {
                        var h, l, u = s.camera;
                        for (v.copy(s.mapSize),
                        v.min(y),
                        c && (h = v.x,
                        l = v.y,
                        E[0].set(2 * h, l, h, l),
                        E[1].set(0, l, h, l),
                        E[2].set(3 * h, l, h, l),
                        E[3].set(h, l, h, l),
                        E[4].set(3 * h, 0, h, l),
                        E[5].set(h, 0, h, l),
                        v.x *= 4,
                        v.y *= 2),
                        null === s.map && (s.map = new P(v.x,v.y,{
                            minFilter: 1003,
                            magFilter: 1003,
                            format: 1023
                        }),
                        s.map.texture.name = o.name + ".shadowMap",
                        u.updateProjectionMatrix()),
                        s.isSpotLightShadow && s.update(o),
                        h = s.map,
                        l = s.matrix,
                        b.setFromMatrixPosition(o.matrixWorld),
                        u.position.copy(b),
                        c ? (s = 6,
                        l.makeTranslation(-b.x, -b.y, -b.z)) : (s = 1,
                        x.setFromMatrixPosition(o.target.matrixWorld),
                        u.lookAt(x),
                        u.updateMatrixWorld(),
                        l.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1),
                        l.multiply(u.projectionMatrix),
                        l.multiply(u.matrixWorldInverse)),
                        p.setRenderTarget(h),
                        p.clear(),
                        o = 0; o < s; o++)
                            c && (x.copy(u.position),
                            x.add(_[o]),
                            u.up.copy(M[o]),
                            u.lookAt(x),
                            u.updateMatrixWorld(),
                            n.viewport(E[o])),
                            g.multiplyMatrices(u.projectionMatrix, u.matrixWorldInverse),
                            m.setFromMatrix(g),
                            function e(t, i, n, r) {
                                if (!1 !== t.visible) {
                                    if (t.layers.test(i.layers) && (t.isMesh || t.isLine || t.isPoints) && t.castShadow && (!t.frustumCulled || m.intersectsObject(t))) {
                                        t.modelViewMatrix.multiplyMatrices(n.matrixWorldInverse, t.matrixWorld);
                                        var a = d.update(t)
                                          , o = t.material;
                                        if (Array.isArray(o))
                                            for (var s = a.groups, c = 0, h = s.length; c < h; c++) {
                                                var l = s[c]
                                                  , u = o[l.materialIndex];
                                                u && u.visible && (u = f(t, u, r, b, n.near, n.far),
                                                p.renderBufferDirect(n, null, a, u, t, l))
                                            }
                                        else
                                            o.visible && (u = f(t, o, r, b, n.near, n.far),
                                            p.renderBufferDirect(n, null, a, u, t, null))
                                    }
                                    for (a = 0,
                                    o = (t = t.children).length; a < o; a++)
                                        e(t[a], i, n, r)
                                }
                            }(t, i, u, c)
                    }
                }
                S.needsUpdate = !1
            }
        }
    }
    function St(l, i, c, n) {
        function e(e, t, i) {
            var n = new Uint8Array(4)
              , r = l.createTexture();
            for (l.bindTexture(e, r),
            l.texParameteri(e, 10241, 9728),
            l.texParameteri(e, 10240, 9728),
            e = 0; e < i; e++)
                l.texImage2D(t + e, 0, 6408, 1, 1, 0, 6408, 5121, n);
            return r
        }
        function t(e, t) {
            g[e] = 1,
            0 === v[e] && (l.enableVertexAttribArray(e),
            v[e] = 1),
            z[e] !== t && ((n.isWebGL2 ? l : i.get("ANGLE_instanced_arrays"))[n.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"](e, t),
            z[e] = t)
        }
        function u(e) {
            !0 !== y[e] && (l.enable(e),
            y[e] = !0)
        }
        function p(e) {
            !1 !== y[e] && (l.disable(e),
            y[e] = !1)
        }
        function r(e, t, i, n, r, a, o, s) {
            if (0 === e)
                w && (p(3042),
                w = !1);
            else if (w || (u(3042),
            w = !0),
            5 !== e) {
                if (e !== _ || s !== P) {
                    if (100 === M && 100 === T || (l.blendEquation(32774),
                    T = M = 100),
                    s)
                        switch (e) {
                        case 1:
                            l.blendFuncSeparate(1, 771, 1, 771);
                            break;
                        case 2:
                            l.blendFunc(1, 1);
                            break;
                        case 3:
                            l.blendFuncSeparate(0, 0, 769, 771);
                            break;
                        case 4:
                            l.blendFuncSeparate(0, 768, 0, 770);
                            break;
                        default:
                            console.error("THREE.WebGLState: Invalid blending: ", e)
                        }
                    else
                        switch (e) {
                        case 1:
                            l.blendFuncSeparate(770, 771, 1, 771);
                            break;
                        case 2:
                            l.blendFunc(770, 1);
                            break;
                        case 3:
                            l.blendFunc(0, 769);
                            break;
                        case 4:
                            l.blendFunc(0, 768);
                            break;
                        default:
                            console.error("THREE.WebGLState: Invalid blending: ", e)
                        }
                    L = A = S = E = null,
                    _ = e,
                    P = s
                }
            } else
                r = r || t,
                a = a || i,
                o = o || n,
                t === M && r === T || (l.blendEquationSeparate(c.convert(t), c.convert(r)),
                M = t,
                T = r),
                i === E && n === S && a === A && o === L || (l.blendFuncSeparate(c.convert(i), c.convert(n), c.convert(a), c.convert(o)),
                E = i,
                S = n,
                A = a,
                L = o),
                _ = e,
                P = null
        }
        function a(e) {
            R !== e && (e ? l.frontFace(2304) : l.frontFace(2305),
            R = e)
        }
        function o(e) {
            0 !== e ? (u(2884),
            e !== C && (1 === e ? l.cullFace(1029) : 2 === e ? l.cullFace(1028) : l.cullFace(1032))) : p(2884),
            C = e
        }
        function s(e, t, i) {
            e ? (u(32823),
            G === t && F === i || (l.polygonOffset(t, i),
            G = t,
            F = i)) : p(32823)
        }
        function N(e) {
            I !== (e = void 0 === e ? 33984 + H - 1 : e) && (l.activeTexture(e),
            I = e)
        }
        var h = new function() {
            var t = !1
              , a = new Ee
              , i = null
              , o = new Ee(0,0,0,0);
            return {
                setMask: function(e) {
                    i === e || t || (l.colorMask(e, e, e, e),
                    i = e)
                },
                setLocked: function(e) {
                    t = e
                },
                setClear: function(e, t, i, n, r) {
                    !0 === r && (e *= n,
                    t *= n,
                    i *= n),
                    a.set(e, t, i, n),
                    !1 === o.equals(a) && (l.clearColor(e, t, i, n),
                    o.copy(a))
                },
                reset: function() {
                    t = !1,
                    i = null,
                    o.set(-1, 0, 0, 0)
                }
            }
        }
          , d = new function() {
            var t = !1
              , i = null
              , n = null
              , r = null;
            return {
                setTest: function(e) {
                    (e ? u : p)(2929)
                },
                setMask: function(e) {
                    i === e || t || (l.depthMask(e),
                    i = e)
                },
                setFunc: function(e) {
                    if (n !== e) {
                        if (e)
                            switch (e) {
                            case 0:
                                l.depthFunc(512);
                                break;
                            case 1:
                                l.depthFunc(519);
                                break;
                            case 2:
                                l.depthFunc(513);
                                break;
                            case 3:
                                l.depthFunc(515);
                                break;
                            case 4:
                                l.depthFunc(514);
                                break;
                            case 5:
                                l.depthFunc(518);
                                break;
                            case 6:
                                l.depthFunc(516);
                                break;
                            case 7:
                                l.depthFunc(517);
                                break;
                            default:
                                l.depthFunc(515)
                            }
                        else
                            l.depthFunc(515);
                        n = e
                    }
                },
                setLocked: function(e) {
                    t = e
                },
                setClear: function(e) {
                    r !== e && (l.clearDepth(e),
                    r = e)
                },
                reset: function() {
                    t = !1,
                    r = n = i = null
                }
            }
        }
          , f = new function() {
            var t = !1
              , i = null
              , n = null
              , r = null
              , a = null
              , o = null
              , s = null
              , c = null
              , h = null;
            return {
                setTest: function(e) {
                    (e ? u : p)(2960)
                },
                setMask: function(e) {
                    i === e || t || (l.stencilMask(e),
                    i = e)
                },
                setFunc: function(e, t, i) {
                    n === e && r === t && a === i || (l.stencilFunc(e, t, i),
                    n = e,
                    r = t,
                    a = i)
                },
                setOp: function(e, t, i) {
                    o === e && s === t && c === i || (l.stencilOp(e, t, i),
                    o = e,
                    s = t,
                    c = i)
                },
                setLocked: function(e) {
                    t = e
                },
                setClear: function(e) {
                    h !== e && (l.clearStencil(e),
                    h = e)
                },
                reset: function() {
                    t = !1,
                    h = c = s = o = a = r = n = i = null
                }
            }
        }
          , m = l.getParameter(34921)
          , g = new Uint8Array(m)
          , v = new Uint8Array(m)
          , z = new Uint8Array(m)
          , y = {}
          , x = null
          , b = null
          , w = null
          , _ = null
          , M = null
          , E = null
          , S = null
          , T = null
          , A = null
          , L = null
          , P = !1
          , R = null
          , C = null
          , U = null
          , G = null
          , F = null
          , H = l.getParameter(35661)
          , O = !1
          , m = 0
          , I = (-1 !== (m = l.getParameter(7938)).indexOf("WebGL") ? (m = parseFloat(/^WebGL ([0-9])/.exec(m)[1]),
        O = 1 <= m) : -1 !== m.indexOf("OpenGL ES") && (m = parseFloat(/^OpenGL ES ([0-9])/.exec(m)[1]),
        O = 2 <= m),
        null)
          , D = {}
          , k = new Ee
          , V = new Ee
          , B = {};
        return B[3553] = e(3553, 3553, 1),
        B[34067] = e(34067, 34069, 6),
        h.setClear(0, 0, 0, 1),
        d.setClear(1),
        f.setClear(0),
        u(2929),
        d.setFunc(3),
        a(!1),
        o(1),
        u(2884),
        r(0),
        {
            buffers: {
                color: h,
                depth: d,
                stencil: f
            },
            initAttributes: function() {
                for (var e = 0, t = g.length; e < t; e++)
                    g[e] = 0
            },
            enableAttribute: function(e) {
                t(e, 0)
            },
            enableAttributeAndDivisor: t,
            disableUnusedAttributes: function() {
                for (var e = 0, t = v.length; e !== t; ++e)
                    v[e] !== g[e] && (l.disableVertexAttribArray(e),
                    v[e] = 0)
            },
            enable: u,
            disable: p,
            getCompressedTextureFormats: function() {
                if (null === x && (x = [],
                i.get("WEBGL_compressed_texture_pvrtc") || i.get("WEBGL_compressed_texture_s3tc") || i.get("WEBGL_compressed_texture_etc1") || i.get("WEBGL_compressed_texture_astc")))
                    for (var e = l.getParameter(34467), t = 0; t < e.length; t++)
                        x.push(e[t]);
                return x
            },
            useProgram: function(e) {
                return b !== e && (l.useProgram(e),
                b = e,
                !0)
            },
            setBlending: r,
            setMaterial: function(e, t) {
                (2 === e.side ? p : u)(2884);
                var i = 1 === e.side;
                a(i = t ? !i : i),
                1 === e.blending && !1 === e.transparent ? r(0) : r(e.blending, e.blendEquation, e.blendSrc, e.blendDst, e.blendEquationAlpha, e.blendSrcAlpha, e.blendDstAlpha, e.premultipliedAlpha),
                d.setFunc(e.depthFunc),
                d.setTest(e.depthTest),
                d.setMask(e.depthWrite),
                h.setMask(e.colorWrite),
                s(e.polygonOffset, e.polygonOffsetFactor, e.polygonOffsetUnits)
            },
            setFlipSided: a,
            setCullFace: o,
            setLineWidth: function(e) {
                e !== U && (O && l.lineWidth(e),
                U = e)
            },
            setPolygonOffset: s,
            setScissorTest: function(e) {
                (e ? u : p)(3089)
            },
            activeTexture: N,
            bindTexture: function(e, t) {
                null === I && N();
                var i = D[I];
                void 0 === i && (D[I] = i = {
                    type: void 0,
                    texture: void 0
                }),
                i.type === e && i.texture === t || (l.bindTexture(e, t || B[e]),
                i.type = e,
                i.texture = t)
            },
            compressedTexImage2D: function() {
                try {
                    l.compressedTexImage2D.apply(l, arguments)
                } catch (e) {
                    console.error("THREE.WebGLState:", e)
                }
            },
            texImage2D: function() {
                try {
                    l.texImage2D.apply(l, arguments)
                } catch (e) {
                    console.error("THREE.WebGLState:", e)
                }
            },
            texImage3D: function() {
                try {
                    l.texImage3D.apply(l, arguments)
                } catch (e) {
                    console.error("THREE.WebGLState:", e)
                }
            },
            scissor: function(e) {
                !1 === k.equals(e) && (l.scissor(e.x, e.y, e.z, e.w),
                k.copy(e))
            },
            viewport: function(e) {
                !1 === V.equals(e) && (l.viewport(e.x, e.y, e.z, e.w),
                V.copy(e))
            },
            reset: function() {
                for (var e = 0; e < v.length; e++)
                    1 === v[e] && (l.disableVertexAttribArray(e),
                    v[e] = 0);
                y = {},
                I = x = null,
                D = {},
                C = R = _ = b = null,
                h.reset(),
                d.reset(),
                f.reset()
            }
        }
    }
    function Tt(m, n, g, v, y, x, b) {
        function w(e, t, i, n) {
            var r = 1;
            if ((r = e.width > n || e.height > n ? n / Math.max(e.width, e.height) : r) < 1 || !0 === t) {
                if (e instanceof HTMLImageElement || e instanceof HTMLCanvasElement || e instanceof ImageBitmap)
                    return void 0 === o && (o = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas")),
                    i = i ? document.createElementNS("http://www.w3.org/1999/xhtml", "canvas") : o,
                    t = t ? Se.floorPowerOfTwo : Math.floor,
                    i.width = t(r * e.width),
                    i.height = t(r * e.height),
                    i.getContext("2d").drawImage(e, 0, 0, i.width, i.height),
                    console.warn("THREE.WebGLRenderer: Texture has been resized from (" + e.width + "x" + e.height + ") to (" + i.width + "x" + i.height + ")."),
                    i;
                "data"in e && console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + e.width + "x" + e.height + ").")
            }
            return e
        }
        function _(e) {
            return Se.isPowerOfTwo(e.width) && Se.isPowerOfTwo(e.height)
        }
        function M(e, t) {
            return e.generateMipmaps && t && 1003 !== e.minFilter && 1006 !== e.minFilter
        }
        function E(e, t, i, n) {
            m.generateMipmap(e),
            v.get(t).__maxMipLevel = Math.log(Math.max(i, n)) * Math.LOG2E
        }
        function S(e, t) {
            var i;
            return y.isWebGL2 ? (6403 === (i = e) && (5126 === t && (i = 33326),
            5131 === t && (i = 33325),
            5121 === t) && (i = 33321),
            6407 === e && (5126 === t && (i = 34837),
            5131 === t && (i = 34843),
            5121 === t) && (i = 32849),
            33325 === (i = 6408 === e && (5126 === t && (i = 34836),
            5131 === t && (i = 34842),
            5121 === t) ? 32856 : i) || 33326 === i || 34842 === i || 34836 === i ? n.get("EXT_color_buffer_float") : 34843 !== i && 34837 !== i || console.warn("THREE.WebGLRenderer: Floating point textures with RGB format not supported. Please use RGBA instead."),
            i) : e
        }
        function r(e) {
            return 1003 === e || 1004 === e || 1005 === e ? 9728 : 9729
        }
        function T(e) {
            (e = e.target).removeEventListener("dispose", T);
            e: {
                var t = v.get(e);
                if (e.image && t.__image__webglTextureCube)
                    m.deleteTexture(t.__image__webglTextureCube);
                else {
                    if (void 0 === t.__webglInit)
                        break e;
                    m.deleteTexture(t.__webglTexture)
                }
                v.remove(e)
            }
            e.isVideoTexture && delete p[e.id],
            b.memory.textures--
        }
        function s(e) {
            (e = e.target).removeEventListener("dispose", s);
            var t = v.get(e)
              , i = v.get(e.texture);
            if (e) {
                if (void 0 !== i.__webglTexture && m.deleteTexture(i.__webglTexture),
                e.depthTexture && e.depthTexture.dispose(),
                e.isWebGLRenderTargetCube)
                    for (i = 0; i < 6; i++)
                        m.deleteFramebuffer(t.__webglFramebuffer[i]),
                        t.__webglDepthbuffer && m.deleteRenderbuffer(t.__webglDepthbuffer[i]);
                else
                    m.deleteFramebuffer(t.__webglFramebuffer),
                    t.__webglDepthbuffer && m.deleteRenderbuffer(t.__webglDepthbuffer);
                v.remove(e.texture),
                v.remove(e)
            }
            b.memory.textures--
        }
        function c(e, t) {
            var i, n, r = v.get(e);
            if (e.isVideoTexture && (i = e.id,
            n = b.render.frame,
            p[i] !== n) && (p[i] = n,
            e.update()),
            0 < e.version && r.__version !== e.version)
                if (void 0 === (i = e.image))
                    console.warn("THREE.WebGLRenderer: Texture marked for update but image is undefined");
                else {
                    if (!1 !== i.complete)
                        return void a(r, e, t);
                    console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete")
                }
            g.activeTexture(33984 + t),
            g.bindTexture(3553, r.__webglTexture)
        }
        function A(e, t, i) {
            i ? (m.texParameteri(e, 10242, x.convert(t.wrapS)),
            m.texParameteri(e, 10243, x.convert(t.wrapT)),
            m.texParameteri(e, 10240, x.convert(t.magFilter)),
            m.texParameteri(e, 10241, x.convert(t.minFilter))) : (m.texParameteri(e, 10242, 33071),
            m.texParameteri(e, 10243, 33071),
            1001 === t.wrapS && 1001 === t.wrapT || console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."),
            m.texParameteri(e, 10240, r(t.magFilter)),
            m.texParameteri(e, 10241, r(t.minFilter)),
            1003 !== t.minFilter && 1006 !== t.minFilter && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.")),
            !(i = n.get("EXT_texture_filter_anisotropic")) || 1015 === t.type && null === n.get("OES_texture_float_linear") || 1016 === t.type && null === (y.isWebGL2 || n.get("OES_texture_half_float_linear")) || !(1 < t.anisotropy || v.get(t).__currentAnisotropy) || (m.texParameterf(e, i.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(t.anisotropy, y.getMaxAnisotropy())),
            v.get(t).__currentAnisotropy = t.anisotropy)
        }
        function a(e, t, i) {
            var n = t.isDataTexture3D ? 32879 : 3553
              , r = (void 0 === e.__webglInit && (e.__webglInit = !0,
            t.addEventListener("dispose", T),
            e.__webglTexture = m.createTexture(),
            b.memory.textures++),
            g.activeTexture(33984 + i),
            g.bindTexture(n, e.__webglTexture),
            m.pixelStorei(37440, t.flipY),
            m.pixelStorei(37441, t.premultiplyAlpha),
            m.pixelStorei(3317, t.unpackAlignment),
            i = (i = !y.isWebGL2 && (1001 !== t.wrapS || 1001 !== t.wrapT || 1003 !== t.minFilter && 1006 !== t.minFilter)) && !1 === _(t.image),
            _(i = w(t.image, i, !1, y.maxTextureSize)) || y.isWebGL2)
              , a = x.convert(t.format)
              , o = x.convert(t.type)
              , s = S(a, o)
              , c = (A(n, t, r),
            t.mipmaps);
            if (t.isDepthTexture) {
                if (s = 6402,
                1015 === t.type) {
                    if (!y.isWebGL2)
                        throw Error("Float Depth Texture only supported in WebGL2.0");
                    s = 36012
                } else
                    y.isWebGL2 && (s = 33189);
                1026 === t.format && 6402 === s && 1012 !== t.type && 1014 !== t.type && (console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."),
                t.type = 1012,
                o = x.convert(t.type)),
                1027 === t.format && (s = 34041,
                1020 !== t.type) && (console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."),
                t.type = 1020,
                o = x.convert(t.type)),
                g.texImage2D(3553, 0, s, i.width, i.height, 0, a, o, null)
            } else if (t.isDataTexture)
                if (0 < c.length && r) {
                    for (var h = 0, l = c.length; h < l; h++)
                        n = c[h],
                        g.texImage2D(3553, h, s, n.width, n.height, 0, a, o, n.data);
                    t.generateMipmaps = !1,
                    e.__maxMipLevel = c.length - 1
                } else
                    g.texImage2D(3553, 0, s, i.width, i.height, 0, a, o, i.data),
                    e.__maxMipLevel = 0;
            else if (t.isCompressedTexture) {
                for (h = 0,
                l = c.length; h < l; h++)
                    n = c[h],
                    1023 !== t.format && 1022 !== t.format ? -1 < g.getCompressedTextureFormats().indexOf(a) ? g.compressedTexImage2D(3553, h, s, n.width, n.height, 0, n.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : g.texImage2D(3553, h, s, n.width, n.height, 0, a, o, n.data);
                e.__maxMipLevel = c.length - 1
            } else if (t.isDataTexture3D)
                g.texImage3D(32879, 0, s, i.width, i.height, i.depth, 0, a, o, i.data),
                e.__maxMipLevel = 0;
            else if (0 < c.length && r) {
                for (h = 0,
                l = c.length; h < l; h++)
                    n = c[h],
                    g.texImage2D(3553, h, s, a, o, n);
                t.generateMipmaps = !1,
                e.__maxMipLevel = c.length - 1
            } else
                g.texImage2D(3553, 0, s, a, o, i),
                e.__maxMipLevel = 0;
            M(t, r) && E(3553, t, i.width, i.height),
            e.__version = t.version,
            t.onUpdate && t.onUpdate(t)
        }
        function h(e, t, i, n) {
            var r = x.convert(t.texture.format)
              , a = x.convert(t.texture.type)
              , o = S(r, a);
            g.texImage2D(n, 0, o, t.width, t.height, 0, r, a, null),
            m.bindFramebuffer(36160, e),
            m.framebufferTexture2D(36160, i, n, v.get(t.texture).__webglTexture, 0),
            m.bindFramebuffer(36160, null)
        }
        function l(e, t, i) {
            m.bindRenderbuffer(36161, e),
            t.depthBuffer && !t.stencilBuffer ? (i ? (i = u(t),
            m.renderbufferStorageMultisample(36161, i, 33189, t.width, t.height)) : m.renderbufferStorage(36161, 33189, t.width, t.height),
            m.framebufferRenderbuffer(36160, 36096, 36161, e)) : t.depthBuffer && t.stencilBuffer ? (i ? (i = u(t),
            m.renderbufferStorageMultisample(36161, i, 34041, t.width, t.height)) : m.renderbufferStorage(36161, 34041, t.width, t.height),
            m.framebufferRenderbuffer(36160, 33306, 36161, e)) : (e = S(e = x.convert(t.texture.format), x.convert(t.texture.type)),
            i ? (i = u(t),
            m.renderbufferStorageMultisample(36161, i, e, t.width, t.height)) : m.renderbufferStorage(36161, e, t.width, t.height)),
            m.bindRenderbuffer(36161, null)
        }
        function u(e) {
            return y.isWebGL2 && e.isWebGLMultisampleRenderTarget ? Math.min(y.maxSamples, e.samples) : 0
        }
        var o, p = {};
        this.setTexture2D = c,
        this.setTexture3D = function(e, t) {
            var i = v.get(e);
            0 < e.version && i.__version !== e.version ? a(i, e, t) : (g.activeTexture(33984 + t),
            g.bindTexture(32879, i.__webglTexture))
        }
        ,
        this.setTextureCube = function(e, t) {
            var i = v.get(e);
            if (6 === e.image.length)
                if (0 < e.version && i.__version !== e.version) {
                    i.__image__webglTextureCube || (e.addEventListener("dispose", T),
                    i.__image__webglTextureCube = m.createTexture(),
                    b.memory.textures++),
                    g.activeTexture(33984 + t),
                    g.bindTexture(34067, i.__image__webglTextureCube),
                    m.pixelStorei(37440, e.flipY),
                    t = e && e.isCompressedTexture;
                    for (var n = e.image[0] && e.image[0].isDataTexture, r = [], a = 0; a < 6; a++)
                        r[a] = t || n ? n ? e.image[a].image : e.image[a] : w(e.image[a], !1, !0, y.maxCubemapSize);
                    var o = r[0]
                      , s = _(o) || y.isWebGL2
                      , c = x.convert(e.format)
                      , h = x.convert(e.type)
                      , l = S(c, h);
                    for (A(34067, e, s),
                    a = 0; a < 6; a++)
                        if (t)
                            for (var u, p = r[a].mipmaps, d = 0, f = p.length; d < f; d++)
                                u = p[d],
                                1023 !== e.format && 1022 !== e.format ? -1 < g.getCompressedTextureFormats().indexOf(c) ? g.compressedTexImage2D(34069 + a, d, l, u.width, u.height, 0, u.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : g.texImage2D(34069 + a, d, l, u.width, u.height, 0, c, h, u.data);
                        else
                            n ? g.texImage2D(34069 + a, 0, l, r[a].width, r[a].height, 0, c, h, r[a].data) : g.texImage2D(34069 + a, 0, l, c, h, r[a]);
                    i.__maxMipLevel = t ? p.length - 1 : 0,
                    M(e, s) && E(34067, e, o.width, o.height),
                    i.__version = e.version,
                    e.onUpdate && e.onUpdate(e)
                } else
                    g.activeTexture(33984 + t),
                    g.bindTexture(34067, i.__image__webglTextureCube)
        }
        ,
        this.setTextureCubeDynamic = function(e, t) {
            g.activeTexture(33984 + t),
            g.bindTexture(34067, v.get(e).__webglTexture)
        }
        ,
        this.setupRenderTarget = function(e) {
            var t, i = v.get(e), n = v.get(e.texture), r = (e.addEventListener("dispose", s),
            n.__webglTexture = m.createTexture(),
            b.memory.textures++,
            !0 === e.isWebGLRenderTargetCube), a = !0 === e.isWebGLMultisampleRenderTarget, o = _(e) || y.isWebGL2;
            if (r)
                for (i.__webglFramebuffer = [],
                a = 0; a < 6; a++)
                    i.__webglFramebuffer[a] = m.createFramebuffer();
            else
                i.__webglFramebuffer = m.createFramebuffer(),
                a && (y.isWebGL2 ? (i.__webglMultisampledFramebuffer = m.createFramebuffer(),
                i.__webglColorRenderbuffer = m.createRenderbuffer(),
                m.bindRenderbuffer(36161, i.__webglColorRenderbuffer),
                a = S(a = x.convert(e.texture.format), x.convert(e.texture.type)),
                t = u(e),
                m.renderbufferStorageMultisample(36161, t, a, e.width, e.height),
                m.bindFramebuffer(36160, i.__webglMultisampledFramebuffer),
                m.framebufferRenderbuffer(36160, 36064, 36161, i.__webglColorRenderbuffer),
                m.bindRenderbuffer(36161, null),
                e.depthBuffer && (i.__webglDepthRenderbuffer = m.createRenderbuffer(),
                l(i.__webglDepthRenderbuffer, e, !0)),
                m.bindFramebuffer(36160, null)) : console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2."));
            if (r) {
                for (g.bindTexture(34067, n.__webglTexture),
                A(34067, e.texture, o),
                a = 0; a < 6; a++)
                    h(i.__webglFramebuffer[a], e, 36064, 34069 + a);
                M(e.texture, o) && E(34067, e.texture, e.width, e.height),
                g.bindTexture(34067, null)
            } else
                g.bindTexture(3553, n.__webglTexture),
                A(3553, e.texture, o),
                h(i.__webglFramebuffer, e, 36064, 3553),
                M(e.texture, o) && E(3553, e.texture, e.width, e.height),
                g.bindTexture(3553, null);
            if (e.depthBuffer) {
                if (i = v.get(e),
                n = !0 === e.isWebGLRenderTargetCube,
                e.depthTexture) {
                    if (n)
                        throw Error("target.depthTexture not supported in Cube render targets");
                    if (e && e.isWebGLRenderTargetCube)
                        throw Error("Depth Texture with cube render targets is not supported");
                    if (m.bindFramebuffer(36160, i.__webglFramebuffer),
                    !e.depthTexture || !e.depthTexture.isDepthTexture)
                        throw Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
                    if (v.get(e.depthTexture).__webglTexture && e.depthTexture.image.width === e.width && e.depthTexture.image.height === e.height || (e.depthTexture.image.width = e.width,
                    e.depthTexture.image.height = e.height,
                    e.depthTexture.needsUpdate = !0),
                    c(e.depthTexture, 0),
                    i = v.get(e.depthTexture).__webglTexture,
                    1026 === e.depthTexture.format)
                        m.framebufferTexture2D(36160, 36096, 3553, i, 0);
                    else {
                        if (1027 !== e.depthTexture.format)
                            throw Error("Unknown depthTexture format");
                        m.framebufferTexture2D(36160, 33306, 3553, i, 0)
                    }
                } else if (n)
                    for (i.__webglDepthbuffer = [],
                    n = 0; n < 6; n++)
                        m.bindFramebuffer(36160, i.__webglFramebuffer[n]),
                        i.__webglDepthbuffer[n] = m.createRenderbuffer(),
                        l(i.__webglDepthbuffer[n], e);
                else
                    m.bindFramebuffer(36160, i.__webglFramebuffer),
                    i.__webglDepthbuffer = m.createRenderbuffer(),
                    l(i.__webglDepthbuffer, e);
                m.bindFramebuffer(36160, null)
            }
        }
        ,
        this.updateRenderTargetMipmap = function(e) {
            var t, i = e.texture, n = _(e) || y.isWebGL2;
            M(i, n) && (n = e.isWebGLRenderTargetCube ? 34067 : 3553,
            t = v.get(i).__webglTexture,
            g.bindTexture(n, t),
            E(n, i, e.width, e.height),
            g.bindTexture(n, null))
        }
        ,
        this.updateMultisampleRenderTarget = function(e) {
            var t, i, n;
            e.isWebGLMultisampleRenderTarget && (y.isWebGL2 ? (t = v.get(e),
            m.bindFramebuffer(36008, t.__webglMultisampledFramebuffer),
            m.bindFramebuffer(36009, t.__webglFramebuffer),
            t = e.width,
            i = e.height,
            n = 16384,
            e.depthBuffer && (n |= 256),
            e.stencilBuffer && (n |= 1024),
            m.blitFramebuffer(0, 0, t, i, 0, 0, t, i, n, 9728)) : console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2."))
        }
    }
    function At(e, i, n) {
        return {
            convert: function(e) {
                if (1e3 === e)
                    return 10497;
                if (1001 === e)
                    return 33071;
                if (1002 === e)
                    return 33648;
                if (1003 === e)
                    return 9728;
                if (1004 === e)
                    return 9984;
                if (1005 === e)
                    return 9986;
                if (1006 === e)
                    return 9729;
                if (1007 === e)
                    return 9985;
                if (1008 === e)
                    return 9987;
                if (1009 === e)
                    return 5121;
                if (1017 === e)
                    return 32819;
                if (1018 === e)
                    return 32820;
                if (1019 === e)
                    return 33635;
                if (1010 === e)
                    return 5120;
                if (1011 === e)
                    return 5122;
                if (1012 === e)
                    return 5123;
                if (1013 === e)
                    return 5124;
                if (1014 === e)
                    return 5125;
                if (1015 === e)
                    return 5126;
                if (1016 === e) {
                    if (n.isWebGL2)
                        return 5131;
                    var t = i.get("OES_texture_half_float");
                    if (null !== t)
                        return t.HALF_FLOAT_OES
                }
                if (1021 === e)
                    return 6406;
                if (1022 === e)
                    return 6407;
                if (1023 === e)
                    return 6408;
                if (1024 === e)
                    return 6409;
                if (1025 === e)
                    return 6410;
                if (1026 === e)
                    return 6402;
                if (1027 === e)
                    return 34041;
                if (1028 === e)
                    return 6403;
                if (100 === e)
                    return 32774;
                if (101 === e)
                    return 32778;
                if (102 === e)
                    return 32779;
                if (200 !== e) {
                    if (201 === e)
                        return 1;
                    if (202 === e)
                        return 768;
                    if (203 === e)
                        return 769;
                    if (204 === e)
                        return 770;
                    if (205 === e)
                        return 771;
                    if (206 === e)
                        return 772;
                    if (207 === e)
                        return 773;
                    if (208 === e)
                        return 774;
                    if (209 === e)
                        return 775;
                    if (210 === e)
                        return 776;
                    if ((33776 === e || 33777 === e || 33778 === e || 33779 === e) && null !== (t = i.get("WEBGL_compressed_texture_s3tc"))) {
                        if (33776 === e)
                            return t.COMPRESSED_RGB_S3TC_DXT1_EXT;
                        if (33777 === e)
                            return t.COMPRESSED_RGBA_S3TC_DXT1_EXT;
                        if (33778 === e)
                            return t.COMPRESSED_RGBA_S3TC_DXT3_EXT;
                        if (33779 === e)
                            return t.COMPRESSED_RGBA_S3TC_DXT5_EXT
                    }
                    if ((35840 === e || 35841 === e || 35842 === e || 35843 === e) && null !== (t = i.get("WEBGL_compressed_texture_pvrtc"))) {
                        if (35840 === e)
                            return t.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
                        if (35841 === e)
                            return t.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
                        if (35842 === e)
                            return t.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
                        if (35843 === e)
                            return t.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG
                    }
                    if (36196 === e && null !== (t = i.get("WEBGL_compressed_texture_etc1")))
                        return t.COMPRESSED_RGB_ETC1_WEBGL;
                    if ((37808 === e || 37809 === e || 37810 === e || 37811 === e || 37812 === e || 37813 === e || 37814 === e || 37815 === e || 37816 === e || 37817 === e || 37818 === e || 37819 === e || 37820 === e || 37821 === e) && null !== (t = i.get("WEBGL_compressed_texture_astc")))
                        return e;
                    if (103 === e || 104 === e) {
                        if (n.isWebGL2) {
                            if (103 === e)
                                return 32775;
                            if (104 === e)
                                return 32776
                        }
                        if (null !== (t = i.get("EXT_blend_minmax"))) {
                            if (103 === e)
                                return t.MIN_EXT;
                            if (104 === e)
                                return t.MAX_EXT
                        }
                    }
                    if (1020 === e) {
                        if (n.isWebGL2)
                            return 34042;
                        if (null !== (t = i.get("WEBGL_depth_texture")))
                            return t.UNSIGNED_INT_24_8_WEBGL
                    }
                }
                return 0
            }
        }
    }
    function Lt() {
        u.call(this),
        this.type = "Group"
    }
    function Pt() {
        u.call(this),
        this.type = "Camera",
        this.matrixWorldInverse = new _e,
        this.projectionMatrix = new _e,
        this.projectionMatrixInverse = new _e
    }
    function E(e, t, i, n) {
        Pt.call(this),
        this.type = "PerspectiveCamera",
        this.fov = void 0 !== e ? e : 50,
        this.zoom = 1,
        this.near = void 0 !== i ? i : .1,
        this.far = void 0 !== n ? n : 2e3,
        this.focus = 10,
        this.aspect = void 0 !== t ? t : 1,
        this.view = null,
        this.filmGauge = 35,
        this.filmOffset = 0,
        this.updateProjectionMatrix()
    }
    function Rt(e) {
        E.call(this),
        this.cameras = e || []
    }
    function Ct(e, t, i) {
        Sc.setFromMatrixPosition(t.matrixWorld),
        Tc.setFromMatrixPosition(i.matrixWorld);
        var n = Sc.distanceTo(Tc)
          , r = t.projectionMatrix.elements
          , a = i.projectionMatrix.elements
          , o = r[14] / (r[10] - 1)
          , s = (i = r[14] / (r[10] + 1),
        (r[9] + 1) / r[5])
          , c = (r[9] - 1) / r[5]
          , h = (r[8] - 1) / r[0]
          , l = (a[8] + 1) / a[0]
          , r = o * h
          , a = o * l
          , h = (l = n / (l - h)) * -h;
        t.matrixWorld.decompose(e.position, e.quaternion, e.scale),
        e.translateX(h),
        e.translateZ(l),
        e.matrixWorld.compose(e.position, e.quaternion, e.scale),
        e.matrixWorldInverse.getInverse(e.matrixWorld),
        t = o + l,
        e.projectionMatrix.makePerspective(r - h, n - h + a, s * i / (o = i + l) * t, c * i / o * t, t, o)
    }
    function Ot(i) {
        function n() {
            return null !== c && !0 === c.isPresenting
        }
        function e() {
            var e, t;
            n() ? (e = (t = c.getEyeParameters("left")).renderWidth * a,
            t = t.renderHeight * a,
            s = i.getPixelRatio(),
            o = i.getSize(),
            i.setDrawingBufferSize(2 * e, t, 1),
            _.start()) : (r.enabled && i.setDrawingBufferSize(o.width, o.height, s),
            _.stop())
        }
        var r = this
          , c = null
          , h = null
          , l = null
          , u = []
          , p = new _e
          , d = new _e
          , a = 1
          , f = "stage"
          , m = ("undefined" != typeof window && "VRFrameData"in window && (h = new window.VRFrameData,
        window.addEventListener("vrdisplaypresentchange", e, !1)),
        new _e)
          , g = new M
          , v = new Me
          , y = new E
          , x = (y.bounds = new Ee(0,0,.5,1),
        y.layers.enable(1),
        new E)
          , b = (x.bounds = new Ee(.5,0,.5,1),
        x.layers.enable(2),
        new Rt([y, x]));
        b.layers.enable(1),
        b.layers.enable(2);
        var o, s, w = [], _ = (this.enabled = !1,
        this.getController = function(e) {
            var t = u[e];
            return void 0 === t && ((t = new Lt).matrixAutoUpdate = !1,
            t.visible = !1,
            u[e] = t),
            t
        }
        ,
        this.getDevice = function() {
            return c
        }
        ,
        this.setDevice = function(e) {
            void 0 !== e && (c = e),
            _.setContext(e)
        }
        ,
        this.setFramebufferScaleFactor = function(e) {
            a = e
        }
        ,
        this.setFrameOfReferenceType = function(e) {
            f = e
        }
        ,
        this.setPoseTarget = function(e) {
            void 0 !== e && (l = e)
        }
        ,
        this.getCamera = function(e) {
            var t = "stage" === f ? 1.6 : 0;
            if (null === c)
                return e.position.set(0, t, 0),
                e;
            if (c.depthNear = e.near,
            c.depthFar = e.far,
            c.getFrameData(h),
            "stage" === f && ((i = c.stageParameters) ? p.fromArray(i.sittingToStandingTransform) : p.makeTranslation(0, t, 0)),
            t = h.pose,
            (i = null !== l ? l : e).matrix.copy(p),
            i.matrix.decompose(i.position, i.quaternion, i.scale),
            null !== t.orientation && (g.fromArray(t.orientation),
            i.quaternion.multiply(g)),
            null !== t.position && (g.setFromRotationMatrix(p),
            v.fromArray(t.position),
            v.applyQuaternion(g),
            i.position.add(v)),
            i.updateMatrixWorld(),
            !1 === c.isPresenting)
                return e;
            for (y.near = e.near,
            x.near = e.near,
            y.far = e.far,
            x.far = e.far,
            y.matrixWorldInverse.fromArray(h.leftViewMatrix),
            x.matrixWorldInverse.fromArray(h.rightViewMatrix),
            d.getInverse(p),
            "stage" === f && (y.matrixWorldInverse.multiply(d),
            x.matrixWorldInverse.multiply(d)),
            null !== (e = i.parent) && (m.getInverse(e.matrixWorld),
            y.matrixWorldInverse.multiply(m),
            x.matrixWorldInverse.multiply(m)),
            y.matrixWorld.getInverse(y.matrixWorldInverse),
            x.matrixWorld.getInverse(x.matrixWorldInverse),
            y.projectionMatrix.fromArray(h.leftProjectionMatrix),
            x.projectionMatrix.fromArray(h.rightProjectionMatrix),
            Ct(b, y, x),
            (e = c.getLayers()).length && (null !== (e = e[0]).leftBounds && 4 === e.leftBounds.length && y.bounds.fromArray(e.leftBounds),
            null !== e.rightBounds) && 4 === e.rightBounds.length && x.bounds.fromArray(e.rightBounds),
            e = 0; e < u.length; e++) {
                t = u[e];
                e: {
                    for (var i = e, n = navigator.getGamepads && navigator.getGamepads(), r = 0, a = 0, o = n.length; r < o; r++) {
                        var s = n[r];
                        if (s && ("Daydream Controller" === s.id || "Gear VR Controller" === s.id || "Oculus Go Controller" === s.id || "OpenVR Gamepad" === s.id || s.id.startsWith("Oculus Touch") || s.id.startsWith("Spatial Controller"))) {
                            if (a === i) {
                                i = s;
                                break e
                            }
                            a++
                        }
                    }
                    i = void 0
                }
                if (void 0 !== i && void 0 !== i.pose) {
                    if (null === i.pose)
                        break;
                    !1 === (n = i.pose).hasPosition && t.position.set(.2, -.6, -.05),
                    null !== n.position && t.position.fromArray(n.position),
                    null !== n.orientation && t.quaternion.fromArray(n.orientation),
                    t.matrix.compose(t.position, t.quaternion, t.scale),
                    t.matrix.premultiply(p),
                    t.matrix.decompose(t.position, t.quaternion, t.scale),
                    t.matrixWorldNeedsUpdate = !0,
                    t.visible = !0,
                    n = "Daydream Controller" === i.id ? 0 : 1,
                    w[e] !== i.buttons[n].pressed && (w[e] = i.buttons[n].pressed,
                    !0 === w[e] ? t.dispatchEvent({
                        type: "selectstart"
                    }) : (t.dispatchEvent({
                        type: "selectend"
                    }),
                    t.dispatchEvent({
                        type: "select"
                    })))
                } else
                    t.visible = !1
            }
            return b
        }
        ,
        this.getStandingMatrix = function() {
            return p
        }
        ,
        this.isPresenting = n,
        new Re);
        this.setAnimationLoop = function(e) {
            _.setAnimationLoop(e)
        }
        ,
        this.submitFrame = function() {
            n() && c.submitFrame()
        }
        ,
        this.dispose = function() {
            "undefined" != typeof window && window.removeEventListener("vrdisplaypresentchange", e)
        }
    }
    function It(t) {
        function r() {
            return null !== h && null !== l
        }
        function i(e) {
            var t = d[f.indexOf(e.inputSource)];
            t && t.dispatchEvent({
                type: e.type
            })
        }
        function n() {
            t.setFramebuffer(null),
            x.stop()
        }
        function a(e, t) {
            null === t ? e.matrixWorld.copy(e.matrix) : e.matrixWorld.multiplyMatrices(t.matrixWorld, e.matrix),
            e.matrixWorldInverse.getInverse(e.matrixWorld)
        }
        var o = t.context
          , s = null
          , h = null
          , c = 1
          , l = null
          , u = "stage"
          , p = null
          , d = []
          , f = []
          , m = new E
          , g = (m.layers.enable(1),
        m.viewport = new Ee,
        new E)
          , v = (g.layers.enable(2),
        g.viewport = new Ee,
        new Rt([m, g]))
          , y = (v.layers.enable(1),
        v.layers.enable(2),
        this.enabled = !1,
        this.getController = function(e) {
            var t = d[e];
            return void 0 === t && ((t = new Lt).matrixAutoUpdate = !1,
            t.visible = !1,
            d[e] = t),
            t
        }
        ,
        this.getDevice = function() {
            return s
        }
        ,
        this.setDevice = function(e) {
            void 0 !== e && (s = e),
            e instanceof XRDevice && o.setCompatibleXRDevice(e)
        }
        ,
        this.setFramebufferScaleFactor = function(e) {
            c = e
        }
        ,
        this.setFrameOfReferenceType = function(e) {
            u = e
        }
        ,
        this.setSession = function(e) {
            null !== (h = e) && (h.addEventListener("select", i),
            h.addEventListener("selectstart", i),
            h.addEventListener("selectend", i),
            h.addEventListener("end", n),
            h.baseLayer = new XRWebGLLayer(h,o,{
                framebufferScaleFactor: c
            }),
            h.requestFrameOfReference(u).then(function(e) {
                l = e,
                t.setFramebuffer(h.baseLayer.framebuffer),
                x.setContext(h),
                x.start()
            }),
            f = h.getInputSources(),
            h.addEventListener("inputsourceschange", function() {
                f = h.getInputSources(),
                console.log(f);
                for (var e = 0; e < d.length; e++)
                    d[e].userData.inputSource = f[e]
            }))
        }
        ,
        this.getCamera = function(e) {
            if (r()) {
                var t = e.parent
                  , i = v.cameras;
                a(v, t);
                for (var n = 0; n < i.length; n++)
                    a(i[n], t);
                for (e.matrixWorld.copy(v.matrixWorld),
                n = 0,
                t = (e = e.children).length; n < t; n++)
                    e[n].updateMatrixWorld(!0);
                return Ct(v, m, g),
                v
            }
            return e
        }
        ,
        this.isPresenting = r,
        null)
          , x = new Re;
        x.setAnimationLoop(function(e, t) {
            if (null !== (p = t.getDevicePose(l)))
                for (var i = h.baseLayer, n = t.views, r = 0; r < n.length; r++) {
                    var a = n[r]
                      , o = i.getViewport(a)
                      , s = p.getViewMatrix(a)
                      , c = v.cameras[r];
                    c.matrix.fromArray(s).getInverse(c.matrix),
                    c.projectionMatrix.fromArray(a.projectionMatrix),
                    c.viewport.set(o.x, o.y, o.width, o.height),
                    0 === r && v.matrix.copy(c.matrix)
                }
            for (r = 0; r < d.length; r++)
                i = d[r],
                (n = f[r]) && null !== (n = t.getInputPose(n, l)) ? ("targetRay"in n ? i.matrix.elements = n.targetRay.transformMatrix : "pointerMatrix"in n && (i.matrix.elements = n.pointerMatrix),
                i.matrix.decompose(i.position, i.rotation, i.scale),
                i.visible = !0) : i.visible = !1;
            y && y(e)
        }),
        this.setAnimationLoop = function(e) {
            y = e
        }
        ,
        this.dispose = function() {}
        ,
        this.getStandingMatrix = function() {
            return console.warn("THREE.WebXRManager: getStandingMatrix() is no longer needed."),
            new THREE.Matrix4
        }
        ,
        this.submitFrame = function() {}
    }
    function Dt(e) {
        var _;
        function a() {
            M = new Ne(B),
            (E = new De(B,M,e)).isWebGL2 || (M.get("WEBGL_depth_texture"),
            M.get("OES_texture_float"),
            M.get("OES_texture_half_float"),
            M.get("OES_texture_half_float_linear"),
            M.get("OES_standard_derivatives"),
            M.get("OES_element_index_uint"),
            M.get("ANGLE_instanced_arrays")),
            M.get("OES_texture_float_linear"),
            m = new At(0,M,E),
            (S = new St(B,M,m,E)).scissor(r.copy(ue).multiplyScalar(C)),
            S.viewport(L.copy(le).multiplyScalar(C)),
            t = new Ge,
            f = new dt,
            s = new Tt(B,M,S,f,E,m,t),
            T = new Ce(B),
            q = new ze(0,T,t),
            p = new He(q,t),
            X = new Fe(B),
            l = new pt(y,M,E),
            c = new vt,
            h = new wt,
            u = new Oe(y,S,p,ee),
            Y = new Ie(B,M,t,E),
            J = new Ue(B,M,t,E),
            t.programs = l.programs,
            y.context = B,
            y.capabilities = E,
            y.extensions = M,
            y.properties = f,
            y.renderLists = c,
            y.state = S,
            y.info = t
        }
        function z(e) {
            e.preventDefault(),
            console.log("THREE.WebGLRenderer: Context Lost."),
            ne = !0
        }
        function U() {
            console.log("THREE.WebGLRenderer: Context Restored."),
            ne = !1,
            a()
        }
        function G(e) {
            (e = e.target).removeEventListener("dispose", G),
            F(e),
            f.remove(e)
        }
        function F(e) {
            var t = f.get(e).program;
            (e.program = void 0) !== t && l.releaseProgram(t)
        }
        function o(e, t, i, n) {
            for (var r = 0, a = e.length; r < a; r++) {
                var o = (h = e[r]).object
                  , s = h.geometry
                  , c = void 0 === n ? h.material : n
                  , h = h.group;
                if (i.isArrayCamera)
                    for (var l = (se = i).cameras, u = 0, p = l.length; u < p; u++) {
                        var d, f = l[u];
                        o.layers.test(f.layers) && ("viewport"in f ? S.viewport(L.copy(f.viewport)) : (d = f.bounds,
                        S.viewport(L.set(d.x * P, d.y * R, d.z * P, d.w * R).multiplyScalar(C))),
                        v.setupLights(f),
                        H(o, t, f, s, c, h))
                    }
                else
                    se = null,
                    H(o, t, i, s, c, h)
            }
        }
        function H(e, t, i, n, r, a) {
            var o, s;
            e.onBeforeRender(y, t, i, n, r, a),
            v = h.get(t, se || i),
            e.modelViewMatrix.multiplyMatrices(i.matrixWorldInverse, e.matrixWorld),
            e.normalMatrix.getNormalMatrix(e.modelViewMatrix),
            e.isImmediateRenderObject ? (S.setMaterial(r),
            o = V(i, t.fog, r, e),
            ae = _ = null,
            oe = !1,
            s = o,
            e.render(function(e) {
                y.renderBufferImmediate(e, s)
            })) : y.renderBufferDirect(i, t.fog, n, r, e, a),
            e.onAfterRender(y, t, i, n, r, a),
            v = h.get(t, se || i)
        }
        function k(e, t, i) {
            var n = f.get(e)
              , r = v.state.lights
              , a = n.lightsHash
              , o = r.state.hash
              , s = (i = l.getParameters(e, r.state, v.state.shadowsArray, t, O.numPlanes, O.numIntersection, i),
            l.getProgramCode(e, i))
              , c = n.program
              , h = !0;
            if (void 0 === c)
                e.addEventListener("dispose", G);
            else if (c.code !== s)
                F(e);
            else {
                if (a.stateID !== o.stateID || a.directionalLength !== o.directionalLength || a.pointLength !== o.pointLength || a.spotLength !== o.spotLength || a.rectAreaLength !== o.rectAreaLength || a.hemiLength !== o.hemiLength || a.shadowsLength !== o.shadowsLength)
                    a.stateID = o.stateID,
                    a.directionalLength = o.directionalLength,
                    a.pointLength = o.pointLength,
                    a.spotLength = o.spotLength,
                    a.rectAreaLength = o.rectAreaLength,
                    a.hemiLength = o.hemiLength,
                    a.shadowsLength = o.shadowsLength;
                else if (void 0 !== i.shaderID)
                    return;
                h = !1
            }
            if (h && (i.shaderID ? (s = Is[i.shaderID],
            n.shader = {
                name: e.type,
                uniforms: Pe(s.uniforms),
                vertexShader: s.vertexShader,
                fragmentShader: s.fragmentShader
            }) : n.shader = {
                name: e.type,
                uniforms: e.uniforms,
                vertexShader: e.vertexShader,
                fragmentShader: e.fragmentShader
            },
            e.onBeforeCompile(n.shader, y),
            s = l.getProgramCode(e, i),
            c = l.acquireProgram(e, n.shader, i, s),
            n.program = c,
            e.program = c),
            i = c.getAttributes(),
            e.morphTargets)
                for (s = e.numSupportedMorphTargets = 0; s < y.maxMorphTargets; s++)
                    0 <= i["morphTarget" + s] && e.numSupportedMorphTargets++;
            if (e.morphNormals)
                for (s = e.numSupportedMorphNormals = 0; s < y.maxMorphNormals; s++)
                    0 <= i["morphNormal" + s] && e.numSupportedMorphNormals++;
            i = n.shader.uniforms,
            (e.isShaderMaterial || e.isRawShaderMaterial) && !0 !== e.clipping || (n.numClippingPlanes = O.numPlanes,
            n.numIntersection = O.numIntersection,
            i.clippingPlanes = O.uniform),
            n.fog = t,
            void 0 === a && (n.lightsHash = a = {}),
            a.stateID = o.stateID,
            a.directionalLength = o.directionalLength,
            a.pointLength = o.pointLength,
            a.spotLength = o.spotLength,
            a.rectAreaLength = o.rectAreaLength,
            a.hemiLength = o.hemiLength,
            a.shadowsLength = o.shadowsLength,
            e.lights && (i.ambientLightColor.value = r.state.ambient,
            i.directionalLights.value = r.state.directional,
            i.spotLights.value = r.state.spot,
            i.rectAreaLights.value = r.state.rectArea,
            i.pointLights.value = r.state.point,
            i.hemisphereLights.value = r.state.hemi,
            i.directionalShadowMap.value = r.state.directionalShadowMap,
            i.directionalShadowMatrix.value = r.state.directionalShadowMatrix,
            i.spotShadowMap.value = r.state.spotShadowMap,
            i.spotShadowMatrix.value = r.state.spotShadowMatrix,
            i.pointShadowMap.value = r.state.pointShadowMap,
            i.pointShadowMatrix.value = r.state.pointShadowMatrix),
            e = n.program.getUniforms(),
            e = it.seqWithValue(e.seq, i),
            n.uniformsList = e
        }
        function V(e, t, i, n) {
            he = 0;
            var r, a, o = f.get(i), s = o.lightsHash, c = v.state.lights.state.hash, h = (fe && (me || e !== w) && O.setState(i.clippingPlanes, i.clipIntersection, i.clipShadows, e, o, e === w && i.id === b),
            !1 !== i.needsUpdate || (void 0 === o.program || i.fog && o.fog !== t || i.lights && (s.stateID !== c.stateID || s.directionalLength !== c.directionalLength || s.pointLength !== c.pointLength || s.spotLength !== c.spotLength || s.rectAreaLength !== c.rectAreaLength || s.hemiLength !== c.hemiLength || s.shadowsLength !== c.shadowsLength) || void 0 !== o.numClippingPlanes && (o.numClippingPlanes !== O.numPlanes || o.numIntersection !== O.numIntersection)) && (i.needsUpdate = !0),
            i.needsUpdate && (k(i, t, n),
            i.needsUpdate = !1),
            !1), l = !1, u = !1, c = (s = o.program).getUniforms(), p = o.shader.uniforms;
            return S.useProgram(s.program) && (u = l = h = !0),
            i.id !== b && (b = i.id,
            l = !0),
            (h || w !== e) && (c.setValue(B, "projectionMatrix", e.projectionMatrix),
            E.logarithmicDepthBuffer && c.setValue(B, "logDepthBufFC", 2 / (Math.log(e.far + 1) / Math.LN2)),
            w !== e && (w = e,
            u = l = !0),
            (i.isShaderMaterial || i.isMeshPhongMaterial || i.isMeshStandardMaterial || i.envMap) && void 0 !== (h = c.map.cameraPosition) && h.setValue(B, D.setFromMatrixPosition(e.matrixWorld)),
            i.isMeshPhongMaterial || i.isMeshLambertMaterial || i.isMeshBasicMaterial || i.isMeshStandardMaterial || i.isShaderMaterial || i.skinning) && c.setValue(B, "viewMatrix", e.matrixWorldInverse),
            i.skinning && (c.setOptional(B, n, "bindMatrix"),
            c.setOptional(B, n, "bindMatrixInverse"),
            e = n.skeleton) && (h = e.bones,
            E.floatVertexTextures ? (void 0 === e.boneTexture && (h = Math.sqrt(4 * h.length),
            h = Se.ceilPowerOfTwo(h),
            h = Math.max(h, 4),
            (r = new Float32Array(h * h * 4)).set(e.boneMatrices),
            (a = new Ae(r,h,h,1023,1015)).needsUpdate = !0,
            e.boneMatrices = r,
            e.boneTexture = a,
            e.boneTextureSize = h),
            c.setValue(B, "boneTexture", e.boneTexture),
            c.setValue(B, "boneTextureSize", e.boneTextureSize)) : c.setOptional(B, e, "boneMatrices")),
            l && (c.setValue(B, "toneMappingExposure", y.toneMappingExposure),
            c.setValue(B, "toneMappingWhitePoint", y.toneMappingWhitePoint),
            i.lights && (l = u,
            p.ambientLightColor.needsUpdate = l,
            p.directionalLights.needsUpdate = l,
            p.pointLights.needsUpdate = l,
            p.spotLights.needsUpdate = l,
            p.rectAreaLights.needsUpdate = l,
            p.hemisphereLights.needsUpdate = l),
            t && i.fog && (p.fogColor.value = t.color,
            t.isFog ? (p.fogNear.value = t.near,
            p.fogFar.value = t.far) : t.isFogExp2 && (p.fogDensity.value = t.density)),
            i.isMeshBasicMaterial ? d(p, i) : i.isMeshLambertMaterial ? (d(p, i),
            i.emissiveMap && (p.emissiveMap.value = i.emissiveMap)) : i.isMeshPhongMaterial ? (d(p, i),
            i.isMeshToonMaterial ? (j(p, i),
            i.gradientMap && (p.gradientMap.value = i.gradientMap)) : j(p, i)) : i.isMeshStandardMaterial ? (d(p, i),
            i.isMeshPhysicalMaterial ? (W(p, i),
            p.reflectivity.value = i.reflectivity,
            p.clearCoat.value = i.clearCoat,
            p.clearCoatRoughness.value = i.clearCoatRoughness) : W(p, i)) : i.isMeshMatcapMaterial ? (d(p, i),
            i.matcap && (p.matcap.value = i.matcap),
            i.bumpMap && (p.bumpMap.value = i.bumpMap,
            p.bumpScale.value = i.bumpScale,
            1 === i.side) && (p.bumpScale.value *= -1),
            i.normalMap && (p.normalMap.value = i.normalMap,
            p.normalScale.value.copy(i.normalScale),
            1 === i.side) && p.normalScale.value.negate(),
            i.displacementMap && (p.displacementMap.value = i.displacementMap,
            p.displacementScale.value = i.displacementScale,
            p.displacementBias.value = i.displacementBias)) : i.isMeshDepthMaterial ? (d(p, i),
            i.displacementMap && (p.displacementMap.value = i.displacementMap,
            p.displacementScale.value = i.displacementScale,
            p.displacementBias.value = i.displacementBias)) : i.isMeshDistanceMaterial ? (d(p, i),
            i.displacementMap && (p.displacementMap.value = i.displacementMap,
            p.displacementScale.value = i.displacementScale,
            p.displacementBias.value = i.displacementBias),
            p.referencePosition.value.copy(i.referencePosition),
            p.nearDistance.value = i.nearDistance,
            p.farDistance.value = i.farDistance) : i.isMeshNormalMaterial ? (d(p, i),
            i.bumpMap && (p.bumpMap.value = i.bumpMap,
            p.bumpScale.value = i.bumpScale,
            1 === i.side) && (p.bumpScale.value *= -1),
            i.normalMap && (p.normalMap.value = i.normalMap,
            p.normalScale.value.copy(i.normalScale),
            1 === i.side) && p.normalScale.value.negate(),
            i.displacementMap && (p.displacementMap.value = i.displacementMap,
            p.displacementScale.value = i.displacementScale,
            p.displacementBias.value = i.displacementBias)) : i.isLineBasicMaterial ? (p.diffuse.value = i.color,
            p.opacity.value = i.opacity,
            i.isLineDashedMaterial && (p.dashSize.value = i.dashSize,
            p.totalSize.value = i.dashSize + i.gapSize,
            p.scale.value = i.scale)) : i.isPointsMaterial ? (p.diffuse.value = i.color,
            p.opacity.value = i.opacity,
            p.size.value = i.size * C,
            p.scale.value = .5 * R,
            p.map.value = i.map,
            null !== i.map && (!0 === i.map.matrixAutoUpdate && i.map.updateMatrix(),
            p.uvTransform.value.copy(i.map.matrix))) : i.isSpriteMaterial ? (p.diffuse.value = i.color,
            p.opacity.value = i.opacity,
            p.rotation.value = i.rotation,
            p.map.value = i.map,
            null !== i.map && (!0 === i.map.matrixAutoUpdate && i.map.updateMatrix(),
            p.uvTransform.value.copy(i.map.matrix))) : i.isShadowMaterial && (p.color.value = i.color,
            p.opacity.value = i.opacity),
            void 0 !== p.ltc_1 && (p.ltc_1.value = Te.LTC_1),
            void 0 !== p.ltc_2 && (p.ltc_2.value = Te.LTC_2),
            it.upload(B, o.uniformsList, p, y)),
            i.isShaderMaterial && !0 === i.uniformsNeedUpdate && (it.upload(B, o.uniformsList, p, y),
            i.uniformsNeedUpdate = !1),
            i.isSpriteMaterial && c.setValue(B, "center", n.center),
            c.setValue(B, "modelViewMatrix", n.modelViewMatrix),
            c.setValue(B, "normalMatrix", n.normalMatrix),
            c.setValue(B, "modelMatrix", n.matrixWorld),
            s
        }
        function d(e, t) {
            var i;
            e.opacity.value = t.opacity,
            t.color && (e.diffuse.value = t.color),
            t.emissive && e.emissive.value.copy(t.emissive).multiplyScalar(t.emissiveIntensity),
            t.map && (e.map.value = t.map),
            t.alphaMap && (e.alphaMap.value = t.alphaMap),
            t.specularMap && (e.specularMap.value = t.specularMap),
            t.envMap && (e.envMap.value = t.envMap,
            e.flipEnvMap.value = t.envMap.isCubeTexture ? -1 : 1,
            e.reflectivity.value = t.reflectivity,
            e.refractionRatio.value = t.refractionRatio,
            e.maxMipLevel.value = f.get(t.envMap).__maxMipLevel),
            t.lightMap && (e.lightMap.value = t.lightMap,
            e.lightMapIntensity.value = t.lightMapIntensity),
            t.aoMap && (e.aoMap.value = t.aoMap,
            e.aoMapIntensity.value = t.aoMapIntensity),
            t.map ? i = t.map : t.specularMap ? i = t.specularMap : t.displacementMap ? i = t.displacementMap : t.normalMap ? i = t.normalMap : t.bumpMap ? i = t.bumpMap : t.roughnessMap ? i = t.roughnessMap : t.metalnessMap ? i = t.metalnessMap : t.alphaMap ? i = t.alphaMap : t.emissiveMap && (i = t.emissiveMap),
            void 0 !== i && (!0 === (i = i.isWebGLRenderTarget ? i.texture : i).matrixAutoUpdate && i.updateMatrix(),
            e.uvTransform.value.copy(i.matrix))
        }
        function j(e, t) {
            e.specular.value = t.specular,
            e.shininess.value = Math.max(t.shininess, 1e-4),
            t.emissiveMap && (e.emissiveMap.value = t.emissiveMap),
            t.bumpMap && (e.bumpMap.value = t.bumpMap,
            e.bumpScale.value = t.bumpScale,
            1 === t.side) && (e.bumpScale.value *= -1),
            t.normalMap && (e.normalMap.value = t.normalMap,
            e.normalScale.value.copy(t.normalScale),
            1 === t.side) && e.normalScale.value.negate(),
            t.displacementMap && (e.displacementMap.value = t.displacementMap,
            e.displacementScale.value = t.displacementScale,
            e.displacementBias.value = t.displacementBias)
        }
        function W(e, t) {
            e.roughness.value = t.roughness,
            e.metalness.value = t.metalness,
            t.roughnessMap && (e.roughnessMap.value = t.roughnessMap),
            t.metalnessMap && (e.metalnessMap.value = t.metalnessMap),
            t.emissiveMap && (e.emissiveMap.value = t.emissiveMap),
            t.bumpMap && (e.bumpMap.value = t.bumpMap,
            e.bumpScale.value = t.bumpScale,
            1 === t.side) && (e.bumpScale.value *= -1),
            t.normalMap && (e.normalMap.value = t.normalMap,
            e.normalScale.value.copy(t.normalScale),
            1 === t.side) && e.normalScale.value.negate(),
            t.displacementMap && (e.displacementMap.value = t.displacementMap,
            e.displacementScale.value = t.displacementScale,
            e.displacementBias.value = t.displacementBias),
            t.envMap && (e.envMapIntensity.value = t.envMapIntensity)
        }
        var M, E, S, t, f, s, T, q, p, l, c, h, u, X, Y, J, m, n = void 0 !== (e = e || {}).canvas ? e.canvas : document.createElementNS("http://www.w3.org/1999/xhtml", "canvas"), Z = void 0 !== e.context ? e.context : null, i = void 0 !== e.alpha && e.alpha, Q = void 0 === e.depth || e.depth, K = void 0 === e.stencil || e.stencil, $ = void 0 !== e.antialias && e.antialias, ee = void 0 === e.premultipliedAlpha || e.premultipliedAlpha, te = void 0 !== e.preserveDrawingBuffer && e.preserveDrawingBuffer, ie = void 0 !== e.powerPreference ? e.powerPreference : "default", g = null, v = null, y = (this.domElement = n,
        this.context = null,
        this.sortObjects = this.autoClearStencil = this.autoClearDepth = this.autoClearColor = this.autoClear = !0,
        this.clippingPlanes = [],
        this.localClippingEnabled = !1,
        this.gammaFactor = 2,
        this.physicallyCorrectLights = this.gammaOutput = this.gammaInput = !1,
        this.toneMappingWhitePoint = this.toneMappingExposure = this.toneMapping = 1,
        this.maxMorphTargets = 8,
        this.maxMorphNormals = 4,
        this), ne = !1, re = null, A = null, x = null, b = -1, ae = _ = null, oe = !1, w = null, se = null, L = new Ee, r = new Ee, ce = null, he = 0, P = n.width, R = n.height, C = 1, le = new Ee(0,0,P,R), ue = new Ee(0,0,P,R), pe = !1, de = new Le, O = new Be, fe = !1, me = !1, I = new _e, D = new Me;
        try {
            i = {
                alpha: i,
                depth: Q,
                stencil: K,
                antialias: $,
                premultipliedAlpha: ee,
                preserveDrawingBuffer: te,
                powerPreference: ie
            },
            n.addEventListener("webglcontextlost", z, !1),
            n.addEventListener("webglcontextrestored", U, !1);
            var B = Z || n.getContext("webgl", i) || n.getContext("experimental-webgl", i);
            if (null === B) {
                if (null !== n.getContext("webgl"))
                    throw Error("Error creating WebGL context with your selected attributes.");
                throw Error("Error creating WebGL context.")
            }
            void 0 === B.getShaderPrecisionFormat && (B.getShaderPrecisionFormat = function() {
                return {
                    rangeMin: 1,
                    rangeMax: 1,
                    precision: 1
                }
            }
            )
        } catch (e) {
            console.error("THREE.WebGLRenderer: " + e.message)
        }
        a();
        var ge, ve, ye, N = null, xe = ("undefined" != typeof navigator && (N = new ("xr"in navigator ? It : Ot)(y)),
        this.vr = N,
        new Et(y,p,E.maxTextureSize)), be = (this.shadowMap = xe,
        this.getContext = function() {
            return B
        }
        ,
        this.getContextAttributes = function() {
            return B.getContextAttributes()
        }
        ,
        this.forceContextLoss = function() {
            var e = M.get("WEBGL_lose_context");
            e && e.loseContext()
        }
        ,
        this.forceContextRestore = function() {
            var e = M.get("WEBGL_lose_context");
            e && e.restoreContext()
        }
        ,
        this.getPixelRatio = function() {
            return C
        }
        ,
        this.setPixelRatio = function(e) {
            void 0 !== e && (C = e,
            this.setSize(P, R, !1))
        }
        ,
        this.getSize = function() {
            return {
                width: P,
                height: R
            }
        }
        ,
        this.setSize = function(e, t, i) {
            N.isPresenting() ? console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.") : (P = e,
            R = t,
            n.width = e * C,
            n.height = t * C,
            !1 !== i && (n.style.width = e + "px",
            n.style.height = t + "px"),
            this.setViewport(0, 0, e, t))
        }
        ,
        this.getDrawingBufferSize = function() {
            return {
                width: P * C,
                height: R * C
            }
        }
        ,
        this.setDrawingBufferSize = function(e, t, i) {
            P = e,
            R = t,
            C = i,
            n.width = e * i,
            n.height = t * i,
            this.setViewport(0, 0, e, t)
        }
        ,
        this.getCurrentViewport = function() {
            return L
        }
        ,
        this.setViewport = function(e, t, i, n) {
            le.set(e, R - t - n, i, n),
            S.viewport(L.copy(le).multiplyScalar(C))
        }
        ,
        this.setScissor = function(e, t, i, n) {
            ue.set(e, R - t - n, i, n),
            S.scissor(r.copy(ue).multiplyScalar(C))
        }
        ,
        this.setScissorTest = function(e) {
            S.setScissorTest(pe = e)
        }
        ,
        this.getClearColor = function() {
            return u.getClearColor()
        }
        ,
        this.setClearColor = function() {
            u.setClearColor.apply(u, arguments)
        }
        ,
        this.getClearAlpha = function() {
            return u.getClearAlpha()
        }
        ,
        this.setClearAlpha = function() {
            u.setClearAlpha.apply(u, arguments)
        }
        ,
        this.clear = function(e, t, i) {
            var n = 0;
            void 0 !== e && !e || (n |= 16384),
            void 0 !== t && !t || (n |= 256),
            void 0 !== i && !i || (n |= 1024),
            B.clear(n)
        }
        ,
        this.clearColor = function() {
            this.clear(!0, !1, !1)
        }
        ,
        this.clearDepth = function() {
            this.clear(!1, !0, !1)
        }
        ,
        this.clearStencil = function() {
            this.clear(!1, !1, !0)
        }
        ,
        this.dispose = function() {
            n.removeEventListener("webglcontextlost", z, !1),
            n.removeEventListener("webglcontextrestored", U, !1),
            c.dispose(),
            h.dispose(),
            f.dispose(),
            p.dispose(),
            N.dispose(),
            we.stop()
        }
        ,
        this.renderBufferImmediate = function(e, t) {
            S.initAttributes();
            var i = f.get(e);
            e.hasPositions && !i.position && (i.position = B.createBuffer()),
            e.hasNormals && !i.normal && (i.normal = B.createBuffer()),
            e.hasUvs && !i.uv && (i.uv = B.createBuffer()),
            e.hasColors && !i.color && (i.color = B.createBuffer()),
            t = t.getAttributes(),
            e.hasPositions && (B.bindBuffer(34962, i.position),
            B.bufferData(34962, e.positionArray, 35048),
            S.enableAttribute(t.position),
            B.vertexAttribPointer(t.position, 3, 5126, !1, 0, 0)),
            e.hasNormals && (B.bindBuffer(34962, i.normal),
            B.bufferData(34962, e.normalArray, 35048),
            S.enableAttribute(t.normal),
            B.vertexAttribPointer(t.normal, 3, 5126, !1, 0, 0)),
            e.hasUvs && (B.bindBuffer(34962, i.uv),
            B.bufferData(34962, e.uvArray, 35048),
            S.enableAttribute(t.uv),
            B.vertexAttribPointer(t.uv, 2, 5126, !1, 0, 0)),
            e.hasColors && (B.bindBuffer(34962, i.color),
            B.bufferData(34962, e.colorArray, 35048),
            S.enableAttribute(t.color),
            B.vertexAttribPointer(t.color, 3, 5126, !1, 0, 0)),
            S.disableUnusedAttributes(),
            B.drawArrays(4, 0, e.count),
            e.count = 0
        }
        ,
        this.renderBufferDirect = function(e, t, i, n, r, a) {
            var o, s = r.isMesh && r.normalMatrix.determinant() < 0, c = (S.setMaterial(n, s),
            V(e, t, n, r)), h = !1, l = (_ === i.id && ae === c.id && oe === (!0 === n.wireframe) || (_ = i.id,
            ae = c.id,
            oe = !0 === n.wireframe,
            h = !0),
            r.morphTargetInfluences && (X.update(r, i, n, c),
            h = !0),
            s = i.index,
            i.attributes.position);
            if (t = 1,
            !0 === n.wireframe && (s = q.getWireframeAttribute(i),
            t = 2),
            e = Y,
            null !== s && (o = T.get(s),
            (e = J).setIndex(o)),
            h) {
                if (i && i.isInstancedBufferGeometry & !E.isWebGL2 && null === M.get("ANGLE_instanced_arrays"))
                    console.error("THREE.WebGLRenderer.setupVertexAttributes: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
                else {
                    S.initAttributes();
                    var h = i.attributes
                      , c = c.getAttributes()
                      , u = n.defaultAttributeValues;
                    for (w in c) {
                        var p = c[w];
                        if (0 <= p)
                            if (void 0 !== (v = h[w])) {
                                var d, f, m, g, v, y = v.normalized, x = v.itemSize, b = T.get(v);
                                void 0 !== b && (d = b.buffer,
                                f = b.type,
                                b = b.bytesPerElement,
                                v.isInterleavedBufferAttribute ? (g = (m = v.data).stride,
                                v = v.offset,
                                m && m.isInstancedInterleavedBuffer ? (S.enableAttributeAndDivisor(p, m.meshPerAttribute),
                                void 0 === i.maxInstancedCount && (i.maxInstancedCount = m.meshPerAttribute * m.count)) : S.enableAttribute(p),
                                B.bindBuffer(34962, d),
                                B.vertexAttribPointer(p, x, f, y, g * b, v * b)) : (v.isInstancedBufferAttribute ? (S.enableAttributeAndDivisor(p, v.meshPerAttribute),
                                void 0 === i.maxInstancedCount && (i.maxInstancedCount = v.meshPerAttribute * v.count)) : S.enableAttribute(p),
                                B.bindBuffer(34962, d),
                                B.vertexAttribPointer(p, x, f, y, 0, 0)))
                            } else if (void 0 !== u && void 0 !== (y = u[w]))
                                switch (y.length) {
                                case 2:
                                    B.vertexAttrib2fv(p, y);
                                    break;
                                case 3:
                                    B.vertexAttrib3fv(p, y);
                                    break;
                                case 4:
                                    B.vertexAttrib4fv(p, y);
                                    break;
                                default:
                                    B.vertexAttrib1fv(p, y)
                                }
                    }
                    S.disableUnusedAttributes()
                }
                null !== s && B.bindBuffer(34963, o.buffer)
            }
            o = 1 / 0,
            null !== s ? o = s.count : void 0 !== l && (o = l.count);
            var s = i.drawRange.start * t
              , l = null !== a ? a.start * t : 0
              , w = Math.max(s, l);
            if (0 !== (a = Math.max(0, Math.min(o, s + i.drawRange.count * t, l + (null !== a ? a.count * t : 1 / 0)) - 1 - w + 1))) {
                if (r.isMesh)
                    if (!0 === n.wireframe)
                        S.setLineWidth(n.wireframeLinewidth * (null === A ? C : 1)),
                        e.setMode(1);
                    else
                        switch (r.drawMode) {
                        case 0:
                            e.setMode(4);
                            break;
                        case 1:
                            e.setMode(5);
                            break;
                        case 2:
                            e.setMode(6)
                        }
                else
                    r.isLine ? (n = n.linewidth,
                    S.setLineWidth((n = void 0 === n ? 1 : n) * (null === A ? C : 1)),
                    r.isLineSegments ? e.setMode(1) : r.isLineLoop ? e.setMode(2) : e.setMode(3)) : r.isPoints ? e.setMode(0) : r.isSprite && e.setMode(4);
                i && i.isInstancedBufferGeometry ? 0 < i.maxInstancedCount && e.renderInstances(i, w, a) : e.render(w, a)
            }
        }
        ,
        this.compile = function(i, e) {
            (v = h.get(i, e)).init(),
            i.traverse(function(e) {
                e.isLight && (v.pushLight(e),
                e.castShadow) && v.pushShadow(e)
            }),
            v.setupLights(e),
            i.traverse(function(e) {
                if (e.material)
                    if (Array.isArray(e.material))
                        for (var t = 0; t < e.material.length; t++)
                            k(e.material[t], i.fog, e);
                    else
                        k(e.material, i.fog, e)
            })
        }
        ,
        null), we = new Re;
        we.setAnimationLoop(function(e) {
            N.isPresenting() || be && be(e)
        }),
        "undefined" != typeof window && we.setContext(window),
        this.setAnimationLoop = function(e) {
            be = e,
            N.setAnimationLoop(e),
            we.start()
        }
        ,
        this.render = function(e, t, i, n) {
            var r, a;
            t && t.isCamera ? ne || (ae = _ = null,
            oe = !1,
            b = -1,
            !(w = null) === e.autoUpdate && e.updateMatrixWorld(),
            null === t.parent && t.updateMatrixWorld(),
            N.enabled && (t = N.getCamera(t)),
            (v = h.get(e, t)).init(),
            e.onBeforeRender(y, e, t, i),
            I.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse),
            de.setFromMatrix(I),
            me = this.localClippingEnabled,
            fe = O.init(this.clippingPlanes, me, t),
            (g = c.get(e, t)).init(),
            function e(t, i, n, r) {
                if (!1 !== t.visible) {
                    if (t.layers.test(i.layers))
                        if (t.isGroup)
                            n = t.renderOrder;
                        else if (t.isLight)
                            v.pushLight(t),
                            t.castShadow && v.pushShadow(t);
                        else if (t.isSprite) {
                            var a, o;
                            t.frustumCulled && !de.intersectsSprite(t) || (r && D.setFromMatrixPosition(t.matrixWorld).applyMatrix4(I),
                            a = p.update(t),
                            o = t.material,
                            g.push(t, a, o, n, D.z, null))
                        } else if (t.isImmediateRenderObject)
                            r && D.setFromMatrixPosition(t.matrixWorld).applyMatrix4(I),
                            g.push(t, null, t.material, n, D.z, null);
                        else if ((t.isMesh || t.isLine || t.isPoints) && (t.isSkinnedMesh && t.skeleton.update(),
                        !t.frustumCulled || de.intersectsObject(t)))
                            if (r && D.setFromMatrixPosition(t.matrixWorld).applyMatrix4(I),
                            a = p.update(t),
                            o = t.material,
                            Array.isArray(o))
                                for (var s = a.groups, c = 0, h = s.length; c < h; c++) {
                                    var l = s[c]
                                      , u = o[l.materialIndex];
                                    u && u.visible && g.push(t, a, u, n, D.z, l)
                                }
                            else
                                o.visible && g.push(t, a, o, n, D.z, null);
                    for (c = 0,
                    h = (t = t.children).length; c < h; c++)
                        e(t[c], i, n, r)
                }
            }(e, t, 0, y.sortObjects),
            !0 === y.sortObjects && g.sort(),
            fe && O.beginShadows(),
            xe.render(v.state.shadowsArray, e, t),
            v.setupLights(t),
            fe && O.endShadows(),
            this.info.autoReset && this.info.reset(),
            this.setRenderTarget(i = void 0 === i ? null : i),
            u.render(g, e, t, n),
            n = g.opaque,
            r = g.transparent,
            e.overrideMaterial ? (a = e.overrideMaterial,
            n.length && o(n, e, t, a),
            r.length && o(r, e, t, a)) : (n.length && o(n, e, t),
            r.length && o(r, e, t)),
            i && (s.updateRenderTargetMipmap(i),
            s.updateMultisampleRenderTarget(i)),
            S.buffers.depth.setTest(!0),
            S.buffers.depth.setMask(!0),
            S.buffers.color.setMask(!0),
            S.setPolygonOffset(!1),
            e.onAfterRender(y, e, t),
            N.enabled && N.submitFrame(),
            v = g = null) : console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.")
        }
        ,
        this.allocTextureUnit = function() {
            var e = he;
            return e >= E.maxTextures && console.warn("THREE.WebGLRenderer: Trying to use " + e + " texture units while this GPU supports only " + E.maxTextures),
            he += 1,
            e
        }
        ,
        this.setTexture2D = (ge = !1,
        function(e, t) {
            e && e.isWebGLRenderTarget && (ge || (console.warn("THREE.WebGLRenderer.setTexture2D: don't use render targets as textures. Use their .texture property instead."),
            ge = !0),
            e = e.texture),
            s.setTexture2D(e, t)
        }
        ),
        this.setTexture3D = function(e, t) {
            s.setTexture3D(e, t)
        }
        ,
        this.setTexture = (ve = !1,
        function(e, t) {
            ve || (console.warn("THREE.WebGLRenderer: .setTexture is deprecated, use setTexture2D instead."),
            ve = !0),
            s.setTexture2D(e, t)
        }
        ),
        this.setTextureCube = (ye = !1,
        function(e, t) {
            e && e.isWebGLRenderTargetCube && (ye || (console.warn("THREE.WebGLRenderer.setTextureCube: don't use cube render targets as textures. Use their .texture property instead."),
            ye = !0),
            e = e.texture),
            e && e.isCubeTexture || Array.isArray(e.image) && 6 === e.image.length ? s.setTextureCube(e, t) : s.setTextureCubeDynamic(e, t)
        }
        ),
        this.setFramebuffer = function(e) {
            re = e
        }
        ,
        this.getRenderTarget = function() {
            return A
        }
        ,
        this.setRenderTarget = function(e) {
            (A = e) && void 0 === f.get(e).__webglFramebuffer && s.setupRenderTarget(e);
            var t = re
              , i = !1;
            ce = e ? (t = f.get(e).__webglFramebuffer,
            e.isWebGLRenderTargetCube ? (t = t[e.activeCubeFace],
            i = !0) : t = e.isWebGLMultisampleRenderTarget ? f.get(e).__webglMultisampledFramebuffer : t,
            L.copy(e.viewport),
            r.copy(e.scissor),
            e.scissorTest) : (L.copy(le).multiplyScalar(C),
            r.copy(ue).multiplyScalar(C),
            pe),
            x !== t && (B.bindFramebuffer(36160, t),
            x = t),
            S.viewport(L),
            S.scissor(r),
            S.setScissorTest(ce),
            i && (i = f.get(e.texture),
            B.framebufferTexture2D(36160, 36064, 34069 + e.activeCubeFace, i.__webglTexture, e.activeMipMapLevel))
        }
        ,
        this.readRenderTargetPixels = function(e, t, i, n, r, a) {
            if (e && e.isWebGLRenderTarget) {
                var o = f.get(e).__webglFramebuffer;
                if (o) {
                    var s = !1;
                    o !== x && (B.bindFramebuffer(36160, o),
                    s = !0);
                    try {
                        var c = e.texture
                          , h = c.format
                          , l = c.type;
                        1023 !== h && m.convert(h) !== B.getParameter(35739) ? console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.") : 1009 === l || m.convert(l) === B.getParameter(35738) || 1015 === l && (E.isWebGL2 || M.get("OES_texture_float") || M.get("WEBGL_color_buffer_float")) || 1016 === l && (E.isWebGL2 ? M.get("EXT_color_buffer_float") : M.get("EXT_color_buffer_half_float")) ? 36053 === B.checkFramebufferStatus(36160) ? 0 <= t && t <= e.width - n && 0 <= i && i <= e.height - r && B.readPixels(t, i, n, r, m.convert(h), m.convert(l), a) : console.error("THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.") : console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.")
                    } finally {
                        s && B.bindFramebuffer(36160, x)
                    }
                }
            } else
                console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.")
        }
        ,
        this.copyFramebufferToTexture = function(e, t, i) {
            var n = t.image.width
              , r = t.image.height
              , a = m.convert(t.format);
            this.setTexture2D(t, 0),
            B.copyTexImage2D(3553, i || 0, a, e.x, e.y, n, r, 0)
        }
        ,
        this.copyTextureToTexture = function(e, t, i, n) {
            var r = t.image.width
              , a = t.image.height
              , o = m.convert(i.format)
              , s = m.convert(i.type);
            this.setTexture2D(i, 0),
            t.isDataTexture ? B.texSubImage2D(3553, n || 0, e.x, e.y, r, a, o, s, t.image.data) : B.texSubImage2D(3553, n || 0, e.x, e.y, o, s, t.image)
        }
    }
    function Bt(e, t) {
        this.name = "",
        this.color = new d(e),
        this.density = void 0 !== t ? t : 25e-5
    }
    function Nt(e, t, i) {
        this.name = "",
        this.color = new d(e),
        this.near = void 0 !== t ? t : 1,
        this.far = void 0 !== i ? i : 1e3
    }
    function zt() {
        u.call(this),
        this.type = "Scene",
        this.overrideMaterial = this.fog = this.background = null,
        this.autoUpdate = !0
    }
    function Ut(e, t) {
        this.array = e,
        this.stride = t,
        this.count = void 0 !== e ? e.length / t : 0,
        this.dynamic = !1,
        this.updateRange = {
            offset: 0,
            count: -1
        },
        this.version = 0
    }
    function Gt(e, t, i, n) {
        this.data = e,
        this.itemSize = t,
        this.offset = i,
        this.normalized = !0 === n
    }
    function Ft(e) {
        a.call(this),
        this.type = "SpriteMaterial",
        this.color = new d(16777215),
        this.map = null,
        this.rotation = 0,
        this.sizeAttenuation = !0,
        this.lights = !1,
        this.transparent = !0,
        this.setValues(e)
    }
    function Ht(e) {
        var t;
        u.call(this),
        this.type = "Sprite",
        void 0 === Fs && (Fs = new U,
        t = new Ut(t = new Float32Array([-.5, -.5, 0, 0, 0, .5, -.5, 0, 1, 0, .5, .5, 0, 1, 1, -.5, .5, 0, 0, 1]),5),
        Fs.setIndex([0, 1, 2, 0, 2, 3]),
        Fs.addAttribute("position", new Gt(t,3,0,!1)),
        Fs.addAttribute("uv", new Gt(t,2,3,!1))),
        this.geometry = Fs,
        this.material = void 0 !== e ? e : new Ft,
        this.center = new Y(.5,.5)
    }
    function kt() {
        u.call(this),
        this.type = "LOD",
        Object.defineProperties(this, {
            levels: {
                enumerable: !0,
                value: []
            }
        })
    }
    function Vt(e, t) {
        e && e.isGeometry && console.error("THREE.SkinnedMesh no longer supports THREE.Geometry. Use THREE.BufferGeometry instead."),
        v.call(this, e, t),
        this.type = "SkinnedMesh",
        this.bindMode = "attached",
        this.bindMatrix = new _e,
        this.bindMatrixInverse = new _e
    }
    function jt(e, t) {
        if (this.bones = (e = e || []).slice(0),
        this.boneMatrices = new Float32Array(16 * this.bones.length),
        void 0 === t)
            this.calculateInverses();
        else if (this.bones.length === t.length)
            this.boneInverses = t.slice(0);
        else
            for (console.warn("THREE.Skeleton boneInverses is the wrong length."),
            this.boneInverses = [],
            e = 0,
            t = this.bones.length; e < t; e++)
                this.boneInverses.push(new _e)
    }
    function Wt() {
        u.call(this),
        this.type = "Bone"
    }
    function y(e) {
        a.call(this),
        this.type = "LineBasicMaterial",
        this.color = new d(16777215),
        this.linewidth = 1,
        this.linejoin = this.linecap = "round",
        this.lights = !1,
        this.setValues(e)
    }
    function h(e, t, i) {
        1 === i && console.error("THREE.Line: parameter THREE.LinePieces no longer supported. Use THREE.LineSegments instead."),
        u.call(this),
        this.type = "Line",
        this.geometry = void 0 !== e ? e : new U,
        this.material = void 0 !== t ? t : new y({
            color: 16777215 * Math.random()
        })
    }
    function x(e, t) {
        h.call(this, e, t),
        this.type = "LineSegments"
    }
    function qt(e, t) {
        h.call(this, e, t),
        this.type = "LineLoop"
    }
    function Xt(e) {
        a.call(this),
        this.type = "PointsMaterial",
        this.color = new d(16777215),
        this.map = null,
        this.size = 1,
        this.sizeAttenuation = !0,
        this.lights = this.morphTargets = !1,
        this.setValues(e)
    }
    function Yt(e, t) {
        u.call(this),
        this.type = "Points",
        this.geometry = void 0 !== e ? e : new U,
        this.material = void 0 !== t ? t : new Xt({
            color: 16777215 * Math.random()
        })
    }
    function Jt(e, t, i, n, r, a, o, s, c) {
        p.call(this, e, t, i, n, r, a, o, s, c),
        this.format = void 0 !== o ? o : 1022,
        this.minFilter = void 0 !== a ? a : 1006,
        this.magFilter = void 0 !== r ? r : 1006,
        this.generateMipmaps = !1
    }
    function Zt(e, t, i, n, r, a, o, s, c, h, l, u) {
        p.call(this, null, a, o, s, c, h, n, r, l, u),
        this.image = {
            width: t,
            height: i
        },
        this.mipmaps = e,
        this.generateMipmaps = this.flipY = !1
    }
    function Qt(e, t, i, n, r, a, o, s, c) {
        p.call(this, e, t, i, n, r, a, o, s, c),
        this.needsUpdate = !0
    }
    function Kt(e, t, i, n, r, a, o, s, c, h) {
        if (1026 !== (h = void 0 !== h ? h : 1026) && 1027 !== h)
            throw Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
        p.call(this, null, n, r, a, o, s, h, i = void 0 === (i = void 0 === i && 1026 === h ? 1012 : i) && 1027 === h ? 1020 : i, c),
        this.image = {
            width: e,
            height: t
        },
        this.magFilter = void 0 !== o ? o : 1003,
        this.minFilter = void 0 !== s ? s : 1003,
        this.generateMipmaps = this.flipY = !1
    }
    function $t(e) {
        U.call(this),
        this.type = "WireframeGeometry";
        var t = []
          , i = [0, 0]
          , n = {}
          , r = ["a", "b", "c"];
        if (e && e.isGeometry) {
            for (var a = e.faces, o = 0, s = a.length; o < s; o++)
                for (var c = a[o], h = 0; h < 3; h++) {
                    var l = c[r[h]]
                      , u = c[r[(h + 1) % 3]];
                    i[0] = Math.min(l, u),
                    i[1] = Math.max(l, u),
                    void 0 === n[l = i[0] + "," + i[1]] && (n[l] = {
                        index1: i[0],
                        index2: i[1]
                    })
                }
            for (l in n)
                o = n[l],
                r = e.vertices[o.index1],
                t.push(r.x, r.y, r.z),
                r = e.vertices[o.index2],
                t.push(r.x, r.y, r.z)
        } else if (e && e.isBufferGeometry)
            if (r = new Me,
            null !== e.index) {
                for (var a = e.attributes.position, c = e.index, p = e.groups, d = (p = (e = 0) === p.length ? [{
                    start: 0,
                    count: c.count,
                    materialIndex: 0
                }] : p).length; e < d; ++e)
                    for (h = (o = p[e]).start,
                    s = o.count,
                    s = (o = h) + s; o < s; o += 3)
                        for (h = 0; h < 3; h++)
                            l = c.getX(o + h),
                            u = c.getX(o + (h + 1) % 3),
                            i[0] = Math.min(l, u),
                            i[1] = Math.max(l, u),
                            void 0 === n[l = i[0] + "," + i[1]] && (n[l] = {
                                index1: i[0],
                                index2: i[1]
                            });
                for (l in n)
                    o = n[l],
                    r.fromBufferAttribute(a, o.index1),
                    t.push(r.x, r.y, r.z),
                    r.fromBufferAttribute(a, o.index2),
                    t.push(r.x, r.y, r.z)
            } else
                for (o = 0,
                s = (a = e.attributes.position).count / 3; o < s; o++)
                    for (h = 0; h < 3; h++)
                        r.fromBufferAttribute(a, n = 3 * o + h),
                        t.push(r.x, r.y, r.z),
                        r.fromBufferAttribute(a, n = 3 * o + (h + 1) % 3),
                        t.push(r.x, r.y, r.z);
        this.addAttribute("position", new z(t,3))
    }
    function ei(e, t, i) {
        f.call(this),
        this.type = "ParametricGeometry",
        this.parameters = {
            func: e,
            slices: t,
            stacks: i
        },
        this.fromBufferGeometry(new ti(e,t,i)),
        this.mergeVertices()
    }
    function ti(e, t, i) {
        U.call(this),
        this.type = "ParametricBufferGeometry",
        this.parameters = {
            func: e,
            slices: t,
            stacks: i
        };
        for (var n = [], r = [], a = [], o = [], s = new Me, c = new Me, h = new Me, l = new Me, u = new Me, p = (e.length < 3 && console.error("THREE.ParametricGeometry: Function must now modify a Vector3 as third parameter."),
        t + 1), d = 0; d <= i; d++)
            for (var f = d / i, m = 0; m <= t; m++) {
                var g = m / t;
                e(g, f, c),
                r.push(c.x, c.y, c.z),
                0 <= g - 1e-5 ? (e(g - 1e-5, f, h),
                l.subVectors(c, h)) : (e(1e-5 + g, f, h),
                l.subVectors(h, c)),
                0 <= f - 1e-5 ? (e(g, f - 1e-5, h),
                u.subVectors(c, h)) : (e(g, 1e-5 + f, h),
                u.subVectors(h, c)),
                s.crossVectors(l, u).normalize(),
                a.push(s.x, s.y, s.z),
                o.push(g, f)
            }
        for (d = 0; d < i; d++)
            for (m = 0; m < t; m++)
                s = (d + 1) * p + m + 1,
                n.push(d * p + m, e = d * p + m + 1, c = (d + 1) * p + m),
                n.push(e, s, c);
        this.setIndex(n),
        this.addAttribute("position", new z(r,3)),
        this.addAttribute("normal", new z(a,3)),
        this.addAttribute("uv", new z(o,2))
    }
    function ii(e, t, i, n) {
        f.call(this),
        this.type = "PolyhedronGeometry",
        this.parameters = {
            vertices: e,
            indices: t,
            radius: i,
            detail: n
        },
        this.fromBufferGeometry(new ni(e,t,i,n)),
        this.mergeVertices()
    }
    function ni(i, e, t, n) {
        function r(e) {
            s.push(e.x, e.y, e.z)
        }
        function a(e, t) {
            t.x = i[(e *= 3) + 0],
            t.y = i[e + 1],
            t.z = i[e + 2]
        }
        function o(e, t, i, n) {
            n < 0 && 1 === e.x && (c[t] = e.x - 1),
            0 === i.x && 0 === i.z && (c[t] = n / 2 / Math.PI + .5)
        }
        U.call(this),
        this.type = "PolyhedronBufferGeometry",
        this.parameters = {
            vertices: i,
            indices: e,
            radius: t,
            detail: n
        },
        t = t || 1;
        for (var s = [], c = [], h = n = n || 0, l = new Me, u = new Me, p = new Me, d = 0; d < e.length; d += 3) {
            a(e[d + 0], l),
            a(e[d + 1], u),
            a(e[d + 2], p);
            for (var f = l, m = u, g = p, v = Math.pow(2, h), y = [], x = 0; x <= v; x++) {
                y[x] = [];
                for (var b = f.clone().lerp(g, x / v), w = m.clone().lerp(g, x / v), _ = v - x, M = 0; M <= _; M++)
                    y[x][M] = 0 === M && x === v ? b : b.clone().lerp(w, M / _)
            }
            for (x = 0; x < v; x++)
                for (M = 0; M < 2 * (v - x) - 1; M++)
                    f = Math.floor(M / 2),
                    0 == M % 2 ? (r(y[x][f + 1]),
                    r(y[x + 1][f]),
                    r(y[x][f])) : (r(y[x][f + 1]),
                    r(y[x + 1][f + 1]),
                    r(y[x + 1][f]))
        }
        for (var N = t, E = new Me, S = 0; S < s.length; S += 3)
            E.x = s[S + 0],
            E.y = s[S + 1],
            E.z = s[S + 2],
            E.normalize().multiplyScalar(N),
            s[S + 0] = E.x,
            s[S + 1] = E.y,
            s[S + 2] = E.z;
        for (var T = new Me, A = 0; A < s.length; A += 3)
            T.x = s[A + 0],
            T.y = s[A + 1],
            T.z = s[A + 2],
            c.push(Math.atan2(T.z, -T.x) / 2 / Math.PI + .5, 1 - (Math.atan2(-T.y, Math.sqrt(T.x * T.x + T.z * T.z)) / Math.PI + .5));
        for (var T = new Me, A = new Me, L = new Me, P = new Me, R = new Y, C = new Y, O = new Y, I = 0, D = 0; I < s.length; I += 9,
        D += 6) {
            T.set(s[I + 0], s[I + 1], s[I + 2]),
            A.set(s[I + 3], s[I + 4], s[I + 5]),
            L.set(s[I + 6], s[I + 7], s[I + 8]),
            R.set(c[D + 0], c[D + 1]),
            C.set(c[D + 2], c[D + 3]),
            O.set(c[D + 4], c[D + 5]),
            P.copy(T).add(A).add(L).divideScalar(3);
            var B = Math.atan2(P.z, -P.x);
            o(R, D + 0, T, B),
            o(C, D + 2, A, B),
            o(O, D + 4, L, B)
        }
        for (T = 0; T < c.length; T += 6)
            A = c[T + 0],
            L = c[T + 2],
            P = c[T + 4],
            R = Math.min(A, L, P),
            .9 < Math.max(A, L, P) && R < .1 && (A < .2 && (c[T + 0] += 1),
            L < .2 && (c[T + 2] += 1),
            P < .2) && (c[T + 4] += 1);
        this.addAttribute("position", new z(s,3)),
        this.addAttribute("normal", new z(s.slice(),3)),
        this.addAttribute("uv", new z(c,2)),
        0 === n ? this.computeVertexNormals() : this.normalizeNormals()
    }
    function ri(e, t) {
        f.call(this),
        this.type = "TetrahedronGeometry",
        this.parameters = {
            radius: e,
            detail: t
        },
        this.fromBufferGeometry(new ai(e,t)),
        this.mergeVertices()
    }
    function ai(e, t) {
        ni.call(this, [1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1], [2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1], e, t),
        this.type = "TetrahedronBufferGeometry",
        this.parameters = {
            radius: e,
            detail: t
        }
    }
    function oi(e, t) {
        f.call(this),
        this.type = "OctahedronGeometry",
        this.parameters = {
            radius: e,
            detail: t
        },
        this.fromBufferGeometry(new si(e,t)),
        this.mergeVertices()
    }
    function si(e, t) {
        ni.call(this, [1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1], [0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4, 2], e, t),
        this.type = "OctahedronBufferGeometry",
        this.parameters = {
            radius: e,
            detail: t
        }
    }
    function ci(e, t) {
        f.call(this),
        this.type = "IcosahedronGeometry",
        this.parameters = {
            radius: e,
            detail: t
        },
        this.fromBufferGeometry(new hi(e,t)),
        this.mergeVertices()
    }
    function hi(e, t) {
        var i = (1 + Math.sqrt(5)) / 2;
        ni.call(this, [-1, i, 0, 1, i, 0, -1, -i, 0, 1, -i, 0, 0, -1, i, 0, 1, i, 0, -1, -i, 0, 1, -i, i, 0, -1, i, 0, 1, -i, 0, -1, -i, 0, 1], [0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4, 11, 10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9, 4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1], e, t),
        this.type = "IcosahedronBufferGeometry",
        this.parameters = {
            radius: e,
            detail: t
        }
    }
    function li(e, t) {
        f.call(this),
        this.type = "DodecahedronGeometry",
        this.parameters = {
            radius: e,
            detail: t
        },
        this.fromBufferGeometry(new ui(e,t)),
        this.mergeVertices()
    }
    function ui(e, t) {
        var i = (1 + Math.sqrt(5)) / 2
          , n = 1 / i;
        ni.call(this, [-1, -1, -1, -1, -1, 1, -1, 1, -1, -1, 1, 1, 1, -1, -1, 1, -1, 1, 1, 1, -1, 1, 1, 1, 0, -n, -i, 0, -n, i, 0, n, -i, 0, n, i, -n, -i, 0, -n, i, 0, n, -i, 0, n, i, 0, -i, 0, -n, i, 0, -n, -i, 0, n, i, 0, n], [3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15, 17, 4, 8, 17, 8, 10, 17, 10, 6, 8, 0, 16, 8, 16, 2, 8, 2, 10, 0, 12, 1, 0, 1, 18, 0, 18, 16, 6, 10, 2, 6, 2, 13, 6, 13, 15, 2, 16, 18, 2, 18, 3, 2, 3, 13, 18, 1, 9, 18, 9, 11, 18, 11, 3, 4, 14, 12, 4, 12, 0, 4, 0, 8, 11, 9, 5, 11, 5, 19, 11, 19, 7, 19, 5, 14, 19, 14, 4, 19, 4, 17, 1, 12, 14, 1, 14, 5, 1, 5, 9], e, t),
        this.type = "DodecahedronBufferGeometry",
        this.parameters = {
            radius: e,
            detail: t
        }
    }
    function pi(e, t, i, n, r, a) {
        f.call(this),
        this.type = "TubeGeometry",
        this.parameters = {
            path: e,
            tubularSegments: t,
            radius: i,
            radialSegments: n,
            closed: r
        },
        void 0 !== a && console.warn("THREE.TubeGeometry: taper has been removed."),
        e = new di(e,t,i,n,r),
        this.tangents = e.tangents,
        this.normals = e.normals,
        this.binormals = e.binormals,
        this.fromBufferGeometry(e),
        this.mergeVertices()
    }
    function di(r, a, o, s, e) {
        function t(e) {
            p = r.getPointAt(e / a, p);
            var t = h.normals[e];
            for (e = h.binormals[e],
            c = 0; c <= s; c++) {
                var i = c / s * Math.PI * 2
                  , n = Math.sin(i)
                  , i = -Math.cos(i);
                u.x = i * t.x + n * e.x,
                u.y = i * t.y + n * e.y,
                u.z = i * t.z + n * e.z,
                u.normalize(),
                f.push(u.x, u.y, u.z),
                l.x = p.x + o * u.x,
                l.y = p.y + o * u.y,
                l.z = p.z + o * u.z,
                d.push(l.x, l.y, l.z)
            }
        }
        U.call(this),
        this.type = "TubeBufferGeometry",
        this.parameters = {
            path: r,
            tubularSegments: a,
            radius: o,
            radialSegments: s,
            closed: e
        },
        a = a || 64,
        o = o || 1,
        s = s || 8;
        for (var c, h = r.computeFrenetFrames(a, e = e || !1), l = (this.tangents = h.tangents,
        this.normals = h.normals,
        this.binormals = h.binormals,
        new Me), u = new Me, i = new Y, p = new Me, d = [], f = [], n = [], m = [], g = 0; g < a; g++)
            t(g);
        for (t(!1 === e ? a : 0),
        g = 0; g <= a; g++)
            for (c = 0; c <= s; c++)
                i.x = g / a,
                i.y = c / s,
                n.push(i.x, i.y);
        for (c = 1; c <= a; c++)
            for (g = 1; g <= s; g++) {
                var v = (s + 1) * c + (g - 1)
                  , y = (s + 1) * c + g
                  , x = (s + 1) * (c - 1) + g;
                m.push((s + 1) * (c - 1) + (g - 1), v, x),
                m.push(v, y, x)
            }
        this.setIndex(m),
        this.addAttribute("position", new z(d,3)),
        this.addAttribute("normal", new z(f,3)),
        this.addAttribute("uv", new z(n,2))
    }
    function fi(e, t, i, n, r, a, o) {
        f.call(this),
        this.type = "TorusKnotGeometry",
        this.parameters = {
            radius: e,
            tube: t,
            tubularSegments: i,
            radialSegments: n,
            p: r,
            q: a
        },
        void 0 !== o && console.warn("THREE.TorusKnotGeometry: heightScale has been deprecated. Use .scale( x, y, z ) instead."),
        this.fromBufferGeometry(new mi(e,t,i,n,r,a)),
        this.mergeVertices()
    }
    function mi(e, t, i, n, r, a) {
        function o(e, t, i, n, r) {
            var a = Math.sin(e);
            t = i / t * e,
            i = Math.cos(t),
            r.x = n * (2 + i) * .5 * Math.cos(e),
            r.y = n * (2 + i) * a * .5,
            r.z = n * Math.sin(t) * .5
        }
        U.call(this),
        this.type = "TorusKnotBufferGeometry",
        this.parameters = {
            radius: e,
            tube: t,
            tubularSegments: i,
            radialSegments: n,
            p: r,
            q: a
        },
        e = e || 1,
        t = t || .4,
        i = Math.floor(i) || 64,
        n = Math.floor(n) || 8,
        r = r || 2,
        a = a || 3;
        for (var s = [], c = [], h = [], l = [], u = new Me, p = new Me, d = new Me, f = new Me, m = new Me, g = new Me, v = new Me, y = 0; y <= i; ++y) {
            var x = y / i * r * Math.PI * 2;
            for (o(x, r, a, e, d),
            o(x + .01, r, a, e, f),
            g.subVectors(f, d),
            v.addVectors(f, d),
            m.crossVectors(g, v),
            v.crossVectors(m, g),
            m.normalize(),
            v.normalize(),
            x = 0; x <= n; ++x) {
                var b = x / n * Math.PI * 2
                  , w = -t * Math.cos(b)
                  , b = t * Math.sin(b);
                u.x = d.x + (w * v.x + b * m.x),
                u.y = d.y + (w * v.y + b * m.y),
                u.z = d.z + (w * v.z + b * m.z),
                c.push(u.x, u.y, u.z),
                p.subVectors(u, d).normalize(),
                h.push(p.x, p.y, p.z),
                l.push(y / i),
                l.push(x / n)
            }
        }
        for (x = 1; x <= i; x++)
            for (y = 1; y <= n; y++)
                t = (n + 1) * x + y,
                s.push((n + 1) * (x - 1) + (y - 1), e = (n + 1) * x + (y - 1), r = (n + 1) * (x - 1) + y),
                s.push(e, t, r);
        this.setIndex(s),
        this.addAttribute("position", new z(c,3)),
        this.addAttribute("normal", new z(h,3)),
        this.addAttribute("uv", new z(l,2))
    }
    function gi(e, t, i, n, r) {
        f.call(this),
        this.type = "TorusGeometry",
        this.parameters = {
            radius: e,
            tube: t,
            radialSegments: i,
            tubularSegments: n,
            arc: r
        },
        this.fromBufferGeometry(new vi(e,t,i,n,r)),
        this.mergeVertices()
    }
    function vi(e, t, i, n, r) {
        U.call(this),
        this.type = "TorusBufferGeometry",
        this.parameters = {
            radius: e,
            tube: t,
            radialSegments: i,
            tubularSegments: n,
            arc: r
        },
        e = e || 1,
        t = t || .4,
        i = Math.floor(i) || 8,
        n = Math.floor(n) || 6,
        r = r || 2 * Math.PI;
        for (var a, o = [], s = [], c = [], h = [], l = new Me, u = new Me, p = new Me, d = 0; d <= i; d++)
            for (a = 0; a <= n; a++) {
                var f = a / n * r
                  , m = d / i * Math.PI * 2;
                u.x = (e + t * Math.cos(m)) * Math.cos(f),
                u.y = (e + t * Math.cos(m)) * Math.sin(f),
                u.z = t * Math.sin(m),
                s.push(u.x, u.y, u.z),
                l.x = e * Math.cos(f),
                l.y = e * Math.sin(f),
                p.subVectors(u, l).normalize(),
                c.push(p.x, p.y, p.z),
                h.push(a / n),
                h.push(d / i)
            }
        for (d = 1; d <= i; d++)
            for (a = 1; a <= n; a++)
                o.push((r = (n + 1) * d + a) - 1, e = (t = (n + 1) * (d - 1) + a) - 1, r),
                o.push(e, t, r);
        this.setIndex(o),
        this.addAttribute("position", new z(s,3)),
        this.addAttribute("normal", new z(c,3)),
        this.addAttribute("uv", new z(h,2))
    }
    function yi(e, t, i, n, r) {
        for (var a, o = 0, s = t, c = i - n; s < i; s += n)
            o += (e[c] - e[s]) * (e[s + 1] + e[c + 1]),
            c = s;
        if (r === 0 < o)
            for (r = t; r < i; r += n)
                a = Ai(r, e[r], e[r + 1], a);
        else
            for (r = i - n; t <= r; r -= n)
                a = Ai(r, e[r], e[r + 1], a);
        return a && Mi(a, a.next) && (Li(a),
        a = a.next),
        a
    }
    function xi(e, t) {
        if (!e)
            return e;
        t = t || e;
        do {
            var i = !1;
            if (e.steiner || !Mi(e, e.next) && 0 !== b(e.prev, e, e.next))
                e = e.next;
            else {
                if (Li(e),
                (e = t = e.prev) === e.next)
                    break;
                i = !0
            }
        } while (i || e !== t);
        return t
    }
    function bi(e, t) {
        return e.x - t.x
    }
    function wi(e, t, i, n, r) {
        return 1431655765 & ((e = 858993459 & ((e = 252645135 & ((e = 16711935 & ((e = 32767 * (e - i) * r) | e << 8)) | e << 4)) | e << 2)) | e << 1) | (1431655765 & ((t = 858993459 & ((t = 252645135 & ((t = 16711935 & ((t = 32767 * (t - n) * r) | t << 8)) | t << 4)) | t << 2)) | t << 1)) << 1
    }
    function _i(e, t, i, n, r, a, o, s) {
        return 0 <= (r - o) * (t - s) - (e - o) * (a - s) && 0 <= (e - o) * (n - s) - (i - o) * (t - s) && 0 <= (i - o) * (a - s) - (r - o) * (n - s)
    }
    function b(e, t, i) {
        return (t.y - e.y) * (i.x - t.x) - (t.x - e.x) * (i.y - t.y)
    }
    function Mi(e, t) {
        return e.x === t.x && e.y === t.y
    }
    function Ei(e, t, i, n) {
        return Mi(e, t) && Mi(i, n) || Mi(e, n) && Mi(i, t) || 0 < b(e, t, i) != 0 < b(e, t, n) && 0 < b(i, n, e) != 0 < b(i, n, t)
    }
    function Si(e, t) {
        return b(e.prev, e, e.next) < 0 ? 0 <= b(e, t, e.next) && 0 <= b(e, e.prev, t) : b(e, t, e.prev) < 0 || b(e, e.next, t) < 0
    }
    function Ti(e, t) {
        var i = new Pi(e.i,e.x,e.y)
          , n = new Pi(t.i,t.x,t.y)
          , r = e.next
          , a = t.prev;
        return (e.next = t).prev = e,
        (i.next = r).prev = i,
        (n.next = i).prev = n,
        (a.next = n).prev = a,
        n
    }
    function Ai(e, t, i, n) {
        return e = new Pi(e,t,i),
        n ? (e.next = n.next,
        (e.prev = n).next.prev = e,
        n.next = e) : (e.prev = e).next = e,
        e
    }
    function Li(e) {
        e.next.prev = e.prev,
        e.prev.next = e.next,
        e.prevZ && (e.prevZ.nextZ = e.nextZ),
        e.nextZ && (e.nextZ.prevZ = e.prevZ)
    }
    function Pi(e, t, i) {
        this.i = e,
        this.x = t,
        this.y = i,
        this.nextZ = this.prevZ = this.z = this.next = this.prev = null,
        this.steiner = !1
    }
    function Ri(e) {
        var t = e.length;
        2 < t && e[t - 1].equals(e[0]) && e.pop()
    }
    function Ci(e, t) {
        for (var i = 0; i < t.length; i++)
            e.push(t[i].x),
            e.push(t[i].y)
    }
    function Oi(e, t) {
        f.call(this),
        this.type = "ExtrudeGeometry",
        this.parameters = {
            shapes: e,
            options: t
        },
        this.fromBufferGeometry(new Ii(e,t)),
        this.mergeVertices()
    }
    function Ii(e, j) {
        U.call(this),
        this.type = "ExtrudeBufferGeometry",
        this.parameters = {
            shapes: e,
            options: j
        },
        e = Array.isArray(e) ? e : [e];
        for (var W = this, q = [], X = [], t = 0, i = e.length; t < i; t++)
            !function(e) {
                function t(e, t, i) {
                    return t || console.error("THREE.ExtrudeGeometry: vec does not exist"),
                    t.clone().multiplyScalar(i).add(e)
                }
                function N(e, t, i) {
                    var n = e.x - t.x
                      , r = e.y - t.y
                      , a = i.x - e.x
                      , o = i.y - e.y
                      , s = n * n + r * r;
                    if (Math.abs(n * o - r * a) > Number.EPSILON) {
                        var c = Math.sqrt(s)
                          , h = Math.sqrt(a * a + o * o)
                          , s = t.x - r / c;
                        if (t = t.y + n / c,
                        (r = (a = s + n * (o = ((i.x - o / h - s) * o - (i.y + a / h - t) * a) / (n * o - r * a)) - e.x) * a + (n = t + r * o - e.y) * n) <= 2)
                            return new Y(a,n);
                        r = Math.sqrt(r / 2)
                    } else
                        e = !1,
                        n > Number.EPSILON ? a > Number.EPSILON && (e = !0) : n < -Number.EPSILON ? a < -Number.EPSILON && (e = !0) : Math.sign(r) === Math.sign(o) && (e = !0),
                        r = e ? (a = -r,
                        Math.sqrt(s)) : (a = n,
                        n = r,
                        Math.sqrt(s / 2));
                    return new Y(a / r,n / r)
                }
                function z(e, t) {
                    for (L = e.length; 0 <= --L; ) {
                        var i = L
                          , n = L - 1;
                        n < 0 && (n = e.length - 1);
                        for (var r = d + 2 * y, a = 0; a < r; a++) {
                            var o = A * a
                              , s = t + n + o
                              , c = t + n + (h = A * (a + 1))
                              , h = t + i + h;
                            l(t + i + o),
                            l(s),
                            l(h),
                            l(s),
                            l(c),
                            l(h),
                            o = q.length / 3,
                            u((o = U.generateSideWallUV(W, q, o - 6, o - 3, o - 2, o - 1))[0]),
                            u(o[1]),
                            u(o[3]),
                            u(o[1]),
                            u(o[2]),
                            u(o[3])
                        }
                    }
                }
                function i(e, t, i) {
                    h.push(e),
                    h.push(t),
                    h.push(i)
                }
                function n(e, t, i) {
                    l(e),
                    l(t),
                    l(i),
                    e = q.length / 3,
                    u((e = U.generateTopUV(W, q, e - 3, e - 2, e - 1))[0]),
                    u(e[1]),
                    u(e[2])
                }
                function l(e) {
                    q.push(h[3 * e]),
                    q.push(h[3 * e + 1]),
                    q.push(h[3 * e + 2])
                }
                function u(e) {
                    X.push(e.x),
                    X.push(e.y)
                }
                var r, a, o, s, c, h = [], p = void 0 !== j.curveSegments ? j.curveSegments : 12, d = void 0 !== j.steps ? j.steps : 1, f = void 0 !== j.depth ? j.depth : 100, m = void 0 === j.bevelEnabled || j.bevelEnabled, g = void 0 !== j.bevelThickness ? j.bevelThickness : 6, v = void 0 !== j.bevelSize ? j.bevelSize : g - 2, y = void 0 !== j.bevelSegments ? j.bevelSegments : 3, x = j.extrudePath, U = void 0 !== j.UVGenerator ? j.UVGenerator : Dc, G = (void 0 !== j.amount && (console.warn("THREE.ExtrudeBufferGeometry: amount has been renamed to depth."),
                f = j.amount),
                !1), b = (x && (r = x.getSpacedPoints(d),
                m = !(G = !0),
                a = x.computeFrenetFrames(d, !1),
                o = new Me,
                s = new Me,
                c = new Me),
                m || (v = g = y = 0),
                e = (p = e.extractPoints(p)).shape,
                p.holes);
                if (!Ic.isClockWise(e)) {
                    e = e.reverse();
                    for (var w = 0, _ = b.length; w < _; w++) {
                        var M = b[w];
                        Ic.isClockWise(M) && (b[w] = M.reverse())
                    }
                }
                var E = Ic.triangulateShape(e, b)
                  , S = e
                  , w = 0;
                for (_ = b.length; w < _; w++)
                    M = b[w],
                    e = e.concat(M);
                var T, A = e.length, F = E.length, p = [], L = 0, P = (R = S.length) - 1;
                for (O = L + 1; L < R; L++,
                P++,
                O++)
                    p[L] = N(S[L], S[P = P === R ? 0 : P], S[O = O === R ? 0 : O]);
                var x = []
                  , H = p.concat();
                for (w = 0,
                _ = b.length; w < _; w++) {
                    for (var R, M = b[w], C = [], L = 0, P = (R = M.length) - 1, O = L + 1; L < R; L++,
                    P++,
                    O++)
                        P === R && (P = 0),
                        O === R && (O = 0),
                        C[L] = N(M[L], M[P], M[O]);
                    x.push(C),
                    H = H.concat(C)
                }
                for (P = 0; P < y; P++) {
                    R = P / y;
                    var I = g * Math.cos(R * Math.PI / 2);
                    for (O = v * Math.sin(R * Math.PI / 2),
                    L = 0,
                    R = S.length; L < R; L++) {
                        var D = t(S[L], p[L], O);
                        i(D.x, D.y, -I)
                    }
                    for (w = 0,
                    _ = b.length; w < _; w++)
                        for (M = b[w],
                        C = x[w],
                        L = 0,
                        R = M.length; L < R; L++)
                            i((D = t(M[L], C[L], O)).x, D.y, -I)
                }
                for (O = v,
                L = 0; L < A; L++)
                    D = m ? t(e[L], H[L], O) : e[L],
                    G ? (s.copy(a.normals[0]).multiplyScalar(D.x),
                    o.copy(a.binormals[0]).multiplyScalar(D.y),
                    c.copy(r[0]).add(s).add(o),
                    i(c.x, c.y, c.z)) : i(D.x, D.y, 0);
                for (R = 1; R <= d; R++)
                    for (L = 0; L < A; L++)
                        D = m ? t(e[L], H[L], O) : e[L],
                        G ? (s.copy(a.normals[R]).multiplyScalar(D.x),
                        o.copy(a.binormals[R]).multiplyScalar(D.y),
                        c.copy(r[R]).add(s).add(o),
                        i(c.x, c.y, c.z)) : i(D.x, D.y, f / d * R);
                for (P = y - 1; 0 <= P; P--) {
                    for (R = P / y,
                    I = g * Math.cos(R * Math.PI / 2),
                    O = v * Math.sin(R * Math.PI / 2),
                    L = 0,
                    R = S.length; L < R; L++)
                        i((D = t(S[L], p[L], O)).x, D.y, f + I);
                    for (w = 0,
                    _ = b.length; w < _; w++)
                        for (M = b[w],
                        C = x[w],
                        L = 0,
                        R = M.length; L < R; L++)
                            D = t(M[L], C[L], O),
                            G ? i(D.x, D.y + r[d - 1].y, r[d - 1].x + I) : i(D.x, D.y, f + I)
                }
                var k = q.length / 3;
                if (m) {
                    var B = 0 * A;
                    for (L = 0; L < F; L++)
                        n((T = E[L])[2] + B, T[1] + B, T[0] + B);
                    for (B = A * (d + 2 * y),
                    L = 0; L < F; L++)
                        n((T = E[L])[0] + B, T[1] + B, T[2] + B)
                } else {
                    for (L = 0; L < F; L++)
                        n((T = E[L])[2], T[1], T[0]);
                    for (L = 0; L < F; L++)
                        n((T = E[L])[0] + A * d, T[1] + A * d, T[2] + A * d)
                }
                W.addGroup(k, q.length / 3 - k, 0);
                var k = q.length / 3
                  , V = 0;
                for (z(S, V),
                V += S.length,
                w = 0,
                _ = b.length; w < _; w++)
                    z(M = b[w], V),
                    V += M.length;
                W.addGroup(k, q.length / 3 - k, 1)
            }(e[t]);
        this.addAttribute("position", new z(q,3)),
        this.addAttribute("uv", new z(X,2)),
        this.computeVertexNormals()
    }
    function Di(e, t, i) {
        if (i.shapes = [],
        Array.isArray(e))
            for (var n = 0, r = e.length; n < r; n++)
                i.shapes.push(e[n].uuid);
        else
            i.shapes.push(e.uuid);
        return void 0 !== t.extrudePath && (i.options.extrudePath = t.extrudePath.toJSON()),
        i
    }
    function Bi(e, t) {
        f.call(this),
        this.type = "TextGeometry",
        this.parameters = {
            text: e,
            parameters: t
        },
        this.fromBufferGeometry(new Ni(e,t)),
        this.mergeVertices()
    }
    function Ni(e, t) {
        var i = (t = t || {}).font;
        if (!i || !i.isFont)
            return console.error("THREE.TextGeometry: font parameter is not an instance of THREE.Font."),
            new f;
        e = i.generateShapes(e, t.size),
        t.depth = void 0 !== t.height ? t.height : 50,
        void 0 === t.bevelThickness && (t.bevelThickness = 10),
        void 0 === t.bevelSize && (t.bevelSize = 8),
        void 0 === t.bevelEnabled && (t.bevelEnabled = !1),
        Ii.call(this, e, t),
        this.type = "TextBufferGeometry"
    }
    function zi(e, t, i, n, r, a, o) {
        f.call(this),
        this.type = "SphereGeometry",
        this.parameters = {
            radius: e,
            widthSegments: t,
            heightSegments: i,
            phiStart: n,
            phiLength: r,
            thetaStart: a,
            thetaLength: o
        },
        this.fromBufferGeometry(new Ui(e,t,i,n,r,a,o)),
        this.mergeVertices()
    }
    function Ui(e, t, i, n, r, a, o) {
        U.call(this),
        this.type = "SphereBufferGeometry",
        this.parameters = {
            radius: e,
            widthSegments: t,
            heightSegments: i,
            phiStart: n,
            phiLength: r,
            thetaStart: a,
            thetaLength: o
        },
        e = e || 1,
        t = Math.max(3, Math.floor(t) || 8),
        i = Math.max(2, Math.floor(i) || 6),
        n = void 0 !== n ? n : 0,
        r = void 0 !== r ? r : 2 * Math.PI;
        for (var s = (a = void 0 !== a ? a : 0) + (o = void 0 !== o ? o : Math.PI), c = 0, h = [], l = new Me, u = new Me, p = [], d = [], f = [], m = [], g = 0; g <= i; g++) {
            for (var v = [], y = g / i, x = 0; x <= t; x++) {
                var b = x / t;
                l.x = -e * Math.cos(n + b * r) * Math.sin(a + y * o),
                l.y = e * Math.cos(a + y * o),
                l.z = e * Math.sin(n + b * r) * Math.sin(a + y * o),
                d.push(l.x, l.y, l.z),
                u.set(l.x, l.y, l.z).normalize(),
                f.push(u.x, u.y, u.z),
                m.push(b, 1 - y),
                v.push(c++)
            }
            h.push(v)
        }
        for (g = 0; g < i; g++)
            for (x = 0; x < t; x++)
                e = h[g][x + 1],
                n = h[g][x],
                r = h[g + 1][x],
                o = h[g + 1][x + 1],
                (0 !== g || 0 < a) && p.push(e, n, o),
                (g !== i - 1 || s < Math.PI) && p.push(n, r, o);
        this.setIndex(p),
        this.addAttribute("position", new z(d,3)),
        this.addAttribute("normal", new z(f,3)),
        this.addAttribute("uv", new z(m,2))
    }
    function Gi(e, t, i, n, r, a) {
        f.call(this),
        this.type = "RingGeometry",
        this.parameters = {
            innerRadius: e,
            outerRadius: t,
            thetaSegments: i,
            phiSegments: n,
            thetaStart: r,
            thetaLength: a
        },
        this.fromBufferGeometry(new Fi(e,t,i,n,r,a)),
        this.mergeVertices()
    }
    function Fi(e, t, i, n, r, a) {
        U.call(this),
        this.type = "RingBufferGeometry",
        this.parameters = {
            innerRadius: e,
            outerRadius: t,
            thetaSegments: i,
            phiSegments: n,
            thetaStart: r,
            thetaLength: a
        },
        e = e || .5,
        t = t || 1,
        r = void 0 !== r ? r : 0,
        a = void 0 !== a ? a : 2 * Math.PI,
        i = void 0 !== i ? Math.max(3, i) : 8;
        for (var o, s = [], c = [], h = [], l = [], u = e, p = (t - e) / (n = void 0 !== n ? Math.max(1, n) : 1), d = new Me, f = new Y, m = 0; m <= n; m++) {
            for (o = 0; o <= i; o++)
                e = r + o / i * a,
                d.x = u * Math.cos(e),
                d.y = u * Math.sin(e),
                c.push(d.x, d.y, d.z),
                h.push(0, 0, 1),
                f.x = (d.x / t + 1) / 2,
                f.y = (d.y / t + 1) / 2,
                l.push(f.x, f.y);
            u += p
        }
        for (m = 0; m < n; m++)
            for (t = m * (i + 1),
            o = 0; o < i; o++)
                a = (e = o + t) + i + 2,
                s.push(e, r = e + i + 1, u = e + 1),
                s.push(r, a, u);
        this.setIndex(s),
        this.addAttribute("position", new z(c,3)),
        this.addAttribute("normal", new z(h,3)),
        this.addAttribute("uv", new z(l,2))
    }
    function Hi(e, t, i, n) {
        f.call(this),
        this.type = "LatheGeometry",
        this.parameters = {
            points: e,
            segments: t,
            phiStart: i,
            phiLength: n
        },
        this.fromBufferGeometry(new ki(e,t,i,n)),
        this.mergeVertices()
    }
    function ki(e, t, i, n) {
        U.call(this),
        this.type = "LatheBufferGeometry",
        this.parameters = {
            points: e,
            segments: t,
            phiStart: i,
            phiLength: n
        },
        t = Math.floor(t) || 12,
        i = i || 0,
        n = n || 2 * Math.PI,
        n = Se.clamp(n, 0, 2 * Math.PI);
        for (var r = [], a = [], o = [], s = 1 / t, c = new Me, h = new Y, l = 0; l <= t; l++)
            for (var u = i + l * s * n, p = Math.sin(u), d = Math.cos(u), u = 0; u <= e.length - 1; u++)
                c.x = e[u].x * p,
                c.y = e[u].y,
                c.z = e[u].x * d,
                a.push(c.x, c.y, c.z),
                h.x = l / t,
                h.y = u / (e.length - 1),
                o.push(h.x, h.y);
        for (l = 0; l < t; l++)
            for (u = 0; u < e.length - 1; u++)
                s = (i = u + l * e.length) + e.length,
                c = i + e.length + 1,
                r.push(i, s, h = i + 1),
                r.push(s, c, h);
        if (this.setIndex(r),
        this.addAttribute("position", new z(a,3)),
        this.addAttribute("uv", new z(o,2)),
        this.computeVertexNormals(),
        n === 2 * Math.PI)
            for (n = this.attributes.normal.array,
            r = new Me,
            a = new Me,
            o = new Me,
            i = t * e.length * 3,
            u = l = 0; l < e.length; l++,
            u += 3)
                r.x = n[u + 0],
                r.y = n[u + 1],
                r.z = n[u + 2],
                a.x = n[i + u + 0],
                a.y = n[i + u + 1],
                a.z = n[i + u + 2],
                o.addVectors(r, a).normalize(),
                n[u + 0] = n[i + u + 0] = o.x,
                n[u + 1] = n[i + u + 1] = o.y,
                n[u + 2] = n[i + u + 2] = o.z
    }
    function Vi(e, t) {
        f.call(this),
        this.type = "ShapeGeometry",
        "object" == typeof t && (console.warn("THREE.ShapeGeometry: Options parameter has been removed."),
        t = t.curveSegments),
        this.parameters = {
            shapes: e,
            curveSegments: t
        },
        this.fromBufferGeometry(new ji(e,t)),
        this.mergeVertices()
    }
    function ji(e, s) {
        function t(e) {
            var t, i = h.length / 3, n = (e = e.extractPoints(s)).shape, r = e.holes;
            for (!1 === Ic.isClockWise(n) && (n = n.reverse()),
            e = 0,
            t = r.length; e < t; e++) {
                var a = r[e];
                !0 === Ic.isClockWise(a) && (r[e] = a.reverse())
            }
            var o = Ic.triangulateShape(n, r);
            for (e = 0,
            t = r.length; e < t; e++)
                a = r[e],
                n = n.concat(a);
            for (e = 0,
            t = n.length; e < t; e++)
                a = n[e],
                h.push(a.x, a.y, 0),
                l.push(0, 0, 1),
                u.push(a.x, a.y);
            for (e = 0,
            t = o.length; e < t; e++)
                n = o[e],
                c.push(n[0] + i, n[1] + i, n[2] + i),
                p += 3
        }
        U.call(this),
        this.type = "ShapeBufferGeometry",
        this.parameters = {
            shapes: e,
            curveSegments: s
        },
        s = s || 12;
        var c = []
          , h = []
          , l = []
          , u = []
          , i = 0
          , p = 0;
        if (!1 === Array.isArray(e))
            t(e);
        else
            for (var n = 0; n < e.length; n++)
                t(e[n]),
                this.addGroup(i, p, n),
                i += p,
                p = 0;
        this.setIndex(c),
        this.addAttribute("position", new z(h,3)),
        this.addAttribute("normal", new z(l,3)),
        this.addAttribute("uv", new z(u,2))
    }
    function Wi(e, t) {
        if (t.shapes = [],
        Array.isArray(e))
            for (var i = 0, n = e.length; i < n; i++)
                t.shapes.push(e[i].uuid);
        else
            t.shapes.push(e.uuid);
        return t
    }
    function qi(e, t) {
        U.call(this),
        this.type = "EdgesGeometry",
        this.parameters = {
            thresholdAngle: t
        };
        var i = []
          , n = (t = Math.cos(Se.DEG2RAD * (void 0 !== t ? t : 1)),
        [0, 0])
          , r = {}
          , a = ["a", "b", "c"];
        e.isBufferGeometry ? (o = new f).fromBufferGeometry(e) : o = e.clone(),
        o.mergeVertices(),
        o.computeFaceNormals(),
        e = o.vertices;
        for (var o, s = 0, c = (o = o.faces).length; s < c; s++)
            for (var h = o[s], l = 0; l < 3; l++) {
                var u = h[a[l]]
                  , p = h[a[(l + 1) % 3]];
                n[0] = Math.min(u, p),
                n[1] = Math.max(u, p),
                void 0 === r[u = n[0] + "," + n[1]] ? r[u] = {
                    index1: n[0],
                    index2: n[1],
                    face1: s,
                    face2: void 0
                } : r[u].face2 = s
            }
        for (u in r)
            (void 0 === (n = r[u]).face2 || o[n.face1].normal.dot(o[n.face2].normal) <= t) && (a = e[n.index1],
            i.push(a.x, a.y, a.z),
            a = e[n.index2],
            i.push(a.x, a.y, a.z));
        this.addAttribute("position", new z(i,3))
    }
    function Xi(e, t, i, n, r, a, o, s) {
        f.call(this),
        this.type = "CylinderGeometry",
        this.parameters = {
            radiusTop: e,
            radiusBottom: t,
            height: i,
            radialSegments: n,
            heightSegments: r,
            openEnded: a,
            thetaStart: o,
            thetaLength: s
        },
        this.fromBufferGeometry(new Yi(e,t,i,n,r,a,o,s)),
        this.mergeVertices()
    }
    function Yi(u, p, e, d, t, i, f, m) {
        function n(e) {
            for (var t = new Y, i = new Me, n = 0, r = !0 === e ? u : p, a = !0 === e ? 1 : -1, o = w, s = 1; s <= d; s++)
                y.push(0, _ * a, 0),
                x.push(0, a, 0),
                b.push(.5, .5),
                w++;
            var c = w;
            for (s = 0; s <= d; s++) {
                var h = s / d * m + f
                  , l = Math.cos(h)
                  , h = Math.sin(h);
                i.x = r * h,
                i.y = _ * a,
                i.z = r * l,
                y.push(i.x, i.y, i.z),
                x.push(0, a, 0),
                t.x = .5 * l + .5,
                t.y = .5 * h * a + .5,
                b.push(t.x, t.y),
                w++
            }
            for (s = 0; s < d; s++)
                t = o + s,
                i = c + s,
                !0 === e ? v.push(i, i + 1, t) : v.push(i + 1, i, t),
                n += 3;
            g.addGroup(M, n, !0 === e ? 1 : 2),
            M += n
        }
        U.call(this),
        this.type = "CylinderBufferGeometry",
        this.parameters = {
            radiusTop: u,
            radiusBottom: p,
            height: e,
            radialSegments: d,
            heightSegments: t,
            openEnded: i,
            thetaStart: f,
            thetaLength: m
        };
        for (var g = this, v = (u = void 0 !== u ? u : 1,
        p = void 0 !== p ? p : 1,
        e = e || 1,
        d = Math.floor(d) || 8,
        t = Math.floor(t) || 1,
        i = void 0 !== i && i,
        f = void 0 !== f ? f : 0,
        m = void 0 !== m ? m : 2 * Math.PI,
        []), y = [], x = [], b = [], w = 0, r = [], _ = e / 2, M = 0, a = new Me, o = new Me, s = 0, c = (p - u) / e, h = 0; h <= t; h++) {
            for (var l = [], E = h / t, S = E * (p - u) + u, T = 0; T <= d; T++) {
                var A = T / d
                  , L = A * m + f
                  , P = Math.sin(L)
                  , L = Math.cos(L);
                o.x = S * P,
                o.y = -E * e + _,
                o.z = S * L,
                y.push(o.x, o.y, o.z),
                a.set(P, c, L).normalize(),
                x.push(a.x, a.y, a.z),
                b.push(A, 1 - E),
                l.push(w++)
            }
            r.push(l)
        }
        for (T = 0; T < d; T++)
            for (h = 0; h < t; h++)
                a = r[h + 1][T],
                o = r[h + 1][T + 1],
                c = r[h][T + 1],
                v.push(r[h][T], a, c),
                v.push(a, o, c),
                s += 6;
        g.addGroup(M, s, 0),
        M += s,
        !1 === i && (0 < u && n(!0),
        0 < p) && n(!1),
        this.setIndex(v),
        this.addAttribute("position", new z(y,3)),
        this.addAttribute("normal", new z(x,3)),
        this.addAttribute("uv", new z(b,2))
    }
    function Ji(e, t, i, n, r, a, o) {
        Xi.call(this, 0, e, t, i, n, r, a, o),
        this.type = "ConeGeometry",
        this.parameters = {
            radius: e,
            height: t,
            radialSegments: i,
            heightSegments: n,
            openEnded: r,
            thetaStart: a,
            thetaLength: o
        }
    }
    function Zi(e, t, i, n, r, a, o) {
        Yi.call(this, 0, e, t, i, n, r, a, o),
        this.type = "ConeBufferGeometry",
        this.parameters = {
            radius: e,
            height: t,
            radialSegments: i,
            heightSegments: n,
            openEnded: r,
            thetaStart: a,
            thetaLength: o
        }
    }
    function Qi(e, t, i, n) {
        f.call(this),
        this.type = "CircleGeometry",
        this.parameters = {
            radius: e,
            segments: t,
            thetaStart: i,
            thetaLength: n
        },
        this.fromBufferGeometry(new Ki(e,t,i,n)),
        this.mergeVertices()
    }
    function Ki(e, t, i, n) {
        U.call(this),
        this.type = "CircleBufferGeometry",
        this.parameters = {
            radius: e,
            segments: t,
            thetaStart: i,
            thetaLength: n
        },
        e = e || 1,
        t = void 0 !== t ? Math.max(3, t) : 8,
        i = void 0 !== i ? i : 0,
        n = void 0 !== n ? n : 2 * Math.PI;
        for (var r = [], a = [], o = [], s = [], c = new Me, h = new Y, l = (a.push(0, 0, 0),
        o.push(0, 0, 1),
        s.push(.5, .5),
        0), u = 3; l <= t; l++,
        u += 3) {
            var p = i + l / t * n;
            c.x = e * Math.cos(p),
            c.y = e * Math.sin(p),
            a.push(c.x, c.y, c.z),
            o.push(0, 0, 1),
            h.x = (a[u] / e + 1) / 2,
            h.y = (a[u + 1] / e + 1) / 2,
            s.push(h.x, h.y)
        }
        for (u = 1; u <= t; u++)
            r.push(u, u + 1, 0);
        this.setIndex(r),
        this.addAttribute("position", new z(a,3)),
        this.addAttribute("normal", new z(o,3)),
        this.addAttribute("uv", new z(s,2))
    }
    function $i(e) {
        a.call(this),
        this.type = "ShadowMaterial",
        this.color = new d(0),
        this.transparent = !0,
        this.setValues(e)
    }
    function en(e) {
        te.call(this, e),
        this.type = "RawShaderMaterial"
    }
    function tn(e) {
        a.call(this),
        this.defines = {
            STANDARD: ""
        },
        this.type = "MeshStandardMaterial",
        this.color = new d(16777215),
        this.metalness = this.roughness = .5,
        this.lightMap = this.map = null,
        this.lightMapIntensity = 1,
        this.aoMap = null,
        this.aoMapIntensity = 1,
        this.emissive = new d(0),
        this.emissiveIntensity = 1,
        this.bumpMap = this.emissiveMap = null,
        this.bumpScale = 1,
        this.normalMap = null,
        this.normalMapType = 0,
        this.normalScale = new Y(1,1),
        this.displacementMap = null,
        this.displacementScale = 1,
        this.displacementBias = 0,
        this.envMap = this.alphaMap = this.metalnessMap = this.roughnessMap = null,
        this.envMapIntensity = 1,
        this.refractionRatio = .98,
        this.wireframe = !1,
        this.wireframeLinewidth = 1,
        this.wireframeLinejoin = this.wireframeLinecap = "round",
        this.morphNormals = this.morphTargets = this.skinning = !1,
        this.setValues(e)
    }
    function nn(e) {
        tn.call(this),
        this.defines = {
            PHYSICAL: ""
        },
        this.type = "MeshPhysicalMaterial",
        this.reflectivity = .5,
        this.clearCoatRoughness = this.clearCoat = 0,
        this.setValues(e)
    }
    function rn(e) {
        a.call(this),
        this.type = "MeshPhongMaterial",
        this.color = new d(16777215),
        this.specular = new d(1118481),
        this.shininess = 30,
        this.lightMap = this.map = null,
        this.lightMapIntensity = 1,
        this.aoMap = null,
        this.aoMapIntensity = 1,
        this.emissive = new d(0),
        this.emissiveIntensity = 1,
        this.bumpMap = this.emissiveMap = null,
        this.bumpScale = 1,
        this.normalMap = null,
        this.normalMapType = 0,
        this.normalScale = new Y(1,1),
        this.displacementMap = null,
        this.displacementScale = 1,
        this.displacementBias = 0,
        this.envMap = this.alphaMap = this.specularMap = null,
        this.combine = 0,
        this.reflectivity = 1,
        this.refractionRatio = .98,
        this.wireframe = !1,
        this.wireframeLinewidth = 1,
        this.wireframeLinejoin = this.wireframeLinecap = "round",
        this.morphNormals = this.morphTargets = this.skinning = !1,
        this.setValues(e)
    }
    function an(e) {
        rn.call(this),
        this.defines = {
            TOON: ""
        },
        this.type = "MeshToonMaterial",
        this.gradientMap = null,
        this.setValues(e)
    }
    function on(e) {
        a.call(this),
        this.type = "MeshNormalMaterial",
        this.bumpMap = null,
        this.bumpScale = 1,
        this.normalMap = null,
        this.normalMapType = 0,
        this.normalScale = new Y(1,1),
        this.displacementMap = null,
        this.displacementScale = 1,
        this.displacementBias = 0,
        this.wireframe = !1,
        this.wireframeLinewidth = 1,
        this.morphNormals = this.morphTargets = this.skinning = this.lights = this.fog = !1,
        this.setValues(e)
    }
    function sn(e) {
        a.call(this),
        this.type = "MeshLambertMaterial",
        this.color = new d(16777215),
        this.lightMap = this.map = null,
        this.lightMapIntensity = 1,
        this.aoMap = null,
        this.aoMapIntensity = 1,
        this.emissive = new d(0),
        this.emissiveIntensity = 1,
        this.envMap = this.alphaMap = this.specularMap = this.emissiveMap = null,
        this.combine = 0,
        this.reflectivity = 1,
        this.refractionRatio = .98,
        this.wireframe = !1,
        this.wireframeLinewidth = 1,
        this.wireframeLinejoin = this.wireframeLinecap = "round",
        this.morphNormals = this.morphTargets = this.skinning = !1,
        this.setValues(e)
    }
    function cn(e) {
        a.call(this),
        this.defines = {
            MATCAP: ""
        },
        this.type = "MeshMatcapMaterial",
        this.color = new d(16777215),
        this.bumpMap = this.map = this.matcap = null,
        this.bumpScale = 1,
        this.normalMap = null,
        this.normalMapType = 0,
        this.normalScale = new Y(1,1),
        this.displacementMap = null,
        this.displacementScale = 1,
        this.displacementBias = 0,
        this.alphaMap = null,
        this.lights = this.morphNormals = this.morphTargets = this.skinning = !1,
        this.setValues(e)
    }
    function hn(e) {
        y.call(this),
        this.type = "LineDashedMaterial",
        this.scale = 1,
        this.dashSize = 3,
        this.gapSize = 1,
        this.setValues(e)
    }
    function ln(e, t, i, n) {
        this.parameterPositions = e,
        this._cachedIndex = 0,
        this.resultBuffer = void 0 !== n ? n : new t.constructor(i),
        this.sampleValues = t,
        this.valueSize = i
    }
    function un(e, t, i, n) {
        ln.call(this, e, t, i, n),
        this._offsetNext = this._weightNext = this._offsetPrev = this._weightPrev = -0
    }
    function pn(e, t, i, n) {
        ln.call(this, e, t, i, n)
    }
    function dn(e, t, i, n) {
        ln.call(this, e, t, i, n)
    }
    function c(e, t, i, n) {
        if (void 0 === e)
            throw Error("THREE.KeyframeTrack: track name is undefined");
        if (void 0 === t || 0 === t.length)
            throw Error("THREE.KeyframeTrack: no keyframes in track named " + e);
        this.name = e,
        this.times = A.convertArray(t, this.TimeBufferType),
        this.values = A.convertArray(i, this.ValueBufferType),
        this.setInterpolation(n || this.DefaultInterpolation)
    }
    function fn(e, t, i) {
        c.call(this, e, t, i)
    }
    function mn(e, t, i, n) {
        c.call(this, e, t, i, n)
    }
    function gn(e, t, i, n) {
        c.call(this, e, t, i, n)
    }
    function vn(e, t, i, n) {
        ln.call(this, e, t, i, n)
    }
    function yn(e, t, i, n) {
        c.call(this, e, t, i, n)
    }
    function xn(e, t, i, n) {
        c.call(this, e, t, i, n)
    }
    function bn(e, t, i, n) {
        c.call(this, e, t, i, n)
    }
    function wn(e, t, i) {
        this.name = e,
        this.tracks = i,
        this.duration = void 0 !== t ? t : -1,
        this.uuid = Se.generateUUID(),
        this.duration < 0 && this.resetDuration()
    }
    function _n(e) {
        if (void 0 === e.type)
            throw Error("THREE.KeyframeTrack: track type undefined, can not parse");
        var t, i, n = function(e) {
            switch (e.toLowerCase()) {
            case "scalar":
            case "double":
            case "float":
            case "number":
            case "integer":
                return gn;
            case "vector":
            case "vector2":
            case "vector3":
            case "vector4":
                return bn;
            case "color":
                return mn;
            case "quaternion":
                return yn;
            case "bool":
            case "boolean":
                return fn;
            case "string":
                return xn
            }
            throw Error("THREE.KeyframeTrack: Unsupported typeName: " + e)
        }(e.type);
        return void 0 === e.times && (A.flattenJSON(e.keys, t = [], i = [], "value"),
        e.times = t,
        e.values = i),
        void 0 !== n.parse ? n.parse(e) : new n(e.name,e.times,e.values,e.interpolation)
    }
    function Mn(e, t, i) {
        var n = this
          , r = !1
          , a = 0
          , o = 0
          , s = void 0;
        this.onStart = void 0,
        this.onLoad = e,
        this.onProgress = t,
        this.onError = i,
        this.itemStart = function(e) {
            o++,
            !1 === r && void 0 !== n.onStart && n.onStart(e, a, o),
            r = !0
        }
        ,
        this.itemEnd = function(e) {
            a++,
            void 0 !== n.onProgress && n.onProgress(e, a, o),
            a === o && (r = !1,
            void 0 !== n.onLoad) && n.onLoad()
        }
        ,
        this.itemError = function(e) {
            void 0 !== n.onError && n.onError(e)
        }
        ,
        this.resolveURL = function(e) {
            return s ? s(e) : e
        }
        ,
        this.setURLModifier = function(e) {
            return s = e,
            this
        }
    }
    function En(e) {
        this.manager = void 0 !== e ? e : Uc
    }
    function Sn(e) {
        this.manager = void 0 !== e ? e : Uc
    }
    function Tn(e) {
        this.manager = void 0 !== e ? e : Uc,
        this._parser = null
    }
    function An(e) {
        this.manager = void 0 !== e ? e : Uc,
        this._parser = null
    }
    function Ln(e) {
        this.manager = void 0 !== e ? e : Uc
    }
    function Pn(e) {
        this.manager = void 0 !== e ? e : Uc
    }
    function Rn(e) {
        this.manager = void 0 !== e ? e : Uc
    }
    function l() {
        this.type = "Curve",
        this.arcLengthDivisions = 200
    }
    function Cn(e, t, i, n, r, a, o, s) {
        l.call(this),
        this.type = "EllipseCurve",
        this.aX = e || 0,
        this.aY = t || 0,
        this.xRadius = i || 1,
        this.yRadius = n || 1,
        this.aStartAngle = r || 0,
        this.aEndAngle = a || 2 * Math.PI,
        this.aClockwise = o || !1,
        this.aRotation = s || 0
    }
    function On(e, t, i, n, r, a) {
        Cn.call(this, e, t, i, i, n, r, a),
        this.type = "ArcCurve"
    }
    function In() {
        var s = 0
          , c = 0
          , h = 0
          , l = 0;
        return {
            initCatmullRom: function(e, t, i, n, r) {
                h = -3 * (s = t) + 3 * i - 2 * (c = e = r * (i - e)) - (n = r * (n - t)),
                l = 2 * t - 2 * i + e + n
            },
            initNonuniformCatmullRom: function(e, t, i, n, r, a, o) {
                h = -3 * (s = t) + 3 * i - 2 * (c = e = ((t - e) / r - (i - e) / (r + a) + (i - t) / a) * a) - (n = ((i - t) / a - (n - t) / (a + o) + (n - i) / o) * a),
                l = 2 * t - 2 * i + e + n
            },
            calc: function(e) {
                var t = e * e;
                return s + c * e + h * t + l * t * e
            }
        }
    }
    function i(e, t, i, n) {
        l.call(this),
        this.type = "CatmullRomCurve3",
        this.points = e || [],
        this.closed = t || !1,
        this.curveType = i || "centripetal",
        this.tension = n || .5
    }
    function Dn(e, t, i, n, r) {
        var a = e * e;
        return (2 * i - 2 * n + (t = .5 * (n - t)) + (r = .5 * (r - i))) * e * a + (-3 * i + 3 * n - 2 * t - r) * a + t * e + i
    }
    function Bn(e, t, i, n) {
        var r = 1 - e;
        return r * r * t + 2 * (1 - e) * e * i + e * e * n
    }
    function Nn(e, t, i, n, r) {
        var a = 1 - e
          , o = 1 - e;
        return a * a * a * t + 3 * o * o * e * i + 3 * (1 - e) * e * e * n + e * e * e * r
    }
    function zn(e, t, i, n) {
        l.call(this),
        this.type = "CubicBezierCurve",
        this.v0 = e || new Y,
        this.v1 = t || new Y,
        this.v2 = i || new Y,
        this.v3 = n || new Y
    }
    function Un(e, t, i, n) {
        l.call(this),
        this.type = "CubicBezierCurve3",
        this.v0 = e || new Me,
        this.v1 = t || new Me,
        this.v2 = i || new Me,
        this.v3 = n || new Me
    }
    function Gn(e, t) {
        l.call(this),
        this.type = "LineCurve",
        this.v1 = e || new Y,
        this.v2 = t || new Y
    }
    function Fn(e, t) {
        l.call(this),
        this.type = "LineCurve3",
        this.v1 = e || new Me,
        this.v2 = t || new Me
    }
    function Hn(e, t, i) {
        l.call(this),
        this.type = "QuadraticBezierCurve",
        this.v0 = e || new Y,
        this.v1 = t || new Y,
        this.v2 = i || new Y
    }
    function kn(e, t, i) {
        l.call(this),
        this.type = "QuadraticBezierCurve3",
        this.v0 = e || new Me,
        this.v1 = t || new Me,
        this.v2 = i || new Me
    }
    function Vn(e) {
        l.call(this),
        this.type = "SplineCurve",
        this.points = e || []
    }
    function jn() {
        l.call(this),
        this.type = "CurvePath",
        this.curves = [],
        this.autoClose = !1
    }
    function Wn(e) {
        jn.call(this),
        this.type = "Path",
        this.currentPoint = new Y,
        e && this.setFromPoints(e)
    }
    function qn(e) {
        Wn.call(this, e),
        this.uuid = Se.generateUUID(),
        this.type = "Shape",
        this.holes = []
    }
    function _(e, t) {
        u.call(this),
        this.type = "Light",
        this.color = new d(e),
        this.intensity = void 0 !== t ? t : 1,
        this.receiveShadow = void 0
    }
    function Xn(e, t, i) {
        _.call(this, e, i),
        this.type = "HemisphereLight",
        this.castShadow = void 0,
        this.position.copy(u.DefaultUp),
        this.updateMatrix(),
        this.groundColor = new d(t)
    }
    function Yn(e) {
        this.camera = e,
        this.bias = 0,
        this.radius = 1,
        this.mapSize = new Y(512,512),
        this.map = null,
        this.matrix = new _e
    }
    function Jn() {
        Yn.call(this, new E(50,1,.5,500))
    }
    function Zn(e, t, i, n, r, a) {
        _.call(this, e, t),
        this.type = "SpotLight",
        this.position.copy(u.DefaultUp),
        this.updateMatrix(),
        this.target = new u,
        Object.defineProperty(this, "power", {
            get: function() {
                return this.intensity * Math.PI
            },
            set: function(e) {
                this.intensity = e / Math.PI
            }
        }),
        this.distance = void 0 !== i ? i : 0,
        this.angle = void 0 !== n ? n : Math.PI / 3,
        this.penumbra = void 0 !== r ? r : 0,
        this.decay = void 0 !== a ? a : 1,
        this.shadow = new Jn
    }
    function Qn(e, t, i, n) {
        _.call(this, e, t),
        this.type = "PointLight",
        Object.defineProperty(this, "power", {
            get: function() {
                return 4 * this.intensity * Math.PI
            },
            set: function(e) {
                this.intensity = e / (4 * Math.PI)
            }
        }),
        this.distance = void 0 !== i ? i : 0,
        this.decay = void 0 !== n ? n : 1,
        this.shadow = new Yn(new E(90,1,.5,500))
    }
    function Kn(e, t, i, n, r, a) {
        Pt.call(this),
        this.type = "OrthographicCamera",
        this.zoom = 1,
        this.view = null,
        this.left = void 0 !== e ? e : -1,
        this.right = void 0 !== t ? t : 1,
        this.top = void 0 !== i ? i : 1,
        this.bottom = void 0 !== n ? n : -1,
        this.near = void 0 !== r ? r : .1,
        this.far = void 0 !== a ? a : 2e3,
        this.updateProjectionMatrix()
    }
    function $n() {
        Yn.call(this, new Kn(-5,5,5,-5,.5,500))
    }
    function er(e, t) {
        _.call(this, e, t),
        this.type = "DirectionalLight",
        this.position.copy(u.DefaultUp),
        this.updateMatrix(),
        this.target = new u,
        this.shadow = new $n
    }
    function tr(e, t) {
        _.call(this, e, t),
        this.type = "AmbientLight",
        this.castShadow = void 0
    }
    function ir(e, t, i, n) {
        _.call(this, e, t),
        this.type = "RectAreaLight",
        this.width = void 0 !== i ? i : 10,
        this.height = void 0 !== n ? n : 10
    }
    function nr(e) {
        this.manager = void 0 !== e ? e : Uc,
        this.textures = {}
    }
    function rr(e) {
        this.manager = void 0 !== e ? e : Uc
    }
    function ar(e) {
        this.manager = void 0 !== e ? e : Uc,
        this.resourcePath = ""
    }
    function or(e) {
        "undefined" == typeof createImageBitmap && console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."),
        "undefined" == typeof fetch && console.warn("THREE.ImageBitmapLoader: fetch() not supported."),
        this.manager = void 0 !== e ? e : Uc,
        this.options = void 0
    }
    function sr() {
        this.type = "ShapePath",
        this.color = new d,
        this.subPaths = [],
        this.currentPath = null
    }
    function cr(e) {
        this.type = "Font",
        this.data = e
    }
    function hr(e) {
        this.manager = void 0 !== e ? e : Uc
    }
    function lr() {}
    function ur(e) {
        this.manager = void 0 !== e ? e : Uc
    }
    function pr() {
        this.type = "StereoCamera",
        this.aspect = 1,
        this.eyeSep = .064,
        this.cameraL = new E,
        this.cameraL.layers.enable(1),
        this.cameraL.matrixAutoUpdate = !1,
        this.cameraR = new E,
        this.cameraR.layers.enable(2),
        this.cameraR.matrixAutoUpdate = !1
    }
    function dr(e, t, i, n) {
        u.call(this),
        this.type = "CubeCamera";
        var a = new E(90,1,e,t)
          , o = (a.up.set(0, -1, 0),
        a.lookAt(new Me(1,0,0)),
        this.add(a),
        new E(90,1,e,t))
          , s = (o.up.set(0, -1, 0),
        o.lookAt(new Me(-1,0,0)),
        this.add(o),
        new E(90,1,e,t))
          , c = (s.up.set(0, 0, 1),
        s.lookAt(new Me(0,1,0)),
        this.add(s),
        new E(90,1,e,t))
          , h = (c.up.set(0, 0, -1),
        c.lookAt(new Me(0,-1,0)),
        this.add(c),
        new E(90,1,e,t))
          , l = (h.up.set(0, -1, 0),
        h.lookAt(new Me(0,0,1)),
        this.add(h),
        new E(90,1,e,t));
        l.up.set(0, -1, 0),
        l.lookAt(new Me(0,0,-1)),
        this.add(l),
        this.renderTarget = new C(i,i,n = n || {
            format: 1022,
            magFilter: 1006,
            minFilter: 1006
        }),
        this.renderTarget.texture.name = "CubeCamera",
        this.update = function(e, t) {
            null === this.parent && this.updateMatrixWorld();
            var i = e.getRenderTarget()
              , n = this.renderTarget
              , r = n.texture.generateMipmaps;
            n.texture.generateMipmaps = !1,
            n.activeCubeFace = 0,
            e.render(t, a, n),
            n.activeCubeFace = 1,
            e.render(t, o, n),
            n.activeCubeFace = 2,
            e.render(t, s, n),
            n.activeCubeFace = 3,
            e.render(t, c, n),
            n.activeCubeFace = 4,
            e.render(t, h, n),
            n.texture.generateMipmaps = r,
            n.activeCubeFace = 5,
            e.render(t, l, n),
            e.setRenderTarget(i)
        }
        ,
        this.clear = function(e, t, i, n) {
            for (var r = e.getRenderTarget(), a = this.renderTarget, o = 0; o < 6; o++)
                a.activeCubeFace = o,
                e.setRenderTarget(a),
                e.clear(t, i, n);
            e.setRenderTarget(r)
        }
    }
    function fr(e) {
        this.autoStart = void 0 === e || e,
        this.elapsedTime = this.oldTime = this.startTime = 0,
        this.running = !1
    }
    function mr() {
        u.call(this),
        this.type = "AudioListener",
        this.context = $h.getContext(),
        this.gain = this.context.createGain(),
        this.gain.connect(this.context.destination),
        this.filter = null,
        this.timeDelta = 0
    }
    function gr(e) {
        u.call(this),
        this.type = "Audio",
        this.listener = e,
        this.context = e.context,
        this.gain = this.context.createGain(),
        this.gain.connect(e.getInput()),
        this.autoplay = !1,
        this.buffer = null,
        this.detune = 0,
        this.loop = !1,
        this.offset = this.startTime = 0,
        this.playbackRate = 1,
        this.isPlaying = !1,
        this.hasPlaybackControl = !0,
        this.sourceType = "empty",
        this.filters = []
    }
    function vr(e) {
        gr.call(this, e),
        this.panner = this.context.createPanner(),
        this.panner.connect(this.gain)
    }
    function yr(e, t) {
        this.analyser = e.context.createAnalyser(),
        this.analyser.fftSize = void 0 !== t ? t : 2048,
        this.data = new Uint8Array(this.analyser.frequencyBinCount),
        e.getOutput().connect(this.analyser)
    }
    function xr(e, t, i) {
        switch (this.binding = e,
        this.valueSize = i,
        e = Float64Array,
        t) {
        case "quaternion":
            t = this._slerp;
            break;
        case "string":
        case "bool":
            e = Array,
            t = this._select;
            break;
        default:
            t = this._lerp
        }
        this.buffer = new e(4 * i),
        this._mixBufferRegion = t,
        this.referenceCount = this.useCount = this.cumulativeWeight = 0
    }
    function br(e, t, i) {
        i = i || S.parseTrackName(t),
        this._targetGroup = e,
        this._bindings = e.subscribe_(t, i)
    }
    function S(e, t, i) {
        this.path = t,
        this.parsedPath = i || S.parseTrackName(t),
        this.node = S.findNode(e, this.parsedPath.nodeName) || e,
        this.rootNode = e
    }
    function wr() {
        this.uuid = Se.generateUUID(),
        this._objects = Array.prototype.slice.call(arguments),
        this.nCachedObjects_ = 0;
        var e = {};
        this._indicesByUUID = e;
        for (var t = 0, i = arguments.length; t !== i; ++t)
            e[arguments[t].uuid] = t;
        this._paths = [],
        this._parsedPaths = [],
        this._bindings = [],
        this._bindingsIndicesByPath = {};
        var n = this;
        this.stats = {
            objects: {
                get total() {
                    return n._objects.length
                },
                get inUse() {
                    return this.total - n.nCachedObjects_
                }
            },
            get bindingsPerObject() {
                return n._bindings.length
            }
        }
    }
    function _r(e, t, i) {
        this._mixer = e,
        this._clip = t,
        this._localRoot = i || null,
        t = (e = t.tracks).length,
        i = Array(t);
        for (var n = {
            endingStart: 2400,
            endingEnd: 2400
        }, r = 0; r !== t; ++r) {
            var a = e[r].createInterpolant(null);
            (i[r] = a).settings = n
        }
        this._interpolantSettings = n,
        this._interpolants = i,
        this._propertyBindings = Array(t),
        this._weightInterpolant = this._timeScaleInterpolant = this._byClipCacheIndex = this._cacheIndex = null,
        this.loop = 2201,
        this._loopCount = -1,
        this._startTime = null,
        this.time = 0,
        this._effectiveWeight = this.weight = this._effectiveTimeScale = this.timeScale = 1,
        this.repetitions = 1 / 0,
        this.paused = !1,
        this.enabled = !0,
        this.clampWhenFinished = !1,
        this.zeroSlopeAtEnd = this.zeroSlopeAtStart = !0
    }
    function Mr(e) {
        this._root = e,
        this._initMemoryManager(),
        this.time = this._accuIndex = 0,
        this.timeScale = 1
    }
    function Er(e, t) {
        "string" == typeof e && (console.warn("THREE.Uniform: Type parameter is no longer needed."),
        e = t),
        this.value = e
    }
    function Sr() {
        U.call(this),
        this.type = "InstancedBufferGeometry",
        this.maxInstancedCount = void 0
    }
    function Tr(e, t, i) {
        Ut.call(this, e, t),
        this.meshPerAttribute = i || 1
    }
    function Ar(e, t, i, n) {
        "number" == typeof i && (n = i,
        i = !1,
        console.error("THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument.")),
        m.call(this, e, t, i),
        this.meshPerAttribute = n || 1
    }
    function Lr(e, t, i, n) {
        this.ray = new ie(e,t),
        this.near = i || 0,
        this.far = n || 1 / 0,
        this.params = {
            Mesh: {},
            Line: {},
            LOD: {},
            Points: {
                threshold: 1
            },
            Sprite: {}
        },
        Object.defineProperties(this.params, {
            PointCloud: {
                get: function() {
                    return console.warn("THREE.Raycaster: params.PointCloud has been renamed to params.Points."),
                    this.Points
                }
            }
        })
    }
    function Pr(e, t) {
        return e.distance - t.distance
    }
    function Rr(e, t, i, n) {
        if (!1 !== e.visible && (e.raycast(t, i),
        !0 === n)) {
            n = 0;
            for (var r = (e = e.children).length; n < r; n++)
                Rr(e[n], t, i, !0)
        }
    }
    function Cr(e, t, i) {
        return this.radius = void 0 !== e ? e : 1,
        this.phi = void 0 !== t ? t : 0,
        this.theta = void 0 !== i ? i : 0,
        this
    }
    function Or(e, t, i) {
        return this.radius = void 0 !== e ? e : 1,
        this.theta = void 0 !== t ? t : 0,
        this.y = void 0 !== i ? i : 0,
        this
    }
    function Ir(e, t) {
        this.min = void 0 !== e ? e : new Y(1 / 0,1 / 0),
        this.max = void 0 !== t ? t : new Y(-1 / 0,-1 / 0)
    }
    function Dr(e, t) {
        this.start = void 0 !== e ? e : new Me,
        this.end = void 0 !== t ? t : new Me
    }
    function Br(e) {
        u.call(this),
        this.material = e,
        this.render = function() {}
    }
    function Nr(e, t, i, n) {
        this.object = e,
        this.size = void 0 !== t ? t : 1,
        e = void 0 !== i ? i : 16711680,
        n = void 0 !== n ? n : 1,
        t = 0,
        (i = this.object.geometry) && i.isGeometry ? t = 3 * i.faces.length : i && i.isBufferGeometry && (t = i.attributes.normal.count),
        i = new U,
        t = new z(6 * t,3),
        i.addAttribute("position", t),
        x.call(this, i, new y({
            color: e,
            linewidth: n
        })),
        this.matrixAutoUpdate = !1,
        this.update()
    }
    function zr(e, t) {
        u.call(this),
        this.light = e,
        this.light.updateMatrixWorld(),
        this.matrix = e.matrixWorld,
        this.matrixAutoUpdate = !1,
        this.color = t,
        e = new U,
        t = [0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, -1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, -1, 1];
        for (var i = 0, n = 1; i < 32; i++,
        n++) {
            var r = i / 32 * Math.PI * 2
              , a = n / 32 * Math.PI * 2;
            t.push(Math.cos(r), Math.sin(r), 1, Math.cos(a), Math.sin(a), 1)
        }
        e.addAttribute("position", new z(t,3)),
        t = new y({
            fog: !1
        }),
        this.cone = new x(e,t),
        this.add(this.cone),
        this.update()
    }
    function Ur(e) {
        for (var t = function e(t) {
            var i = [];
            t && t.isBone && i.push(t);
            for (var n = 0; n < t.children.length; n++)
                i.push.apply(i, e(t.children[n]));
            return i
        }(e), i = new U, n = [], r = [], a = new d(0,0,1), o = new d(0,1,0), s = 0; s < t.length; s++) {
            var c = t[s];
            c.parent && c.parent.isBone && (n.push(0, 0, 0),
            n.push(0, 0, 0),
            r.push(a.r, a.g, a.b),
            r.push(o.r, o.g, o.b))
        }
        i.addAttribute("position", new z(n,3)),
        i.addAttribute("color", new z(r,3)),
        n = new y({
            vertexColors: 2,
            depthTest: !1,
            depthWrite: !1,
            transparent: !0
        }),
        x.call(this, i, n),
        this.root = e,
        this.bones = t,
        this.matrix = e.matrixWorld,
        this.matrixAutoUpdate = !1
    }
    function Gr(e, t, i) {
        this.light = e,
        this.light.updateMatrixWorld(),
        this.color = i,
        e = new Ui(t,4,2),
        t = new ne({
            wireframe: !0,
            fog: !1
        }),
        v.call(this, e, t),
        this.matrix = this.light.matrixWorld,
        this.matrixAutoUpdate = !1,
        this.update()
    }
    function Fr(e, t) {
        this.type = "RectAreaLightHelper",
        this.light = e,
        this.color = t,
        (e = new U).addAttribute("position", new z([1, 1, 0, -1, 1, 0, -1, -1, 0, 1, -1, 0, 1, 1, 0],3)),
        e.computeBoundingSphere(),
        t = new y({
            fog: !1
        }),
        h.call(this, e, t),
        (e = new U).addAttribute("position", new z([1, 1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, -1, 0, 1, -1, 0],3)),
        e.computeBoundingSphere(),
        this.add(new v(e,new ne({
            side: 1,
            fog: !1
        }))),
        this.update()
    }
    function Hr(e, t, i) {
        u.call(this),
        this.light = e,
        this.light.updateMatrixWorld(),
        this.matrix = e.matrixWorld,
        this.matrixAutoUpdate = !1,
        this.color = i,
        (e = new si(t)).rotateY(.5 * Math.PI),
        this.material = new ne({
            wireframe: !0,
            fog: !1
        }),
        void 0 === this.color && (this.material.vertexColors = 2),
        t = e.getAttribute("position"),
        t = new Float32Array(3 * t.count),
        e.addAttribute("color", new m(t,3)),
        this.add(new v(e,this.material)),
        this.update()
    }
    function kr(e, t, i, n) {
        e = e || 10,
        t = t || 10,
        i = new d(void 0 !== i ? i : 4473924),
        n = new d(void 0 !== n ? n : 8947848);
        var r = t / 2
          , a = e / t
          , o = e / 2;
        e = [];
        for (var s = [], c = 0, h = 0, l = -o; c <= t; c++,
        l += a) {
            e.push(-o, 0, l, o, 0, l),
            e.push(l, 0, -o, l, 0, o);
            var u = c === r ? i : n;
            u.toArray(s, h),
            h += 3,
            u.toArray(s, h),
            h += 3,
            u.toArray(s, h),
            h += 3,
            u.toArray(s, h),
            h += 3
        }
        (t = new U).addAttribute("position", new z(e,3)),
        t.addAttribute("color", new z(s,3)),
        i = new y({
            vertexColors: 2
        }),
        x.call(this, t, i)
    }
    function Vr(e, t, i, n, r, a) {
        e = e || 10,
        t = t || 16,
        i = i || 8,
        n = n || 64,
        r = new d(void 0 !== r ? r : 4473924),
        a = new d(void 0 !== a ? a : 8947848);
        for (var o = [], s = [], c = 0; c <= t; c++) {
            var h = c / t * 2 * Math.PI
              , l = Math.sin(h) * e
              , h = Math.cos(h) * e
              , u = (o.push(0, 0, 0),
            o.push(l, 0, h),
            1 & c ? r : a);
            s.push(u.r, u.g, u.b),
            s.push(u.r, u.g, u.b)
        }
        for (c = 0; c <= i; c++) {
            var u = 1 & c ? r : a
              , p = e - e / i * c;
            for (t = 0; t < n; t++)
                h = t / n * 2 * Math.PI,
                l = Math.sin(h) * p,
                h = Math.cos(h) * p,
                o.push(l, 0, h),
                s.push(u.r, u.g, u.b),
                h = (t + 1) / n * 2 * Math.PI,
                l = Math.sin(h) * p,
                h = Math.cos(h) * p,
                o.push(l, 0, h),
                s.push(u.r, u.g, u.b)
        }
        (e = new U).addAttribute("position", new z(o,3)),
        e.addAttribute("color", new z(s,3)),
        o = new y({
            vertexColors: 2
        }),
        x.call(this, e, o)
    }
    function jr(e, t, i, n) {
        this.object = e,
        this.size = void 0 !== t ? t : 1,
        e = void 0 !== i ? i : 16776960,
        n = void 0 !== n ? n : 1,
        t = 0,
        (i = this.object.geometry) && i.isGeometry ? t = i.faces.length : console.warn("THREE.FaceNormalsHelper: only THREE.Geometry is supported. Use THREE.VertexNormalsHelper, instead."),
        i = new U,
        t = new z(6 * t,3),
        i.addAttribute("position", t),
        x.call(this, i, new y({
            color: e,
            linewidth: n
        })),
        this.matrixAutoUpdate = !1,
        this.update()
    }
    function Wr(e, t, i) {
        u.call(this),
        this.light = e,
        this.light.updateMatrixWorld(),
        this.matrix = e.matrixWorld,
        this.matrixAutoUpdate = !1,
        this.color = i,
        void 0 === t && (t = 1),
        (e = new U).addAttribute("position", new z([-t, t, 0, t, t, 0, t, -t, 0, -t, -t, 0, -t, t, 0],3)),
        t = new y({
            fog: !1
        }),
        this.lightPlane = new h(e,t),
        this.add(this.lightPlane),
        (e = new U).addAttribute("position", new z([0, 0, 0, 0, 0, 1],3)),
        this.targetLine = new h(e,t),
        this.add(this.targetLine),
        this.update()
    }
    function qr(e) {
        function t(e, t, i) {
            n(e, i),
            n(t, i)
        }
        function n(e, t) {
            a.push(0, 0, 0),
            o.push(t.r, t.g, t.b),
            void 0 === s[e] && (s[e] = []),
            s[e].push(a.length / 3 - 1)
        }
        var i = new U
          , r = new y({
            color: 16777215,
            vertexColors: 1
        })
          , a = []
          , o = []
          , s = {}
          , c = new d(16755200)
          , h = new d(16711680)
          , l = new d(43775)
          , u = new d(16777215)
          , p = new d(3355443);
        t("n1", "n2", c),
        t("n2", "n4", c),
        t("n4", "n3", c),
        t("n3", "n1", c),
        t("f1", "f2", c),
        t("f2", "f4", c),
        t("f4", "f3", c),
        t("f3", "f1", c),
        t("n1", "f1", c),
        t("n2", "f2", c),
        t("n3", "f3", c),
        t("n4", "f4", c),
        t("p", "n1", h),
        t("p", "n2", h),
        t("p", "n3", h),
        t("p", "n4", h),
        t("u1", "u2", l),
        t("u2", "u3", l),
        t("u3", "u1", l),
        t("c", "t", u),
        t("p", "c", p),
        t("cn1", "cn2", p),
        t("cn3", "cn4", p),
        t("cf1", "cf2", p),
        t("cf3", "cf4", p),
        i.addAttribute("position", new z(a,3)),
        i.addAttribute("color", new z(o,3)),
        x.call(this, i, r),
        this.camera = e,
        this.camera.updateProjectionMatrix && this.camera.updateProjectionMatrix(),
        this.matrix = e.matrixWorld,
        this.matrixAutoUpdate = !1,
        this.pointMap = s,
        this.update()
    }
    function Xr(e, t) {
        this.object = e,
        void 0 === t && (t = 16776960),
        e = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]);
        var i = new Float32Array(24)
          , n = new U;
        n.setIndex(new m(e,1)),
        n.addAttribute("position", new m(i,3)),
        x.call(this, n, new y({
            color: t
        })),
        this.matrixAutoUpdate = !1,
        this.update()
    }
    function Yr(e, t) {
        this.type = "Box3Helper",
        this.box = e,
        e = void 0 !== t ? t : 16776960,
        t = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]);
        var i = new U;
        i.setIndex(new m(t,1)),
        i.addAttribute("position", new z([1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1],3)),
        x.call(this, i, new y({
            color: e
        })),
        this.geometry.computeBoundingSphere()
    }
    function Jr(e, t, i) {
        this.type = "PlaneHelper",
        this.plane = e,
        this.size = void 0 === t ? 1 : t,
        e = void 0 !== i ? i : 16776960,
        (t = new U).addAttribute("position", new z([1, -1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0],3)),
        t.computeBoundingSphere(),
        h.call(this, t, new y({
            color: e
        })),
        (t = new U).addAttribute("position", new z([1, 1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, -1, 1, 1, -1, 1],3)),
        t.computeBoundingSphere(),
        this.add(new v(t,new ne({
            color: e,
            opacity: .2,
            transparent: !0,
            depthWrite: !1
        })))
    }
    function Zr(e, t, i, n, r, a) {
        u.call(this),
        void 0 === e && (e = new Me(0,0,1)),
        void 0 === t && (t = new Me(0,0,0)),
        void 0 === i && (i = 1),
        void 0 === n && (n = 16776960),
        void 0 === r && (r = .2 * i),
        void 0 === a && (a = .2 * r),
        void 0 === Yh && ((Yh = new U).addAttribute("position", new z([0, 0, 0, 0, 1, 0],3)),
        (Jh = new Yi(0,.5,1,5,1)).translate(0, -.5, 0)),
        this.position.copy(t),
        this.line = new h(Yh,new y({
            color: n
        })),
        this.line.matrixAutoUpdate = !1,
        this.add(this.line),
        this.cone = new v(Jh,new ne({
            color: n
        })),
        this.cone.matrixAutoUpdate = !1,
        this.add(this.cone),
        this.setDirection(e),
        this.setLength(i, r, a)
    }
    function Qr(e) {
        var t = [0, 0, 0, e = e || 1, 0, 0, 0, 0, 0, 0, e, 0, 0, 0, 0, 0, 0, e];
        (e = new U).addAttribute("position", new z(t,3)),
        e.addAttribute("color", new z([1, 0, 0, 1, .6, 0, 0, 1, 0, .6, 1, 0, 0, 0, 1, 0, .6, 1],3)),
        t = new y({
            vertexColors: 2
        }),
        x.call(this, e, t)
    }
    function Kr(e) {
        console.warn("THREE.ClosedSplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead."),
        i.call(this, e),
        this.type = "catmullrom",
        this.closed = !0
    }
    function $r(e) {
        console.warn("THREE.SplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead."),
        i.call(this, e),
        this.type = "catmullrom"
    }
    function ea(e) {
        console.warn("THREE.Spline has been removed. Use THREE.CatmullRomCurve3 instead."),
        i.call(this, e),
        this.type = "catmullrom"
    }
    void 0 === Number.EPSILON && (Number.EPSILON = Math.pow(2, -52)),
    void 0 === Number.isInteger && (Number.isInteger = function(e) {
        return "number" == typeof e && isFinite(e) && Math.floor(e) === e
    }
    ),
    void 0 === Math.sign && (Math.sign = function(e) {
        return e < 0 ? -1 : 0 < e ? 1 : +e
    }
    ),
    !1 == "name"in Function.prototype && Object.defineProperty(Function.prototype, "name", {
        get: function() {
            return this.toString().match(/^\s*function\s*([^\(\s]*)/)[1]
        }
    }),
    void 0 === Object.assign && (Object.assign = function(e) {
        if (null == e)
            throw new TypeError("Cannot convert undefined or null to object");
        for (var t = Object(e), i = 1; i < arguments.length; i++) {
            var n = arguments[i];
            if (null != n)
                for (var r in n)
                    Object.prototype.hasOwnProperty.call(n, r) && (t[r] = n[r])
        }
        return t
    }
    ),
    Object.assign(L.prototype, {
        addEventListener: function(e, t) {
            void 0 === this._listeners && (this._listeners = {});
            var i = this._listeners;
            void 0 === i[e] && (i[e] = []),
            -1 === i[e].indexOf(t) && i[e].push(t)
        },
        hasEventListener: function(e, t) {
            var i;
            return void 0 !== this._listeners && void 0 !== (i = this._listeners)[e] && -1 !== i[e].indexOf(t)
        },
        removeEventListener: function(e, t) {
            void 0 !== this._listeners && void 0 !== (e = this._listeners[e]) && -1 !== (t = e.indexOf(t)) && e.splice(t, 1)
        },
        dispatchEvent: function(e) {
            if (void 0 !== this._listeners && void 0 !== (t = this._listeners[e.type])) {
                e.target = this;
                for (var t, i = 0, n = (t = t.slice(0)).length; i < n; i++)
                    t[i].call(this, e)
            }
        }
    });
    var ta, ia, na, ra, aa, oa, sa, r, ca, ha, la, ua, pa, da, fa, ma, ga, va, ya, xa, ba, Se = {
        DEG2RAD: Math.PI / 180,
        RAD2DEG: 180 / Math.PI,
        generateUUID: function() {
            for (var r = [], e = 0; e < 256; e++)
                r[e] = (e < 16 ? "0" : "") + e.toString(16);
            return function() {
                var e = 4294967295 * Math.random() | 0
                  , t = 4294967295 * Math.random() | 0
                  , i = 4294967295 * Math.random() | 0
                  , n = 4294967295 * Math.random() | 0;
                return (r[255 & e] + r[e >> 8 & 255] + r[e >> 16 & 255] + r[e >> 24 & 255] + "-" + r[255 & t] + r[t >> 8 & 255] + "-" + r[t >> 16 & 15 | 64] + r[t >> 24 & 255] + "-" + r[63 & i | 128] + r[i >> 8 & 255] + "-" + r[i >> 16 & 255] + r[i >> 24 & 255] + r[255 & n] + r[n >> 8 & 255] + r[n >> 16 & 255] + r[n >> 24 & 255]).toUpperCase()
            }
        }(),
        clamp: function(e, t, i) {
            return Math.max(t, Math.min(i, e))
        },
        euclideanModulo: function(e, t) {
            return (e % t + t) % t
        },
        mapLinear: function(e, t, i, n, r) {
            return n + (e - t) * (r - n) / (i - t)
        },
        lerp: function(e, t, i) {
            return (1 - i) * e + i * t
        },
        smoothstep: function(e, t, i) {
            return e <= t ? 0 : i <= e ? 1 : (e = (e - t) / (i - t)) * e * (3 - 2 * e)
        },
        smootherstep: function(e, t, i) {
            return e <= t ? 0 : i <= e ? 1 : (e = (e - t) / (i - t)) * e * e * (e * (6 * e - 15) + 10)
        },
        randInt: function(e, t) {
            return e + Math.floor(Math.random() * (t - e + 1))
        },
        randFloat: function(e, t) {
            return e + Math.random() * (t - e)
        },
        randFloatSpread: function(e) {
            return e * (.5 - Math.random())
        },
        degToRad: function(e) {
            return e * Se.DEG2RAD
        },
        radToDeg: function(e) {
            return e * Se.RAD2DEG
        },
        isPowerOfTwo: function(e) {
            return 0 == (e & e - 1) && 0 !== e
        },
        ceilPowerOfTwo: function(e) {
            return Math.pow(2, Math.ceil(Math.log(e) / Math.LN2))
        },
        floorPowerOfTwo: function(e) {
            return Math.pow(2, Math.floor(Math.log(e) / Math.LN2))
        }
    };
    Object.defineProperties(Y.prototype, {
        width: {
            get: function() {
                return this.x
            },
            set: function(e) {
                this.x = e
            }
        },
        height: {
            get: function() {
                return this.y
            },
            set: function(e) {
                this.y = e
            }
        }
    }),
    Object.assign(Y.prototype, {
        isVector2: !0,
        set: function(e, t) {
            return this.x = e,
            this.y = t,
            this
        },
        setScalar: function(e) {
            return this.y = this.x = e,
            this
        },
        setX: function(e) {
            return this.x = e,
            this
        },
        setY: function(e) {
            return this.y = e,
            this
        },
        setComponent: function(e, t) {
            switch (e) {
            case 0:
                this.x = t;
                break;
            case 1:
                this.y = t;
                break;
            default:
                throw Error("index is out of range: " + e)
            }
            return this
        },
        getComponent: function(e) {
            switch (e) {
            case 0:
                return this.x;
            case 1:
                return this.y;
            default:
                throw Error("index is out of range: " + e)
            }
        },
        clone: function() {
            return new this.constructor(this.x,this.y)
        },
        copy: function(e) {
            return this.x = e.x,
            this.y = e.y,
            this
        },
        add: function(e, t) {
            return void 0 !== t ? (console.warn("THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),
            this.addVectors(e, t)) : (this.x += e.x,
            this.y += e.y,
            this)
        },
        addScalar: function(e) {
            return this.x += e,
            this.y += e,
            this
        },
        addVectors: function(e, t) {
            return this.x = e.x + t.x,
            this.y = e.y + t.y,
            this
        },
        addScaledVector: function(e, t) {
            return this.x += e.x * t,
            this.y += e.y * t,
            this
        },
        sub: function(e, t) {
            return void 0 !== t ? (console.warn("THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),
            this.subVectors(e, t)) : (this.x -= e.x,
            this.y -= e.y,
            this)
        },
        subScalar: function(e) {
            return this.x -= e,
            this.y -= e,
            this
        },
        subVectors: function(e, t) {
            return this.x = e.x - t.x,
            this.y = e.y - t.y,
            this
        },
        multiply: function(e) {
            return this.x *= e.x,
            this.y *= e.y,
            this
        },
        multiplyScalar: function(e) {
            return this.x *= e,
            this.y *= e,
            this
        },
        divide: function(e) {
            return this.x /= e.x,
            this.y /= e.y,
            this
        },
        divideScalar: function(e) {
            return this.multiplyScalar(1 / e)
        },
        applyMatrix3: function(e) {
            var t = this.x
              , i = this.y;
            return e = e.elements,
            this.x = e[0] * t + e[3] * i + e[6],
            this.y = e[1] * t + e[4] * i + e[7],
            this
        },
        min: function(e) {
            return this.x = Math.min(this.x, e.x),
            this.y = Math.min(this.y, e.y),
            this
        },
        max: function(e) {
            return this.x = Math.max(this.x, e.x),
            this.y = Math.max(this.y, e.y),
            this
        },
        clamp: function(e, t) {
            return this.x = Math.max(e.x, Math.min(t.x, this.x)),
            this.y = Math.max(e.y, Math.min(t.y, this.y)),
            this
        },
        clampScalar: (ta = new Y,
        ia = new Y,
        function(e, t) {
            return ta.set(e, e),
            ia.set(t, t),
            this.clamp(ta, ia)
        }
        ),
        clampLength: function(e, t) {
            var i = this.length();
            return this.divideScalar(i || 1).multiplyScalar(Math.max(e, Math.min(t, i)))
        },
        floor: function() {
            return this.x = Math.floor(this.x),
            this.y = Math.floor(this.y),
            this
        },
        ceil: function() {
            return this.x = Math.ceil(this.x),
            this.y = Math.ceil(this.y),
            this
        },
        round: function() {
            return this.x = Math.round(this.x),
            this.y = Math.round(this.y),
            this
        },
        roundToZero: function() {
            return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x),
            this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y),
            this
        },
        negate: function() {
            return this.x = -this.x,
            this.y = -this.y,
            this
        },
        dot: function(e) {
            return this.x * e.x + this.y * e.y
        },
        cross: function(e) {
            return this.x * e.y - this.y * e.x
        },
        lengthSq: function() {
            return this.x * this.x + this.y * this.y
        },
        length: function() {
            return Math.sqrt(this.x * this.x + this.y * this.y)
        },
        manhattanLength: function() {
            return Math.abs(this.x) + Math.abs(this.y)
        },
        normalize: function() {
            return this.divideScalar(this.length() || 1)
        },
        angle: function() {
            var e = Math.atan2(this.y, this.x);
            return e < 0 && (e += 2 * Math.PI),
            e
        },
        distanceTo: function(e) {
            return Math.sqrt(this.distanceToSquared(e))
        },
        distanceToSquared: function(e) {
            var t = this.x - e.x;
            return t * t + (e = this.y - e.y) * e
        },
        manhattanDistanceTo: function(e) {
            return Math.abs(this.x - e.x) + Math.abs(this.y - e.y)
        },
        setLength: function(e) {
            return this.normalize().multiplyScalar(e)
        },
        lerp: function(e, t) {
            return this.x += (e.x - this.x) * t,
            this.y += (e.y - this.y) * t,
            this
        },
        lerpVectors: function(e, t, i) {
            return this.subVectors(t, e).multiplyScalar(i).add(e)
        },
        equals: function(e) {
            return e.x === this.x && e.y === this.y
        },
        fromArray: function(e, t) {
            return this.x = e[t = void 0 === t ? 0 : t],
            this.y = e[t + 1],
            this
        },
        toArray: function(e, t) {
            return (e = void 0 === e ? [] : e)[t = void 0 === t ? 0 : t] = this.x,
            e[t + 1] = this.y,
            e
        },
        fromBufferAttribute: function(e, t, i) {
            return void 0 !== i && console.warn("THREE.Vector2: offset has been removed from .fromBufferAttribute()."),
            this.x = e.getX(t),
            this.y = e.getY(t),
            this
        },
        rotateAround: function(e, t) {
            var i = Math.cos(t)
              , n = (t = Math.sin(t),
            this.x - e.x)
              , r = this.y - e.y;
            return this.x = n * i - r * t + e.x,
            this.y = n * t + r * i + e.y,
            this
        }
    }),
    Object.assign(_e.prototype, {
        isMatrix4: !0,
        set: function(e, t, i, n, r, a, o, s, c, h, l, u, p, d, f, m) {
            var g = this.elements;
            return g[0] = e,
            g[4] = t,
            g[8] = i,
            g[12] = n,
            g[1] = r,
            g[5] = a,
            g[9] = o,
            g[13] = s,
            g[2] = c,
            g[6] = h,
            g[10] = l,
            g[14] = u,
            g[3] = p,
            g[7] = d,
            g[11] = f,
            g[15] = m,
            this
        },
        identity: function() {
            return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1),
            this
        },
        clone: function() {
            return (new _e).fromArray(this.elements)
        },
        copy: function(e) {
            var t = this.elements;
            return e = e.elements,
            t[0] = e[0],
            t[1] = e[1],
            t[2] = e[2],
            t[3] = e[3],
            t[4] = e[4],
            t[5] = e[5],
            t[6] = e[6],
            t[7] = e[7],
            t[8] = e[8],
            t[9] = e[9],
            t[10] = e[10],
            t[11] = e[11],
            t[12] = e[12],
            t[13] = e[13],
            t[14] = e[14],
            t[15] = e[15],
            this
        },
        copyPosition: function(e) {
            var t = this.elements;
            return e = e.elements,
            t[12] = e[12],
            t[13] = e[13],
            t[14] = e[14],
            this
        },
        extractBasis: function(e, t, i) {
            return e.setFromMatrixColumn(this, 0),
            t.setFromMatrixColumn(this, 1),
            i.setFromMatrixColumn(this, 2),
            this
        },
        makeBasis: function(e, t, i) {
            return this.set(e.x, t.x, i.x, 0, e.y, t.y, i.y, 0, e.z, t.z, i.z, 0, 0, 0, 0, 1),
            this
        },
        extractRotation: (la = new Me,
        function(e) {
            var t = this.elements
              , i = e.elements
              , n = 1 / la.setFromMatrixColumn(e, 0).length()
              , r = 1 / la.setFromMatrixColumn(e, 1).length();
            return e = 1 / la.setFromMatrixColumn(e, 2).length(),
            t[0] = i[0] * n,
            t[1] = i[1] * n,
            t[2] = i[2] * n,
            t[3] = 0,
            t[4] = i[4] * r,
            t[5] = i[5] * r,
            t[6] = i[6] * r,
            t[7] = 0,
            t[8] = i[8] * e,
            t[9] = i[9] * e,
            t[10] = i[10] * e,
            t[11] = 0,
            t[12] = 0,
            t[13] = 0,
            t[14] = 0,
            t[15] = 1,
            this
        }
        ),
        makeRotationFromEuler: function(e) {
            e && e.isEuler || console.error("THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.");
            var t, i, n, r = this.elements, a = e.x, o = e.y, s = e.z, c = Math.cos(a), a = Math.sin(a), h = Math.cos(o), o = Math.sin(o), l = Math.cos(s), s = Math.sin(s);
            return "XYZ" === e.order ? (e = c * l,
            t = c * s,
            i = a * l,
            n = a * s,
            r[0] = h * l,
            r[4] = -h * s,
            r[8] = o,
            r[1] = t + i * o,
            r[5] = e - n * o,
            r[9] = -a * h,
            r[2] = n - e * o,
            r[6] = i + t * o,
            r[10] = c * h) : "YXZ" === e.order ? (t = h * s,
            i = o * l,
            r[0] = (e = h * l) + (n = o * s) * a,
            r[4] = i * a - t,
            r[8] = c * o,
            r[1] = c * s,
            r[5] = c * l,
            r[9] = -a,
            r[2] = t * a - i,
            r[6] = n + e * a,
            r[10] = c * h) : "ZXY" === e.order ? (t = h * s,
            i = o * l,
            r[0] = (e = h * l) - (n = o * s) * a,
            r[4] = -c * s,
            r[8] = i + t * a,
            r[1] = t + i * a,
            r[5] = c * l,
            r[9] = n - e * a,
            r[2] = -c * o,
            r[6] = a,
            r[10] = c * h) : "ZYX" === e.order ? (e = c * l,
            t = c * s,
            i = a * l,
            n = a * s,
            r[0] = h * l,
            r[4] = i * o - t,
            r[8] = e * o + n,
            r[1] = h * s,
            r[5] = n * o + e,
            r[9] = t * o - i,
            r[2] = -o,
            r[6] = a * h,
            r[10] = c * h) : "YZX" === e.order ? (e = c * h,
            t = c * o,
            i = a * h,
            n = a * o,
            r[0] = h * l,
            r[4] = n - e * s,
            r[8] = i * s + t,
            r[1] = s,
            r[5] = c * l,
            r[9] = -a * l,
            r[2] = -o * l,
            r[6] = t * s + i,
            r[10] = e - n * s) : "XZY" === e.order && (e = c * h,
            t = c * o,
            i = a * h,
            n = a * o,
            r[0] = h * l,
            r[4] = -s,
            r[8] = o * l,
            r[1] = e * s + n,
            r[5] = c * l,
            r[9] = t * s - i,
            r[2] = i * s - t,
            r[6] = a * l,
            r[10] = n * s + e),
            r[3] = 0,
            r[7] = 0,
            r[11] = 0,
            r[12] = 0,
            r[13] = 0,
            r[14] = 0,
            r[15] = 1,
            this
        },
        makeRotationFromQuaternion: (ca = new Me(0,0,0),
        ha = new Me(1,1,1),
        function(e) {
            return this.compose(ca, e, ha)
        }
        ),
        lookAt: (oa = new Me,
        sa = new Me,
        r = new Me,
        function(e, t, i) {
            var n = this.elements;
            return r.subVectors(e, t),
            0 === r.lengthSq() && (r.z = 1),
            r.normalize(),
            oa.crossVectors(i, r),
            0 === oa.lengthSq() && (1 === Math.abs(i.z) ? r.x += 1e-4 : r.z += 1e-4,
            r.normalize(),
            oa.crossVectors(i, r)),
            oa.normalize(),
            sa.crossVectors(r, oa),
            n[0] = oa.x,
            n[4] = sa.x,
            n[8] = r.x,
            n[1] = oa.y,
            n[5] = sa.y,
            n[9] = r.y,
            n[2] = oa.z,
            n[6] = sa.z,
            n[10] = r.z,
            this
        }
        ),
        multiply: function(e, t) {
            return void 0 !== t ? (console.warn("THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."),
            this.multiplyMatrices(e, t)) : this.multiplyMatrices(this, e)
        },
        premultiply: function(e) {
            return this.multiplyMatrices(e, this)
        },
        multiplyMatrices: function(e, t) {
            var i = e.elements
              , n = t.elements
              , r = (t = this.elements,
            e = i[0],
            i[4])
              , a = i[8]
              , o = i[12]
              , s = i[1]
              , c = i[5]
              , h = i[9]
              , l = i[13]
              , u = i[2]
              , p = i[6]
              , d = i[10]
              , f = i[14]
              , m = i[3]
              , g = i[7]
              , v = i[11]
              , i = i[15]
              , y = n[0]
              , x = n[4]
              , b = n[8]
              , w = n[12]
              , _ = n[1]
              , M = n[5]
              , E = n[9]
              , S = n[13]
              , T = n[2]
              , A = n[6]
              , L = n[10]
              , P = n[14]
              , R = n[3]
              , C = n[7]
              , O = n[11]
              , n = n[15];
            return t[0] = e * y + r * _ + a * T + o * R,
            t[4] = e * x + r * M + a * A + o * C,
            t[8] = e * b + r * E + a * L + o * O,
            t[12] = e * w + r * S + a * P + o * n,
            t[1] = s * y + c * _ + h * T + l * R,
            t[5] = s * x + c * M + h * A + l * C,
            t[9] = s * b + c * E + h * L + l * O,
            t[13] = s * w + c * S + h * P + l * n,
            t[2] = u * y + p * _ + d * T + f * R,
            t[6] = u * x + p * M + d * A + f * C,
            t[10] = u * b + p * E + d * L + f * O,
            t[14] = u * w + p * S + d * P + f * n,
            t[3] = m * y + g * _ + v * T + i * R,
            t[7] = m * x + g * M + v * A + i * C,
            t[11] = m * b + g * E + v * L + i * O,
            t[15] = m * w + g * S + v * P + i * n,
            this
        },
        multiplyScalar: function(e) {
            var t = this.elements;
            return t[0] *= e,
            t[4] *= e,
            t[8] *= e,
            t[12] *= e,
            t[1] *= e,
            t[5] *= e,
            t[9] *= e,
            t[13] *= e,
            t[2] *= e,
            t[6] *= e,
            t[10] *= e,
            t[14] *= e,
            t[3] *= e,
            t[7] *= e,
            t[11] *= e,
            t[15] *= e,
            this
        },
        applyToBufferAttribute: (aa = new Me,
        function(e) {
            for (var t = 0, i = e.count; t < i; t++)
                aa.x = e.getX(t),
                aa.y = e.getY(t),
                aa.z = e.getZ(t),
                aa.applyMatrix4(this),
                e.setXYZ(t, aa.x, aa.y, aa.z);
            return e
        }
        ),
        determinant: function() {
            var e = this.elements
              , t = e[0]
              , i = e[4]
              , n = e[8]
              , r = e[12]
              , a = e[1]
              , o = e[5]
              , s = e[9]
              , c = e[13]
              , h = e[2]
              , l = e[6]
              , u = e[10]
              , p = e[14];
            return e[3] * (+r * s * l - n * c * l - r * o * u + i * c * u + n * o * p - i * s * p) + e[7] * (+t * s * p - t * c * u + r * a * u - n * a * p + n * c * h - r * s * h) + e[11] * (+t * c * l - t * o * p - r * a * l + i * a * p + r * o * h - i * c * h) + e[15] * (-n * o * h - t * s * l + t * o * u + n * a * l - i * a * u + i * s * h)
        },
        transpose: function() {
            var e = this.elements
              , t = e[1];
            return e[1] = e[4],
            e[4] = t,
            t = e[2],
            e[2] = e[8],
            e[8] = t,
            t = e[6],
            e[6] = e[9],
            e[9] = t,
            t = e[3],
            e[3] = e[12],
            e[12] = t,
            t = e[7],
            e[7] = e[13],
            e[13] = t,
            t = e[11],
            e[11] = e[14],
            e[14] = t,
            this
        },
        setPosition: function(e) {
            var t = this.elements;
            return t[12] = e.x,
            t[13] = e.y,
            t[14] = e.z,
            this
        },
        getInverse: function(e, t) {
            var i = this.elements
              , n = e.elements
              , r = (e = n[0],
            n[1])
              , a = n[2]
              , o = n[3]
              , s = n[4]
              , c = n[5]
              , h = n[6]
              , l = n[7]
              , u = n[8]
              , p = n[9]
              , d = n[10]
              , f = n[11]
              , m = n[12]
              , g = n[13]
              , v = n[14]
              , y = p * v * l - g * d * l + g * h * f - c * v * f - p * h * (n = n[15]) + c * d * n
              , x = m * d * l - u * v * l - m * h * f + s * v * f + u * h * n - s * d * n
              , b = u * g * l - m * p * l + m * c * f - s * g * f - u * c * n + s * p * n
              , w = m * p * h - u * g * h - m * c * d + s * g * d + u * c * v - s * p * v
              , _ = e * y + r * x + a * b + o * w;
            if (0 != _)
                return i[0] = y * (t = 1 / _),
                i[1] = (g * d * o - p * v * o - g * a * f + r * v * f + p * a * n - r * d * n) * t,
                i[2] = (c * v * o - g * h * o + g * a * l - r * v * l - c * a * n + r * h * n) * t,
                i[3] = (p * h * o - c * d * o - p * a * l + r * d * l + c * a * f - r * h * f) * t,
                i[4] = x * t,
                i[5] = (u * v * o - m * d * o + m * a * f - e * v * f - u * a * n + e * d * n) * t,
                i[6] = (m * h * o - s * v * o - m * a * l + e * v * l + s * a * n - e * h * n) * t,
                i[7] = (s * d * o - u * h * o + u * a * l - e * d * l - s * a * f + e * h * f) * t,
                i[8] = b * t,
                i[9] = (m * p * o - u * g * o - m * r * f + e * g * f + u * r * n - e * p * n) * t,
                i[10] = (s * g * o - m * c * o + m * r * l - e * g * l - s * r * n + e * c * n) * t,
                i[11] = (u * c * o - s * p * o - u * r * l + e * p * l + s * r * f - e * c * f) * t,
                i[12] = w * t,
                i[13] = (u * g * a - m * p * a + m * r * d - e * g * d - u * r * v + e * p * v) * t,
                i[14] = (m * c * a - s * g * a - m * r * h + e * g * h + s * r * v - e * c * v) * t,
                i[15] = (s * p * a - u * c * a + u * r * h - e * p * h - s * r * d + e * c * d) * t,
                this;
            if (!0 === t)
                throw Error("THREE.Matrix4: .getInverse() can't invert matrix, determinant is 0");
            return console.warn("THREE.Matrix4: .getInverse() can't invert matrix, determinant is 0"),
            this.identity()
        },
        scale: function(e) {
            var t = this.elements
              , i = e.x
              , n = e.y;
            return e = e.z,
            t[0] *= i,
            t[4] *= n,
            t[8] *= e,
            t[1] *= i,
            t[5] *= n,
            t[9] *= e,
            t[2] *= i,
            t[6] *= n,
            t[10] *= e,
            t[3] *= i,
            t[7] *= n,
            t[11] *= e,
            this
        },
        getMaxScaleOnAxis: function() {
            var e = this.elements;
            return Math.sqrt(Math.max(e[0] * e[0] + e[1] * e[1] + e[2] * e[2], e[4] * e[4] + e[5] * e[5] + e[6] * e[6], e[8] * e[8] + e[9] * e[9] + e[10] * e[10]))
        },
        makeTranslation: function(e, t, i) {
            return this.set(1, 0, 0, e, 0, 1, 0, t, 0, 0, 1, i, 0, 0, 0, 1),
            this
        },
        makeRotationX: function(e) {
            var t = Math.cos(e);
            return e = Math.sin(e),
            this.set(1, 0, 0, 0, 0, t, -e, 0, 0, e, t, 0, 0, 0, 0, 1),
            this
        },
        makeRotationY: function(e) {
            var t = Math.cos(e);
            return e = Math.sin(e),
            this.set(t, 0, e, 0, 0, 1, 0, 0, -e, 0, t, 0, 0, 0, 0, 1),
            this
        },
        makeRotationZ: function(e) {
            var t = Math.cos(e);
            return e = Math.sin(e),
            this.set(t, -e, 0, 0, e, t, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1),
            this
        },
        makeRotationAxis: function(e, t) {
            var i = Math.cos(t)
              , n = (t = Math.sin(t),
            1 - i)
              , r = e.x
              , a = e.y
              , o = (e = e.z,
            n * r)
              , s = n * a;
            return this.set(o * r + i, o * a - t * e, o * e + t * a, 0, o * a + t * e, s * a + i, s * e - t * r, 0, o * e - t * a, s * e + t * r, n * e * e + i, 0, 0, 0, 0, 1),
            this
        },
        makeScale: function(e, t, i) {
            return this.set(e, 0, 0, 0, 0, t, 0, 0, 0, 0, i, 0, 0, 0, 0, 1),
            this
        },
        makeShear: function(e, t, i) {
            return this.set(1, t, i, 0, e, 1, i, 0, e, t, 1, 0, 0, 0, 0, 1),
            this
        },
        compose: function(e, t, i) {
            var n = this.elements
              , r = t._x
              , a = t._y
              , o = t._z
              , s = t._w
              , c = r + r
              , h = a + a
              , l = o + o
              , u = (t = r * c,
            r * h)
              , p = (r *= l,
            a * h)
              , d = (a *= l,
            o *= l,
            c *= s,
            h *= s,
            s *= l,
            l = i.x,
            i.y);
            return i = i.z,
            n[0] = (1 - (p + o)) * l,
            n[1] = (u + s) * l,
            n[2] = (r - h) * l,
            n[3] = 0,
            n[4] = (u - s) * d,
            n[5] = (1 - (t + o)) * d,
            n[6] = (a + c) * d,
            n[7] = 0,
            n[8] = (r + h) * i,
            n[9] = (a - c) * i,
            n[10] = (1 - (t + p)) * i,
            n[11] = 0,
            n[12] = e.x,
            n[13] = e.y,
            n[14] = e.z,
            n[15] = 1,
            this
        },
        decompose: (na = new Me,
        ra = new _e,
        function(e, t, i) {
            var n = this.elements
              , r = na.set(n[0], n[1], n[2]).length()
              , a = na.set(n[4], n[5], n[6]).length()
              , o = na.set(n[8], n[9], n[10]).length()
              , s = (this.determinant() < 0 && (r = -r),
            e.x = n[12],
            e.y = n[13],
            e.z = n[14],
            ra.copy(this),
            n = 1 / a,
            1 / o);
            return ra.elements[0] *= e = 1 / r,
            ra.elements[1] *= e,
            ra.elements[2] *= e,
            ra.elements[4] *= n,
            ra.elements[5] *= n,
            ra.elements[6] *= n,
            ra.elements[8] *= s,
            ra.elements[9] *= s,
            ra.elements[10] *= s,
            t.setFromRotationMatrix(ra),
            i.x = r,
            i.y = a,
            i.z = o,
            this
        }
        ),
        makePerspective: function(e, t, i, n, r, a) {
            void 0 === a && console.warn("THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.");
            var o = this.elements;
            return o[0] = 2 * r / (t - e),
            o[4] = 0,
            o[8] = (t + e) / (t - e),
            o[12] = 0,
            o[1] = 0,
            o[5] = 2 * r / (i - n),
            o[9] = (i + n) / (i - n),
            o[13] = 0,
            o[2] = 0,
            o[6] = 0,
            o[10] = -(a + r) / (a - r),
            o[14] = -2 * a * r / (a - r),
            o[3] = 0,
            o[7] = 0,
            o[11] = -1,
            o[15] = 0,
            this
        },
        makeOrthographic: function(e, t, i, n, r, a) {
            var o = this.elements
              , s = 1 / (t - e)
              , c = 1 / (i - n)
              , h = 1 / (a - r);
            return o[0] = 2 * s,
            o[4] = 0,
            o[8] = 0,
            o[12] = -(t + e) * s,
            o[1] = 0,
            o[5] = 2 * c,
            o[9] = 0,
            o[13] = -(i + n) * c,
            o[2] = 0,
            o[6] = 0,
            o[10] = -2 * h,
            o[14] = -(a + r) * h,
            o[3] = 0,
            o[7] = 0,
            o[11] = 0,
            o[15] = 1,
            this
        },
        equals: function(e) {
            var t = this.elements;
            e = e.elements;
            for (var i = 0; i < 16; i++)
                if (t[i] !== e[i])
                    return !1;
            return !0
        },
        fromArray: function(e, t) {
            void 0 === t && (t = 0);
            for (var i = 0; i < 16; i++)
                this.elements[i] = e[i + t];
            return this
        },
        toArray: function(e, t) {
            var i = this.elements;
            return (e = void 0 === e ? [] : e)[t = void 0 === t ? 0 : t] = i[0],
            e[t + 1] = i[1],
            e[t + 2] = i[2],
            e[t + 3] = i[3],
            e[t + 4] = i[4],
            e[t + 5] = i[5],
            e[t + 6] = i[6],
            e[t + 7] = i[7],
            e[t + 8] = i[8],
            e[t + 9] = i[9],
            e[t + 10] = i[10],
            e[t + 11] = i[11],
            e[t + 12] = i[12],
            e[t + 13] = i[13],
            e[t + 14] = i[14],
            e[t + 15] = i[15],
            e
        }
    }),
    Object.assign(M, {
        slerp: function(e, t, i, n) {
            return i.copy(e).slerp(t, n)
        },
        slerpFlat: function(e, t, i, n, r, a, o) {
            var s, c, h, l = i[n + 0], u = i[n + 1], p = i[n + 2], d = (i = i[n + 3],
            n = r[a + 0],
            r[a + 1]), f = r[a + 2];
            i === (r = r[a + 3]) && l === n && u === d && p === f || (a = 1 - o,
            c = 0 <= (s = l * n + u * d + p * f + i * r) ? 1 : -1,
            (h = 1 - s * s) > Number.EPSILON && (h = Math.sqrt(h),
            s = Math.atan2(h, s * c),
            a = Math.sin(a * s) / h,
            o = Math.sin(o * s) / h),
            l = l * a + n * (c *= o),
            u = u * a + d * c,
            p = p * a + f * c,
            i = i * a + r * c,
            a === 1 - o && (l *= o = 1 / Math.sqrt(l * l + u * u + p * p + i * i),
            u *= o,
            p *= o,
            i *= o)),
            e[t] = l,
            e[t + 1] = u,
            e[t + 2] = p,
            e[t + 3] = i
        }
    }),
    Object.defineProperties(M.prototype, {
        x: {
            get: function() {
                return this._x
            },
            set: function(e) {
                this._x = e,
                this.onChangeCallback()
            }
        },
        y: {
            get: function() {
                return this._y
            },
            set: function(e) {
                this._y = e,
                this.onChangeCallback()
            }
        },
        z: {
            get: function() {
                return this._z
            },
            set: function(e) {
                this._z = e,
                this.onChangeCallback()
            }
        },
        w: {
            get: function() {
                return this._w
            },
            set: function(e) {
                this._w = e,
                this.onChangeCallback()
            }
        }
    }),
    Object.assign(M.prototype, {
        isQuaternion: !0,
        set: function(e, t, i, n) {
            return this._x = e,
            this._y = t,
            this._z = i,
            this._w = n,
            this.onChangeCallback(),
            this
        },
        clone: function() {
            return new this.constructor(this._x,this._y,this._z,this._w)
        },
        copy: function(e) {
            return this._x = e.x,
            this._y = e.y,
            this._z = e.z,
            this._w = e.w,
            this.onChangeCallback(),
            this
        },
        setFromEuler: function(e, t) {
            var i, n, r, a, o, s, c;
            if (e && e.isEuler)
                return o = e._x,
                s = e._y,
                c = e._z,
                e = e.order,
                a = Math.cos,
                i = Math.sin,
                n = a(o / 2),
                r = a(s / 2),
                a = a(c / 2),
                o = i(o / 2),
                s = i(s / 2),
                c = i(c / 2),
                "XYZ" === e ? (this._x = o * r * a + n * s * c,
                this._y = n * s * a - o * r * c,
                this._z = n * r * c + o * s * a,
                this._w = n * r * a - o * s * c) : "YXZ" === e ? (this._x = o * r * a + n * s * c,
                this._y = n * s * a - o * r * c,
                this._z = n * r * c - o * s * a,
                this._w = n * r * a + o * s * c) : "ZXY" === e ? (this._x = o * r * a - n * s * c,
                this._y = n * s * a + o * r * c,
                this._z = n * r * c + o * s * a,
                this._w = n * r * a - o * s * c) : "ZYX" === e ? (this._x = o * r * a - n * s * c,
                this._y = n * s * a + o * r * c,
                this._z = n * r * c - o * s * a,
                this._w = n * r * a + o * s * c) : "YZX" === e ? (this._x = o * r * a + n * s * c,
                this._y = n * s * a + o * r * c,
                this._z = n * r * c - o * s * a,
                this._w = n * r * a - o * s * c) : "XZY" === e && (this._x = o * r * a - n * s * c,
                this._y = n * s * a - o * r * c,
                this._z = n * r * c + o * s * a,
                this._w = n * r * a + o * s * c),
                !1 !== t && this.onChangeCallback(),
                this;
            throw Error("THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.")
        },
        setFromAxisAngle: function(e, t) {
            t /= 2;
            var i = Math.sin(t);
            return this._x = e.x * i,
            this._y = e.y * i,
            this._z = e.z * i,
            this._w = Math.cos(t),
            this.onChangeCallback(),
            this
        },
        setFromRotationMatrix: function(e) {
            var t = e.elements
              , i = t[0]
              , n = (e = t[4],
            t[8])
              , r = t[1]
              , a = t[5]
              , o = t[9]
              , s = t[2]
              , c = t[6]
              , h = i + a + (t = t[10]);
            return 0 < h ? (i = .5 / Math.sqrt(h + 1),
            this._w = .25 / i,
            this._x = (c - o) * i,
            this._y = (n - s) * i,
            this._z = (r - e) * i) : a < i && t < i ? (i = 2 * Math.sqrt(1 + i - a - t),
            this._w = (c - o) / i,
            this._x = .25 * i,
            this._y = (e + r) / i,
            this._z = (n + s) / i) : t < a ? (i = 2 * Math.sqrt(1 + a - i - t),
            this._w = (n - s) / i,
            this._x = (e + r) / i,
            this._y = .25 * i,
            this._z = (o + c) / i) : (i = 2 * Math.sqrt(1 + t - i - a),
            this._w = (r - e) / i,
            this._x = (n + s) / i,
            this._y = (o + c) / i,
            this._z = .25 * i),
            this.onChangeCallback(),
            this
        },
        setFromUnitVectors: (pa = new Me,
        function(e, t) {
            return void 0 === pa && (pa = new Me),
            (ua = e.dot(t) + 1) < 1e-6 ? (ua = 0,
            Math.abs(e.x) > Math.abs(e.z) ? pa.set(-e.y, e.x, 0) : pa.set(0, -e.z, e.y)) : pa.crossVectors(e, t),
            this._x = pa.x,
            this._y = pa.y,
            this._z = pa.z,
            this._w = ua,
            this.normalize()
        }
        ),
        angleTo: function(e) {
            return 2 * Math.acos(Math.abs(Se.clamp(this.dot(e), -1, 1)))
        },
        rotateTowards: function(e, t) {
            var i = this.angleTo(e);
            return 0 !== i && this.slerp(e, Math.min(1, t / i)),
            this
        },
        inverse: function() {
            return this.conjugate()
        },
        conjugate: function() {
            return this._x *= -1,
            this._y *= -1,
            this._z *= -1,
            this.onChangeCallback(),
            this
        },
        dot: function(e) {
            return this._x * e._x + this._y * e._y + this._z * e._z + this._w * e._w
        },
        lengthSq: function() {
            return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w
        },
        length: function() {
            return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w)
        },
        normalize: function() {
            var e = this.length();
            return 0 === e ? (this._z = this._y = this._x = 0,
            this._w = 1) : (this._x *= e = 1 / e,
            this._y *= e,
            this._z *= e,
            this._w *= e),
            this.onChangeCallback(),
            this
        },
        multiply: function(e, t) {
            return void 0 !== t ? (console.warn("THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."),
            this.multiplyQuaternions(e, t)) : this.multiplyQuaternions(this, e)
        },
        premultiply: function(e) {
            return this.multiplyQuaternions(e, this)
        },
        multiplyQuaternions: function(e, t) {
            var i = e._x
              , n = e._y
              , r = e._z
              , a = (e = e._w,
            t._x)
              , o = t._y
              , s = t._z;
            return t = t._w,
            this._x = i * t + e * a + n * s - r * o,
            this._y = n * t + e * o + r * a - i * s,
            this._z = r * t + e * s + i * o - n * a,
            this._w = e * t - i * a - n * o - r * s,
            this.onChangeCallback(),
            this
        },
        slerp: function(e, t) {
            if (0 !== t) {
                if (1 === t)
                    return this.copy(e);
                var i = this._x
                  , n = this._y
                  , r = this._z
                  , a = this._w;
                if ((s = a * e._w + i * e._x + n * e._y + r * e._z) < 0 ? (this._w = -e._w,
                this._x = -e._x,
                this._y = -e._y,
                this._z = -e._z,
                s = -s) : this.copy(e),
                1 <= s)
                    this._w = a,
                    this._x = i,
                    this._y = n,
                    this._z = r;
                else {
                    if ((e = 1 - s * s) <= Number.EPSILON)
                        return this._w = (s = 1 - t) * a + t * this._w,
                        this._x = s * i + t * this._x,
                        this._y = s * n + t * this._y,
                        this._z = s * r + t * this._z,
                        this.normalize();
                    e = Math.sqrt(e);
                    var o = Math.atan2(e, s)
                      , s = Math.sin((1 - t) * o) / e;
                    t = Math.sin(t * o) / e,
                    this._w = a * s + this._w * t,
                    this._x = i * s + this._x * t,
                    this._y = n * s + this._y * t,
                    this._z = r * s + this._z * t,
                    this.onChangeCallback()
                }
            }
            return this
        },
        equals: function(e) {
            return e._x === this._x && e._y === this._y && e._z === this._z && e._w === this._w
        },
        fromArray: function(e, t) {
            return this._x = e[t = void 0 === t ? 0 : t],
            this._y = e[t + 1],
            this._z = e[t + 2],
            this._w = e[t + 3],
            this.onChangeCallback(),
            this
        },
        toArray: function(e, t) {
            return (e = void 0 === e ? [] : e)[t = void 0 === t ? 0 : t] = this._x,
            e[t + 1] = this._y,
            e[t + 2] = this._z,
            e[t + 3] = this._w,
            e
        },
        onChange: function(e) {
            return this.onChangeCallback = e,
            this
        },
        onChangeCallback: function() {}
    }),
    Object.assign(Me.prototype, {
        isVector3: !0,
        set: function(e, t, i) {
            return this.x = e,
            this.y = t,
            this.z = i,
            this
        },
        setScalar: function(e) {
            return this.z = this.y = this.x = e,
            this
        },
        setX: function(e) {
            return this.x = e,
            this
        },
        setY: function(e) {
            return this.y = e,
            this
        },
        setZ: function(e) {
            return this.z = e,
            this
        },
        setComponent: function(e, t) {
            switch (e) {
            case 0:
                this.x = t;
                break;
            case 1:
                this.y = t;
                break;
            case 2:
                this.z = t;
                break;
            default:
                throw Error("index is out of range: " + e)
            }
            return this
        },
        getComponent: function(e) {
            switch (e) {
            case 0:
                return this.x;
            case 1:
                return this.y;
            case 2:
                return this.z;
            default:
                throw Error("index is out of range: " + e)
            }
        },
        clone: function() {
            return new this.constructor(this.x,this.y,this.z)
        },
        copy: function(e) {
            return this.x = e.x,
            this.y = e.y,
            this.z = e.z,
            this
        },
        add: function(e, t) {
            return void 0 !== t ? (console.warn("THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),
            this.addVectors(e, t)) : (this.x += e.x,
            this.y += e.y,
            this.z += e.z,
            this)
        },
        addScalar: function(e) {
            return this.x += e,
            this.y += e,
            this.z += e,
            this
        },
        addVectors: function(e, t) {
            return this.x = e.x + t.x,
            this.y = e.y + t.y,
            this.z = e.z + t.z,
            this
        },
        addScaledVector: function(e, t) {
            return this.x += e.x * t,
            this.y += e.y * t,
            this.z += e.z * t,
            this
        },
        sub: function(e, t) {
            return void 0 !== t ? (console.warn("THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),
            this.subVectors(e, t)) : (this.x -= e.x,
            this.y -= e.y,
            this.z -= e.z,
            this)
        },
        subScalar: function(e) {
            return this.x -= e,
            this.y -= e,
            this.z -= e,
            this
        },
        subVectors: function(e, t) {
            return this.x = e.x - t.x,
            this.y = e.y - t.y,
            this.z = e.z - t.z,
            this
        },
        multiply: function(e, t) {
            return void 0 !== t ? (console.warn("THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."),
            this.multiplyVectors(e, t)) : (this.x *= e.x,
            this.y *= e.y,
            this.z *= e.z,
            this)
        },
        multiplyScalar: function(e) {
            return this.x *= e,
            this.y *= e,
            this.z *= e,
            this
        },
        multiplyVectors: function(e, t) {
            return this.x = e.x * t.x,
            this.y = e.y * t.y,
            this.z = e.z * t.z,
            this
        },
        applyEuler: (xa = new M,
        function(e) {
            return e && e.isEuler || console.error("THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order."),
            this.applyQuaternion(xa.setFromEuler(e))
        }
        ),
        applyAxisAngle: (ya = new M,
        function(e, t) {
            return this.applyQuaternion(ya.setFromAxisAngle(e, t))
        }
        ),
        applyMatrix3: function(e) {
            var t = this.x
              , i = this.y
              , n = this.z;
            return e = e.elements,
            this.x = e[0] * t + e[3] * i + e[6] * n,
            this.y = e[1] * t + e[4] * i + e[7] * n,
            this.z = e[2] * t + e[5] * i + e[8] * n,
            this
        },
        applyMatrix4: function(e) {
            var t = this.x
              , i = this.y
              , n = this.z
              , r = 1 / ((e = e.elements)[3] * t + e[7] * i + e[11] * n + e[15]);
            return this.x = (e[0] * t + e[4] * i + e[8] * n + e[12]) * r,
            this.y = (e[1] * t + e[5] * i + e[9] * n + e[13]) * r,
            this.z = (e[2] * t + e[6] * i + e[10] * n + e[14]) * r,
            this
        },
        applyQuaternion: function(e) {
            var t = this.x
              , i = this.y
              , n = this.z
              , r = e.x
              , a = e.y
              , o = e.z
              , s = (e = e.w) * t + a * n - o * i
              , c = e * i + o * t - r * n
              , h = e * n + r * i - a * t;
            return this.x = s * e + (t = -r * t - a * i - o * n) * -r + c * -o - h * -a,
            this.y = c * e + t * -a + h * -r - s * -o,
            this.z = h * e + t * -o + s * -a - c * -r,
            this
        },
        project: function(e) {
            return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(e.projectionMatrix)
        },
        unproject: (va = new _e,
        function(e) {
            return this.applyMatrix4(va.getInverse(e.projectionMatrix)).applyMatrix4(e.matrixWorld)
        }
        ),
        transformDirection: function(e) {
            var t = this.x
              , i = this.y
              , n = this.z;
            return e = e.elements,
            this.x = e[0] * t + e[4] * i + e[8] * n,
            this.y = e[1] * t + e[5] * i + e[9] * n,
            this.z = e[2] * t + e[6] * i + e[10] * n,
            this.normalize()
        },
        divide: function(e) {
            return this.x /= e.x,
            this.y /= e.y,
            this.z /= e.z,
            this
        },
        divideScalar: function(e) {
            return this.multiplyScalar(1 / e)
        },
        min: function(e) {
            return this.x = Math.min(this.x, e.x),
            this.y = Math.min(this.y, e.y),
            this.z = Math.min(this.z, e.z),
            this
        },
        max: function(e) {
            return this.x = Math.max(this.x, e.x),
            this.y = Math.max(this.y, e.y),
            this.z = Math.max(this.z, e.z),
            this
        },
        clamp: function(e, t) {
            return this.x = Math.max(e.x, Math.min(t.x, this.x)),
            this.y = Math.max(e.y, Math.min(t.y, this.y)),
            this.z = Math.max(e.z, Math.min(t.z, this.z)),
            this
        },
        clampScalar: (ma = new Me,
        ga = new Me,
        function(e, t) {
            return ma.set(e, e, e),
            ga.set(t, t, t),
            this.clamp(ma, ga)
        }
        ),
        clampLength: function(e, t) {
            var i = this.length();
            return this.divideScalar(i || 1).multiplyScalar(Math.max(e, Math.min(t, i)))
        },
        floor: function() {
            return this.x = Math.floor(this.x),
            this.y = Math.floor(this.y),
            this.z = Math.floor(this.z),
            this
        },
        ceil: function() {
            return this.x = Math.ceil(this.x),
            this.y = Math.ceil(this.y),
            this.z = Math.ceil(this.z),
            this
        },
        round: function() {
            return this.x = Math.round(this.x),
            this.y = Math.round(this.y),
            this.z = Math.round(this.z),
            this
        },
        roundToZero: function() {
            return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x),
            this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y),
            this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z),
            this
        },
        negate: function() {
            return this.x = -this.x,
            this.y = -this.y,
            this.z = -this.z,
            this
        },
        dot: function(e) {
            return this.x * e.x + this.y * e.y + this.z * e.z
        },
        lengthSq: function() {
            return this.x * this.x + this.y * this.y + this.z * this.z
        },
        length: function() {
            return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z)
        },
        manhattanLength: function() {
            return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z)
        },
        normalize: function() {
            return this.divideScalar(this.length() || 1)
        },
        setLength: function(e) {
            return this.normalize().multiplyScalar(e)
        },
        lerp: function(e, t) {
            return this.x += (e.x - this.x) * t,
            this.y += (e.y - this.y) * t,
            this.z += (e.z - this.z) * t,
            this
        },
        lerpVectors: function(e, t, i) {
            return this.subVectors(t, e).multiplyScalar(i).add(e)
        },
        cross: function(e, t) {
            return void 0 !== t ? (console.warn("THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."),
            this.crossVectors(e, t)) : this.crossVectors(this, e)
        },
        crossVectors: function(e, t) {
            var i = e.x
              , n = e.y
              , r = (e = e.z,
            t.x)
              , a = t.y;
            return t = t.z,
            this.x = n * t - e * a,
            this.y = e * r - i * t,
            this.z = i * a - n * r,
            this
        },
        projectOnVector: function(e) {
            var t = e.dot(this) / e.lengthSq();
            return this.copy(e).multiplyScalar(t)
        },
        projectOnPlane: (fa = new Me,
        function(e) {
            return fa.copy(this).projectOnVector(e),
            this.sub(fa)
        }
        ),
        reflect: (da = new Me,
        function(e) {
            return this.sub(da.copy(e).multiplyScalar(2 * this.dot(e)))
        }
        ),
        angleTo: function(e) {
            return e = this.dot(e) / Math.sqrt(this.lengthSq() * e.lengthSq()),
            Math.acos(Se.clamp(e, -1, 1))
        },
        distanceTo: function(e) {
            return Math.sqrt(this.distanceToSquared(e))
        },
        distanceToSquared: function(e) {
            var t = this.x - e.x
              , i = this.y - e.y;
            return t * t + i * i + (e = this.z - e.z) * e
        },
        manhattanDistanceTo: function(e) {
            return Math.abs(this.x - e.x) + Math.abs(this.y - e.y) + Math.abs(this.z - e.z)
        },
        setFromSpherical: function(e) {
            return this.setFromSphericalCoords(e.radius, e.phi, e.theta)
        },
        setFromSphericalCoords: function(e, t, i) {
            var n = Math.sin(t) * e;
            return this.x = n * Math.sin(i),
            this.y = Math.cos(t) * e,
            this.z = n * Math.cos(i),
            this
        },
        setFromCylindrical: function(e) {
            return this.setFromCylindricalCoords(e.radius, e.theta, e.y)
        },
        setFromCylindricalCoords: function(e, t, i) {
            return this.x = e * Math.sin(t),
            this.y = i,
            this.z = e * Math.cos(t),
            this
        },
        setFromMatrixPosition: function(e) {
            return e = e.elements,
            this.x = e[12],
            this.y = e[13],
            this.z = e[14],
            this
        },
        setFromMatrixScale: function(e) {
            var t = this.setFromMatrixColumn(e, 0).length()
              , i = this.setFromMatrixColumn(e, 1).length();
            return e = this.setFromMatrixColumn(e, 2).length(),
            this.x = t,
            this.y = i,
            this.z = e,
            this
        },
        setFromMatrixColumn: function(e, t) {
            return this.fromArray(e.elements, 4 * t)
        },
        equals: function(e) {
            return e.x === this.x && e.y === this.y && e.z === this.z
        },
        fromArray: function(e, t) {
            return this.x = e[t = void 0 === t ? 0 : t],
            this.y = e[t + 1],
            this.z = e[t + 2],
            this
        },
        toArray: function(e, t) {
            return (e = void 0 === e ? [] : e)[t = void 0 === t ? 0 : t] = this.x,
            e[t + 1] = this.y,
            e[t + 2] = this.z,
            e
        },
        fromBufferAttribute: function(e, t, i) {
            return void 0 !== i && console.warn("THREE.Vector3: offset has been removed from .fromBufferAttribute()."),
            this.x = e.getX(t),
            this.y = e.getY(t),
            this.z = e.getZ(t),
            this
        }
    }),
    Object.assign(g.prototype, {
        isMatrix3: !0,
        set: function(e, t, i, n, r, a, o, s, c) {
            var h = this.elements;
            return h[0] = e,
            h[1] = n,
            h[2] = o,
            h[3] = t,
            h[4] = r,
            h[5] = s,
            h[6] = i,
            h[7] = a,
            h[8] = c,
            this
        },
        identity: function() {
            return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1),
            this
        },
        clone: function() {
            return (new this.constructor).fromArray(this.elements)
        },
        copy: function(e) {
            var t = this.elements;
            return e = e.elements,
            t[0] = e[0],
            t[1] = e[1],
            t[2] = e[2],
            t[3] = e[3],
            t[4] = e[4],
            t[5] = e[5],
            t[6] = e[6],
            t[7] = e[7],
            t[8] = e[8],
            this
        },
        setFromMatrix4: function(e) {
            return e = e.elements,
            this.set(e[0], e[4], e[8], e[1], e[5], e[9], e[2], e[6], e[10]),
            this
        },
        applyToBufferAttribute: (ba = new Me,
        function(e) {
            for (var t = 0, i = e.count; t < i; t++)
                ba.x = e.getX(t),
                ba.y = e.getY(t),
                ba.z = e.getZ(t),
                ba.applyMatrix3(this),
                e.setXYZ(t, ba.x, ba.y, ba.z);
            return e
        }
        ),
        multiply: function(e) {
            return this.multiplyMatrices(this, e)
        },
        premultiply: function(e) {
            return this.multiplyMatrices(e, this)
        },
        multiplyMatrices: function(e, t) {
            var i = e.elements
              , n = t.elements
              , r = (t = this.elements,
            e = i[0],
            i[3])
              , a = i[6]
              , o = i[1]
              , s = i[4]
              , c = i[7]
              , h = i[2]
              , l = i[5]
              , i = i[8]
              , u = n[0]
              , p = n[3]
              , d = n[6]
              , f = n[1]
              , m = n[4]
              , g = n[7]
              , v = n[2]
              , y = n[5]
              , n = n[8];
            return t[0] = e * u + r * f + a * v,
            t[3] = e * p + r * m + a * y,
            t[6] = e * d + r * g + a * n,
            t[1] = o * u + s * f + c * v,
            t[4] = o * p + s * m + c * y,
            t[7] = o * d + s * g + c * n,
            t[2] = h * u + l * f + i * v,
            t[5] = h * p + l * m + i * y,
            t[8] = h * d + l * g + i * n,
            this
        },
        multiplyScalar: function(e) {
            var t = this.elements;
            return t[0] *= e,
            t[3] *= e,
            t[6] *= e,
            t[1] *= e,
            t[4] *= e,
            t[7] *= e,
            t[2] *= e,
            t[5] *= e,
            t[8] *= e,
            this
        },
        determinant: function() {
            var e = this.elements
              , t = e[0]
              , i = e[1]
              , n = e[2]
              , r = e[3]
              , a = e[4]
              , o = e[5]
              , s = e[6]
              , c = e[7];
            return t * a * (e = e[8]) - t * o * c - i * r * e + i * o * s + n * r * c - n * a * s
        },
        getInverse: function(e, t) {
            e && e.isMatrix4 && console.error("THREE.Matrix3: .getInverse() no longer takes a Matrix4 argument.");
            var i = e.elements
              , n = (e = this.elements,
            i[0])
              , r = i[1]
              , a = i[2]
              , o = i[3]
              , s = i[4]
              , c = i[5]
              , h = i[6]
              , l = i[7]
              , u = (i = i[8]) * s - c * l
              , p = c * h - i * o
              , d = l * o - s * h
              , f = n * u + r * p + a * d;
            if (0 != f)
                return e[0] = u * (t = 1 / f),
                e[1] = (a * l - i * r) * t,
                e[2] = (c * r - a * s) * t,
                e[3] = p * t,
                e[4] = (i * n - a * h) * t,
                e[5] = (a * o - c * n) * t,
                e[6] = d * t,
                e[7] = (r * h - l * n) * t,
                e[8] = (s * n - r * o) * t,
                this;
            if (!0 === t)
                throw Error("THREE.Matrix3: .getInverse() can't invert matrix, determinant is 0");
            return console.warn("THREE.Matrix3: .getInverse() can't invert matrix, determinant is 0"),
            this.identity()
        },
        transpose: function() {
            var e = this.elements
              , t = e[1];
            return e[1] = e[3],
            e[3] = t,
            t = e[2],
            e[2] = e[6],
            e[6] = t,
            t = e[5],
            e[5] = e[7],
            e[7] = t,
            this
        },
        getNormalMatrix: function(e) {
            return this.setFromMatrix4(e).getInverse(this).transpose()
        },
        transposeIntoArray: function(e) {
            var t = this.elements;
            return e[0] = t[0],
            e[1] = t[3],
            e[2] = t[6],
            e[3] = t[1],
            e[4] = t[4],
            e[5] = t[7],
            e[6] = t[2],
            e[7] = t[5],
            e[8] = t[8],
            this
        },
        setUvTransform: function(e, t, i, n, r, a, o) {
            var s = Math.cos(r);
            r = Math.sin(r),
            this.set(i * s, i * r, -i * (s * a + r * o) + a + e, -n * r, n * s, -n * (-r * a + s * o) + o + t, 0, 0, 1)
        },
        scale: function(e, t) {
            var i = this.elements;
            return i[0] *= e,
            i[3] *= e,
            i[6] *= e,
            i[1] *= t,
            i[4] *= t,
            i[7] *= t,
            this
        },
        rotate: function(e) {
            var t = Math.cos(e)
              , i = (e = Math.sin(e),
            this.elements)
              , n = i[0]
              , r = i[3]
              , a = i[6]
              , o = i[1]
              , s = i[4]
              , c = i[7];
            return i[0] = t * n + e * o,
            i[3] = t * r + e * s,
            i[6] = t * a + e * c,
            i[1] = -e * n + t * o,
            i[4] = -e * r + t * s,
            i[7] = -e * a + t * c,
            this
        },
        translate: function(e, t) {
            var i = this.elements;
            return i[0] += e * i[2],
            i[3] += e * i[5],
            i[6] += e * i[8],
            i[1] += t * i[2],
            i[4] += t * i[5],
            i[7] += t * i[8],
            this
        },
        equals: function(e) {
            var t = this.elements;
            e = e.elements;
            for (var i = 0; i < 9; i++)
                if (t[i] !== e[i])
                    return !1;
            return !0
        },
        fromArray: function(e, t) {
            void 0 === t && (t = 0);
            for (var i = 0; i < 9; i++)
                this.elements[i] = e[i + t];
            return this
        },
        toArray: function(e, t) {
            var i = this.elements;
            return (e = void 0 === e ? [] : e)[t = void 0 === t ? 0 : t] = i[0],
            e[t + 1] = i[1],
            e[t + 2] = i[2],
            e[t + 3] = i[3],
            e[t + 4] = i[4],
            e[t + 5] = i[5],
            e[t + 6] = i[6],
            e[t + 7] = i[7],
            e[t + 8] = i[8],
            e
        }
    });
    var wa, _a, Ma, Ea, Sa, Ta, Aa, La, Pa, Ra, Ca, Oa, Ia, Da, Ba, Na, za, Ua, Ga, Fa, Ha, ka, Va, ja, Wa, qa, Xa, Ya, Ja, Za, Qa, Ka = {
        getDataURL: function(e) {
            var t;
            return "undefined" == typeof HTMLCanvasElement ? e.src : (e instanceof HTMLCanvasElement || ((wa = void 0 === wa ? document.createElementNS("http://www.w3.org/1999/xhtml", "canvas") : wa).width = e.width,
            wa.height = e.height,
            t = wa.getContext("2d"),
            e instanceof ImageData ? t.putImageData(e, 0, 0) : t.drawImage(e, 0, 0, e.width, e.height),
            e = wa),
            2048 < e.width || 2048 < e.height ? e.toDataURL("image/jpeg", .6) : e.toDataURL("image/png"))
        }
    }, $a = 0;
    function eo(e) {
        for (var t = 0, i = e.length - 3; t <= i; t += 3) {
            Ia.fromArray(e, t);
            var n = Ba.x * Math.abs(Ia.x) + Ba.y * Math.abs(Ia.y) + Ba.z * Math.abs(Ia.z)
              , r = Aa.dot(Ia)
              , a = La.dot(Ia)
              , o = Pa.dot(Ia);
            if (Math.max(-Math.max(r, a, o), Math.min(r, a, o)) > n)
                return !1
        }
        return !0
    }
    function to(e) {
        var t = e.geometry;
        if (void 0 !== t)
            if (t.isGeometry)
                for (t = t.vertices,
                Ga = 0,
                Fa = t.length; Ga < Fa; Ga++)
                    Ha.copy(t[Ga]),
                    Ha.applyMatrix4(e.matrixWorld),
                    Ua.expandByPoint(Ha);
            else if (t.isBufferGeometry && void 0 !== (t = t.attributes.position))
                for (Ga = 0,
                Fa = t.count; Ga < Fa; Ga++)
                    Ha.fromBufferAttribute(t, Ga).applyMatrix4(e.matrixWorld),
                    Ua.expandByPoint(Ha)
    }
    p.DEFAULT_IMAGE = void 0,
    p.DEFAULT_MAPPING = 300,
    p.prototype = Object.assign(Object.create(L.prototype), {
        constructor: p,
        isTexture: !0,
        updateMatrix: function() {
            this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y)
        },
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(e) {
            return this.name = e.name,
            this.image = e.image,
            this.mipmaps = e.mipmaps.slice(0),
            this.mapping = e.mapping,
            this.wrapS = e.wrapS,
            this.wrapT = e.wrapT,
            this.magFilter = e.magFilter,
            this.minFilter = e.minFilter,
            this.anisotropy = e.anisotropy,
            this.format = e.format,
            this.type = e.type,
            this.offset.copy(e.offset),
            this.repeat.copy(e.repeat),
            this.center.copy(e.center),
            this.rotation = e.rotation,
            this.matrixAutoUpdate = e.matrixAutoUpdate,
            this.matrix.copy(e.matrix),
            this.generateMipmaps = e.generateMipmaps,
            this.premultiplyAlpha = e.premultiplyAlpha,
            this.flipY = e.flipY,
            this.unpackAlignment = e.unpackAlignment,
            this.encoding = e.encoding,
            this
        },
        toJSON: function(e) {
            var t = void 0 === e || "string" == typeof e;
            if (!t && void 0 !== e.textures[this.uuid])
                return e.textures[this.uuid];
            var i = {
                metadata: {
                    version: 4.5,
                    type: "Texture",
                    generator: "Texture.toJSON"
                },
                uuid: this.uuid,
                name: this.name,
                mapping: this.mapping,
                repeat: [this.repeat.x, this.repeat.y],
                offset: [this.offset.x, this.offset.y],
                center: [this.center.x, this.center.y],
                rotation: this.rotation,
                wrap: [this.wrapS, this.wrapT],
                format: this.format,
                type: this.type,
                encoding: this.encoding,
                minFilter: this.minFilter,
                magFilter: this.magFilter,
                anisotropy: this.anisotropy,
                flipY: this.flipY,
                premultiplyAlpha: this.premultiplyAlpha,
                unpackAlignment: this.unpackAlignment
            };
            if (void 0 !== this.image) {
                var n = this.image;
                if (void 0 === n.uuid && (n.uuid = Se.generateUUID()),
                !t && void 0 === e.images[n.uuid]) {
                    if (Array.isArray(n))
                        for (var r = [], a = 0, o = n.length; a < o; a++)
                            r.push(Ka.getDataURL(n[a]));
                    else
                        r = Ka.getDataURL(n);
                    e.images[n.uuid] = {
                        uuid: n.uuid,
                        url: r
                    }
                }
                i.image = n.uuid
            }
            return t || (e.textures[this.uuid] = i),
            i
        },
        dispose: function() {
            this.dispatchEvent({
                type: "dispose"
            })
        },
        transformUv: function(e) {
            if (300 === this.mapping) {
                if (e.applyMatrix3(this.matrix),
                e.x < 0 || 1 < e.x)
                    switch (this.wrapS) {
                    case 1e3:
                        e.x -= Math.floor(e.x);
                        break;
                    case 1001:
                        e.x = e.x < 0 ? 0 : 1;
                        break;
                    case 1002:
                        e.x = 1 === Math.abs(Math.floor(e.x) % 2) ? Math.ceil(e.x) - e.x : e.x - Math.floor(e.x)
                    }
                if (e.y < 0 || 1 < e.y)
                    switch (this.wrapT) {
                    case 1e3:
                        e.y -= Math.floor(e.y);
                        break;
                    case 1001:
                        e.y = e.y < 0 ? 0 : 1;
                        break;
                    case 1002:
                        e.y = 1 === Math.abs(Math.floor(e.y) % 2) ? Math.ceil(e.y) - e.y : e.y - Math.floor(e.y)
                    }
                this.flipY && (e.y = 1 - e.y)
            }
            return e
        }
    }),
    Object.defineProperty(p.prototype, "needsUpdate", {
        set: function(e) {
            !0 === e && this.version++
        }
    }),
    Object.assign(Ee.prototype, {
        isVector4: !0,
        set: function(e, t, i, n) {
            return this.x = e,
            this.y = t,
            this.z = i,
            this.w = n,
            this
        },
        setScalar: function(e) {
            return this.w = this.z = this.y = this.x = e,
            this
        },
        setX: function(e) {
            return this.x = e,
            this
        },
        setY: function(e) {
            return this.y = e,
            this
        },
        setZ: function(e) {
            return this.z = e,
            this
        },
        setW: function(e) {
            return this.w = e,
            this
        },
        setComponent: function(e, t) {
            switch (e) {
            case 0:
                this.x = t;
                break;
            case 1:
                this.y = t;
                break;
            case 2:
                this.z = t;
                break;
            case 3:
                this.w = t;
                break;
            default:
                throw Error("index is out of range: " + e)
            }
            return this
        },
        getComponent: function(e) {
            switch (e) {
            case 0:
                return this.x;
            case 1:
                return this.y;
            case 2:
                return this.z;
            case 3:
                return this.w;
            default:
                throw Error("index is out of range: " + e)
            }
        },
        clone: function() {
            return new this.constructor(this.x,this.y,this.z,this.w)
        },
        copy: function(e) {
            return this.x = e.x,
            this.y = e.y,
            this.z = e.z,
            this.w = void 0 !== e.w ? e.w : 1,
            this
        },
        add: function(e, t) {
            return void 0 !== t ? (console.warn("THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),
            this.addVectors(e, t)) : (this.x += e.x,
            this.y += e.y,
            this.z += e.z,
            this.w += e.w,
            this)
        },
        addScalar: function(e) {
            return this.x += e,
            this.y += e,
            this.z += e,
            this.w += e,
            this
        },
        addVectors: function(e, t) {
            return this.x = e.x + t.x,
            this.y = e.y + t.y,
            this.z = e.z + t.z,
            this.w = e.w + t.w,
            this
        },
        addScaledVector: function(e, t) {
            return this.x += e.x * t,
            this.y += e.y * t,
            this.z += e.z * t,
            this.w += e.w * t,
            this
        },
        sub: function(e, t) {
            return void 0 !== t ? (console.warn("THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),
            this.subVectors(e, t)) : (this.x -= e.x,
            this.y -= e.y,
            this.z -= e.z,
            this.w -= e.w,
            this)
        },
        subScalar: function(e) {
            return this.x -= e,
            this.y -= e,
            this.z -= e,
            this.w -= e,
            this
        },
        subVectors: function(e, t) {
            return this.x = e.x - t.x,
            this.y = e.y - t.y,
            this.z = e.z - t.z,
            this.w = e.w - t.w,
            this
        },
        multiplyScalar: function(e) {
            return this.x *= e,
            this.y *= e,
            this.z *= e,
            this.w *= e,
            this
        },
        applyMatrix4: function(e) {
            var t = this.x
              , i = this.y
              , n = this.z
              , r = this.w;
            return e = e.elements,
            this.x = e[0] * t + e[4] * i + e[8] * n + e[12] * r,
            this.y = e[1] * t + e[5] * i + e[9] * n + e[13] * r,
            this.z = e[2] * t + e[6] * i + e[10] * n + e[14] * r,
            this.w = e[3] * t + e[7] * i + e[11] * n + e[15] * r,
            this
        },
        divideScalar: function(e) {
            return this.multiplyScalar(1 / e)
        },
        setAxisAngleFromQuaternion: function(e) {
            this.w = 2 * Math.acos(e.w);
            var t = Math.sqrt(1 - e.w * e.w);
            return t < 1e-4 ? (this.x = 1,
            this.z = this.y = 0) : (this.x = e.x / t,
            this.y = e.y / t,
            this.z = e.z / t),
            this
        },
        setAxisAngleFromRotationMatrix: function(e) {
            var t = (e = e.elements)[0]
              , i = e[4]
              , n = e[8]
              , r = e[1]
              , a = e[5]
              , o = e[9]
              , s = e[2]
              , c = e[6]
              , h = e[10];
            return Math.abs(i - r) < .01 && Math.abs(n - s) < .01 && Math.abs(o - c) < .01 ? Math.abs(i + r) < .1 && Math.abs(n + s) < .1 && Math.abs(o + c) < .1 && Math.abs(t + a + h - 3) < .1 ? this.set(1, 0, 0, 0) : (e = Math.PI,
            h = (h + 1) / 2,
            i = (i + r) / 4,
            n = (n + s) / 4,
            o = (o + c) / 4,
            (a = (a + 1) / 2) < (t = (t + 1) / 2) && h < t ? i = t < .01 ? (c = 0,
            s = .707106781) : (s = i / (c = Math.sqrt(t)),
            n / c) : h < a ? i = a < .01 ? (s = 0,
            c = .707106781) : (c = i / (s = Math.sqrt(a)),
            o / s) : h < .01 ? (s = c = .707106781,
            i = 0) : (c = n / (i = Math.sqrt(h)),
            s = o / i),
            this.set(c, s, i, e)) : (e = Math.sqrt((c - o) * (c - o) + (n - s) * (n - s) + (r - i) * (r - i)),
            Math.abs(e) < .001 && (e = 1),
            this.x = (c - o) / e,
            this.y = (n - s) / e,
            this.z = (r - i) / e,
            this.w = Math.acos((t + a + h - 1) / 2)),
            this
        },
        min: function(e) {
            return this.x = Math.min(this.x, e.x),
            this.y = Math.min(this.y, e.y),
            this.z = Math.min(this.z, e.z),
            this.w = Math.min(this.w, e.w),
            this
        },
        max: function(e) {
            return this.x = Math.max(this.x, e.x),
            this.y = Math.max(this.y, e.y),
            this.z = Math.max(this.z, e.z),
            this.w = Math.max(this.w, e.w),
            this
        },
        clamp: function(e, t) {
            return this.x = Math.max(e.x, Math.min(t.x, this.x)),
            this.y = Math.max(e.y, Math.min(t.y, this.y)),
            this.z = Math.max(e.z, Math.min(t.z, this.z)),
            this.w = Math.max(e.w, Math.min(t.w, this.w)),
            this
        },
        clampScalar: function(e, t) {
            return void 0 === _a && (_a = new Ee,
            Ma = new Ee),
            _a.set(e, e, e, e),
            Ma.set(t, t, t, t),
            this.clamp(_a, Ma)
        },
        clampLength: function(e, t) {
            var i = this.length();
            return this.divideScalar(i || 1).multiplyScalar(Math.max(e, Math.min(t, i)))
        },
        floor: function() {
            return this.x = Math.floor(this.x),
            this.y = Math.floor(this.y),
            this.z = Math.floor(this.z),
            this.w = Math.floor(this.w),
            this
        },
        ceil: function() {
            return this.x = Math.ceil(this.x),
            this.y = Math.ceil(this.y),
            this.z = Math.ceil(this.z),
            this.w = Math.ceil(this.w),
            this
        },
        round: function() {
            return this.x = Math.round(this.x),
            this.y = Math.round(this.y),
            this.z = Math.round(this.z),
            this.w = Math.round(this.w),
            this
        },
        roundToZero: function() {
            return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x),
            this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y),
            this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z),
            this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w),
            this
        },
        negate: function() {
            return this.x = -this.x,
            this.y = -this.y,
            this.z = -this.z,
            this.w = -this.w,
            this
        },
        dot: function(e) {
            return this.x * e.x + this.y * e.y + this.z * e.z + this.w * e.w
        },
        lengthSq: function() {
            return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
        },
        length: function() {
            return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w)
        },
        manhattanLength: function() {
            return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w)
        },
        normalize: function() {
            return this.divideScalar(this.length() || 1)
        },
        setLength: function(e) {
            return this.normalize().multiplyScalar(e)
        },
        lerp: function(e, t) {
            return this.x += (e.x - this.x) * t,
            this.y += (e.y - this.y) * t,
            this.z += (e.z - this.z) * t,
            this.w += (e.w - this.w) * t,
            this
        },
        lerpVectors: function(e, t, i) {
            return this.subVectors(t, e).multiplyScalar(i).add(e)
        },
        equals: function(e) {
            return e.x === this.x && e.y === this.y && e.z === this.z && e.w === this.w
        },
        fromArray: function(e, t) {
            return this.x = e[t = void 0 === t ? 0 : t],
            this.y = e[t + 1],
            this.z = e[t + 2],
            this.w = e[t + 3],
            this
        },
        toArray: function(e, t) {
            return (e = void 0 === e ? [] : e)[t = void 0 === t ? 0 : t] = this.x,
            e[t + 1] = this.y,
            e[t + 2] = this.z,
            e[t + 3] = this.w,
            e
        },
        fromBufferAttribute: function(e, t, i) {
            return void 0 !== i && console.warn("THREE.Vector4: offset has been removed from .fromBufferAttribute()."),
            this.x = e.getX(t),
            this.y = e.getY(t),
            this.z = e.getZ(t),
            this.w = e.getW(t),
            this
        }
    }),
    P.prototype = Object.assign(Object.create(L.prototype), {
        constructor: P,
        isWebGLRenderTarget: !0,
        setSize: function(e, t) {
            this.width === e && this.height === t || (this.width = e,
            this.height = t,
            this.dispose()),
            this.viewport.set(0, 0, e, t),
            this.scissor.set(0, 0, e, t)
        },
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(e) {
            return this.width = e.width,
            this.height = e.height,
            this.viewport.copy(e.viewport),
            this.texture = e.texture.clone(),
            this.depthBuffer = e.depthBuffer,
            this.stencilBuffer = e.stencilBuffer,
            this.depthTexture = e.depthTexture,
            this
        },
        dispose: function() {
            this.dispatchEvent({
                type: "dispose"
            })
        }
    }),
    R.prototype = Object.assign(Object.create(P.prototype), {
        constructor: R,
        isWebGLMultisampleRenderTarget: !0,
        copy: function(e) {
            return P.prototype.copy.call(this, e),
            this.samples = e.samples,
            this
        }
    }),
    ((C.prototype = Object.create(P.prototype)).constructor = C).prototype.isWebGLRenderTargetCube = !0,
    ((Ae.prototype = Object.create(p.prototype)).constructor = Ae).prototype.isDataTexture = !0,
    Object.assign(O.prototype, {
        isBox3: !0,
        set: function(e, t) {
            return this.min.copy(e),
            this.max.copy(t),
            this
        },
        setFromArray: function(e) {
            for (var t = 1 / 0, i = 1 / 0, n = 1 / 0, r = -1 / 0, a = -1 / 0, o = -1 / 0, s = 0, c = e.length; s < c; s += 3) {
                var h = e[s]
                  , l = e[s + 1]
                  , u = e[s + 2];
                h < t && (t = h),
                l < i && (i = l),
                u < n && (n = u),
                r < h && (r = h),
                a < l && (a = l),
                o < u && (o = u)
            }
            return this.min.set(t, i, n),
            this.max.set(r, a, o),
            this
        },
        setFromBufferAttribute: function(e) {
            for (var t = 1 / 0, i = 1 / 0, n = 1 / 0, r = -1 / 0, a = -1 / 0, o = -1 / 0, s = 0, c = e.count; s < c; s++) {
                var h = e.getX(s)
                  , l = e.getY(s)
                  , u = e.getZ(s);
                h < t && (t = h),
                l < i && (i = l),
                u < n && (n = u),
                r < h && (r = h),
                a < l && (a = l),
                o < u && (o = u)
            }
            return this.min.set(t, i, n),
            this.max.set(r, a, o),
            this
        },
        setFromPoints: function(e) {
            this.makeEmpty();
            for (var t = 0, i = e.length; t < i; t++)
                this.expandByPoint(e[t]);
            return this
        },
        setFromCenterAndSize: (ka = new Me,
        function(e, t) {
            return t = ka.copy(t).multiplyScalar(.5),
            this.min.copy(e).sub(t),
            this.max.copy(e).add(t),
            this
        }
        ),
        setFromObject: function(e) {
            return this.makeEmpty(),
            this.expandByObject(e)
        },
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(e) {
            return this.min.copy(e.min),
            this.max.copy(e.max),
            this
        },
        makeEmpty: function() {
            return this.min.x = this.min.y = this.min.z = 1 / 0,
            this.max.x = this.max.y = this.max.z = -1 / 0,
            this
        },
        isEmpty: function() {
            return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z
        },
        getCenter: function(e) {
            return void 0 === e && (console.warn("THREE.Box3: .getCenter() target is now required"),
            e = new Me),
            this.isEmpty() ? e.set(0, 0, 0) : e.addVectors(this.min, this.max).multiplyScalar(.5)
        },
        getSize: function(e) {
            return void 0 === e && (console.warn("THREE.Box3: .getSize() target is now required"),
            e = new Me),
            this.isEmpty() ? e.set(0, 0, 0) : e.subVectors(this.max, this.min)
        },
        expandByPoint: function(e) {
            return this.min.min(e),
            this.max.max(e),
            this
        },
        expandByVector: function(e) {
            return this.min.sub(e),
            this.max.add(e),
            this
        },
        expandByScalar: function(e) {
            return this.min.addScalar(-e),
            this.max.addScalar(e),
            this
        },
        expandByObject: (Ha = new Me,
        function(e) {
            return Ua = this,
            e.updateMatrixWorld(!0),
            e.traverse(to),
            this
        }
        ),
        containsPoint: function(e) {
            return !(e.x < this.min.x || e.x > this.max.x || e.y < this.min.y || e.y > this.max.y || e.z < this.min.z || e.z > this.max.z)
        },
        containsBox: function(e) {
            return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y && this.min.z <= e.min.z && e.max.z <= this.max.z
        },
        getParameter: function(e, t) {
            return void 0 === t && (console.warn("THREE.Box3: .getParameter() target is now required"),
            t = new Me),
            t.set((e.x - this.min.x) / (this.max.x - this.min.x), (e.y - this.min.y) / (this.max.y - this.min.y), (e.z - this.min.z) / (this.max.z - this.min.z))
        },
        intersectsBox: function(e) {
            return !(e.max.x < this.min.x || e.min.x > this.max.x || e.max.y < this.min.y || e.min.y > this.max.y || e.max.z < this.min.z || e.min.z > this.max.z)
        },
        intersectsSphere: (za = new Me,
        function(e) {
            return this.clampPoint(e.center, za),
            za.distanceToSquared(e.center) <= e.radius * e.radius
        }
        ),
        intersectsPlane: function(e) {
            var t, i = 0 < e.normal.x ? (t = e.normal.x * this.min.x,
            e.normal.x * this.max.x) : (t = e.normal.x * this.max.x,
            e.normal.x * this.min.x);
            return 0 < e.normal.y ? (t += e.normal.y * this.min.y,
            i += e.normal.y * this.max.y) : (t += e.normal.y * this.max.y,
            i += e.normal.y * this.min.y),
            0 < e.normal.z ? (t += e.normal.z * this.min.z,
            i += e.normal.z * this.max.z) : (t += e.normal.z * this.max.z,
            i += e.normal.z * this.min.z),
            t <= -e.constant && i >= -e.constant
        },
        intersectsTriangle: (Aa = new Me,
        La = new Me,
        Pa = new Me,
        Ra = new Me,
        Ca = new Me,
        Oa = new Me,
        Ia = new Me,
        Da = new Me,
        Ba = new Me,
        Na = new Me,
        function(e) {
            return !this.isEmpty() && (this.getCenter(Da),
            Ba.subVectors(this.max, Da),
            Aa.subVectors(e.a, Da),
            La.subVectors(e.b, Da),
            Pa.subVectors(e.c, Da),
            Ra.subVectors(La, Aa),
            Ca.subVectors(Pa, La),
            Oa.subVectors(Aa, Pa),
            !!eo(e = [0, -Ra.z, Ra.y, 0, -Ca.z, Ca.y, 0, -Oa.z, Oa.y, Ra.z, 0, -Ra.x, Ca.z, 0, -Ca.x, Oa.z, 0, -Oa.x, -Ra.y, Ra.x, 0, -Ca.y, Ca.x, 0, -Oa.y, Oa.x, 0])) && !!eo(e = [1, 0, 0, 0, 1, 0, 0, 0, 1]) && (Na.crossVectors(Ra, Ca),
            eo(e = [Na.x, Na.y, Na.z]))
        }
        ),
        clampPoint: function(e, t) {
            return void 0 === t && (console.warn("THREE.Box3: .clampPoint() target is now required"),
            t = new Me),
            t.copy(e).clamp(this.min, this.max)
        },
        distanceToPoint: (Ta = new Me,
        function(e) {
            return Ta.copy(e).clamp(this.min, this.max).sub(e).length()
        }
        ),
        getBoundingSphere: (Sa = new Me,
        function(e) {
            return void 0 === e && (console.warn("THREE.Box3: .getBoundingSphere() target is now required"),
            e = new I),
            this.getCenter(e.center),
            e.radius = .5 * this.getSize(Sa).length(),
            e
        }
        ),
        intersect: function(e) {
            return this.min.max(e.min),
            this.max.min(e.max),
            this.isEmpty() && this.makeEmpty(),
            this
        },
        union: function(e) {
            return this.min.min(e.min),
            this.max.max(e.max),
            this
        },
        applyMatrix4: (Ea = [new Me, new Me, new Me, new Me, new Me, new Me, new Me, new Me],
        function(e) {
            return this.isEmpty() || (Ea[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(e),
            Ea[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(e),
            Ea[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(e),
            Ea[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(e),
            Ea[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(e),
            Ea[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(e),
            Ea[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(e),
            Ea[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(e),
            this.setFromPoints(Ea)),
            this
        }
        ),
        translate: function(e) {
            return this.min.add(e),
            this.max.add(e),
            this
        },
        equals: function(e) {
            return e.min.equals(this.min) && e.max.equals(this.max)
        }
    }),
    Object.assign(I.prototype, {
        set: function(e, t) {
            return this.center.copy(e),
            this.radius = t,
            this
        },
        setFromPoints: (Va = new O,
        function(e, t) {
            var i = this.center;
            void 0 !== t ? i.copy(t) : Va.setFromPoints(e).getCenter(i);
            for (var n = t = 0, r = e.length; n < r; n++)
                t = Math.max(t, i.distanceToSquared(e[n]));
            return this.radius = Math.sqrt(t),
            this
        }
        ),
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(e) {
            return this.center.copy(e.center),
            this.radius = e.radius,
            this
        },
        empty: function() {
            return this.radius <= 0
        },
        containsPoint: function(e) {
            return e.distanceToSquared(this.center) <= this.radius * this.radius
        },
        distanceToPoint: function(e) {
            return e.distanceTo(this.center) - this.radius
        },
        intersectsSphere: function(e) {
            var t = this.radius + e.radius;
            return e.center.distanceToSquared(this.center) <= t * t
        },
        intersectsBox: function(e) {
            return e.intersectsSphere(this)
        },
        intersectsPlane: function(e) {
            return Math.abs(e.distanceToPoint(this.center)) <= this.radius
        },
        clampPoint: function(e, t) {
            var i = this.center.distanceToSquared(e);
            return void 0 === t && (console.warn("THREE.Sphere: .clampPoint() target is now required"),
            t = new Me),
            t.copy(e),
            i > this.radius * this.radius && (t.sub(this.center).normalize(),
            t.multiplyScalar(this.radius).add(this.center)),
            t
        },
        getBoundingBox: function(e) {
            return void 0 === e && (console.warn("THREE.Sphere: .getBoundingBox() target is now required"),
            e = new O),
            e.set(this.center, this.center),
            e.expandByScalar(this.radius),
            e
        },
        applyMatrix4: function(e) {
            return this.center.applyMatrix4(e),
            this.radius *= e.getMaxScaleOnAxis(),
            this
        },
        translate: function(e) {
            return this.center.add(e),
            this
        },
        equals: function(e) {
            return e.center.equals(this.center) && e.radius === this.radius
        }
    }),
    Object.assign(D.prototype, {
        set: function(e, t) {
            return this.normal.copy(e),
            this.constant = t,
            this
        },
        setComponents: function(e, t, i, n) {
            return this.normal.set(e, t, i),
            this.constant = n,
            this
        },
        setFromNormalAndCoplanarPoint: function(e, t) {
            return this.normal.copy(e),
            this.constant = -t.dot(this.normal),
            this
        },
        setFromCoplanarPoints: (Xa = new Me,
        Ya = new Me,
        function(e, t, i) {
            return t = Xa.subVectors(i, t).cross(Ya.subVectors(e, t)).normalize(),
            this.setFromNormalAndCoplanarPoint(t, e),
            this
        }
        ),
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(e) {
            return this.normal.copy(e.normal),
            this.constant = e.constant,
            this
        },
        normalize: function() {
            var e = 1 / this.normal.length();
            return this.normal.multiplyScalar(e),
            this.constant *= e,
            this
        },
        negate: function() {
            return this.constant *= -1,
            this.normal.negate(),
            this
        },
        distanceToPoint: function(e) {
            return this.normal.dot(e) + this.constant
        },
        distanceToSphere: function(e) {
            return this.distanceToPoint(e.center) - e.radius
        },
        projectPoint: function(e, t) {
            return void 0 === t && (console.warn("THREE.Plane: .projectPoint() target is now required"),
            t = new Me),
            t.copy(this.normal).multiplyScalar(-this.distanceToPoint(e)).add(e)
        },
        intersectLine: (qa = new Me,
        function(e, t) {
            void 0 === t && (console.warn("THREE.Plane: .intersectLine() target is now required"),
            t = new Me);
            var i = e.delta(qa)
              , n = this.normal.dot(i);
            if (0 === n) {
                if (0 === this.distanceToPoint(e.start))
                    return t.copy(e.start)
            } else if (!((n = -(e.start.dot(this.normal) + this.constant) / n) < 0 || 1 < n))
                return t.copy(i).multiplyScalar(n).add(e.start)
        }
        ),
        intersectsLine: function(e) {
            var t = this.distanceToPoint(e.start);
            return e = this.distanceToPoint(e.end),
            t < 0 && 0 < e || e < 0 && 0 < t
        },
        intersectsBox: function(e) {
            return e.intersectsPlane(this)
        },
        intersectsSphere: function(e) {
            return e.intersectsPlane(this)
        },
        coplanarPoint: function(e) {
            return void 0 === e && (console.warn("THREE.Plane: .coplanarPoint() target is now required"),
            e = new Me),
            e.copy(this.normal).multiplyScalar(-this.constant)
        },
        applyMatrix4: (ja = new Me,
        Wa = new g,
        function(e, t) {
            return t = t || Wa.getNormalMatrix(e),
            e = this.coplanarPoint(ja).applyMatrix4(e),
            t = this.normal.applyMatrix3(t).normalize(),
            this.constant = -e.dot(t),
            this
        }
        ),
        translate: function(e) {
            return this.constant -= e.dot(this.normal),
            this
        },
        equals: function(e) {
            return e.normal.equals(this.normal) && e.constant === this.constant
        }
    }),
    Object.assign(Le.prototype, {
        set: function(e, t, i, n, r, a) {
            var o = this.planes;
            return o[0].copy(e),
            o[1].copy(t),
            o[2].copy(i),
            o[3].copy(n),
            o[4].copy(r),
            o[5].copy(a),
            this
        },
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(e) {
            for (var t = this.planes, i = 0; i < 6; i++)
                t[i].copy(e.planes[i]);
            return this
        },
        setFromMatrix: function(e) {
            var t = this.planes
              , i = (e = (g = e.elements)[0],
            g[1])
              , n = g[2]
              , r = g[3]
              , a = g[4]
              , o = g[5]
              , s = g[6]
              , c = g[7]
              , h = g[8]
              , l = g[9]
              , u = g[10]
              , p = g[11]
              , d = g[12]
              , f = g[13]
              , m = g[14]
              , g = g[15];
            return t[0].setComponents(r - e, c - a, p - h, g - d).normalize(),
            t[1].setComponents(r + e, c + a, p + h, g + d).normalize(),
            t[2].setComponents(r + i, c + o, p + l, g + f).normalize(),
            t[3].setComponents(r - i, c - o, p - l, g - f).normalize(),
            t[4].setComponents(r - n, c - s, p - u, g - m).normalize(),
            t[5].setComponents(r + n, c + s, p + u, g + m).normalize(),
            this
        },
        intersectsObject: (Qa = new I,
        function(e) {
            var t = e.geometry;
            return null === t.boundingSphere && t.computeBoundingSphere(),
            Qa.copy(t.boundingSphere).applyMatrix4(e.matrixWorld),
            this.intersectsSphere(Qa)
        }
        ),
        intersectsSprite: (Za = new I,
        function(e) {
            return Za.center.set(0, 0, 0),
            Za.radius = .7071067811865476,
            Za.applyMatrix4(e.matrixWorld),
            this.intersectsSphere(Za)
        }
        ),
        intersectsSphere: function(e) {
            var t = this.planes
              , i = e.center;
            e = -e.radius;
            for (var n = 0; n < 6; n++)
                if (t[n].distanceToPoint(i) < e)
                    return !1;
            return !0
        },
        intersectsBox: (Ja = new Me,
        function(e) {
            for (var t = this.planes, i = 0; i < 6; i++) {
                var n = t[i];
                if (Ja.x = (0 < n.normal.x ? e.max : e.min).x,
                Ja.y = (0 < n.normal.y ? e.max : e.min).y,
                Ja.z = (0 < n.normal.z ? e.max : e.min).z,
                n.distanceToPoint(Ja) < 0)
                    return !1
            }
            return !0
        }
        ),
        containsPoint: function(e) {
            for (var t = this.planes, i = 0; i < 6; i++)
                if (t[i].distanceToPoint(e) < 0)
                    return !1;
            return !0
        }
    });
    var io, no, ro, T = {
        alphamap_fragment: "#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif",
        alphamap_pars_fragment: "#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",
        alphatest_fragment: "#ifdef ALPHATEST\n\tif ( diffuseColor.a < ALPHATEST ) discard;\n#endif",
        aomap_fragment: "#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( PHYSICAL )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\n\t#endif\n#endif",
        aomap_pars_fragment: "#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif",
        begin_vertex: "vec3 transformed = vec3( position );",
        beginnormal_vertex: "vec3 objectNormal = vec3( normal );",
        bsdfs: "vec2 integrateSpecularBRDF( const in float dotNV, const in float roughness ) {\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\treturn vec2( -1.04, 1.04 ) * a004 + r.zw;\n}\nfloat punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\tif( cutoffDistance > 0.0 ) {\n\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t}\n\treturn distanceFalloff;\n#else\n\tif( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n\t\treturn pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\t}\n\treturn 1.0;\n#endif\n}\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\n\treturn ( 1.0 - specularColor ) * fresnel + specularColor;\n}\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\tfloat gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\treturn 1.0 / ( gl * gv );\n}\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNL = saturate( dot( geometry.normal, incidentLight.direction ) );\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( G * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE  = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS  = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\nvec3 BRDF_Specular_GGX_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\treturn specularColor * brdf.x + brdf.y;\n}\nvoid BRDF_Specular_Multiscattering_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tvec3 F = F_Schlick( specularColor, dotNV );\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\tvec3 FssEss = F * brdf.x + brdf.y;\n\tfloat Ess = brdf.x + brdf.y;\n\tfloat Ems = 1.0 - Ess;\n\tvec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n\treturn ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\n}\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\n\treturn sqrt( 2.0 / ( blinnExponent + 2.0 ) );\n}",
        bumpmap_pars_fragment: "#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\n\t\tvec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n\t\tvec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 );\n\t\tfDet *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif",
        clipping_planes_fragment: "#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\tplane = clippingPlanes[ i ];\n\t\tif ( dot( vViewPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\t#pragma unroll_loop\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vViewPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\tif ( clipped ) discard;\n\t#endif\n#endif",
        clipping_planes_pars_fragment: "#if NUM_CLIPPING_PLANES > 0\n\t#if ! defined( PHYSICAL ) && ! defined( PHONG ) && ! defined( MATCAP )\n\t\tvarying vec3 vViewPosition;\n\t#endif\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif",
        clipping_planes_pars_vertex: "#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG ) && ! defined( MATCAP )\n\tvarying vec3 vViewPosition;\n#endif",
        clipping_planes_vertex: "#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG ) && ! defined( MATCAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif",
        color_fragment: "#ifdef USE_COLOR\n\tdiffuseColor.rgb *= vColor;\n#endif",
        color_pars_fragment: "#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif",
        color_pars_vertex: "#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif",
        color_vertex: "#ifdef USE_COLOR\n\tvColor.xyz = color.xyz;\n#endif",
        common: "#define PI 3.14159265359\n#define PI2 6.28318530718\n#define PI_HALF 1.5707963267949\n#define RECIPROCAL_PI 0.31830988618\n#define RECIPROCAL_PI2 0.15915494\n#define LOG2 1.442695\n#define EPSILON 1e-6\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#define whiteCompliment(a) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract(sin(sn) * c);\n}\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\tfloat distance = dot( planeNormal, point - pointOnPlane );\n\treturn - distance * planeNormal + point;\n}\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn sign( dot( point - pointOnPlane, planeNormal ) );\n}\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat linearToRelativeLuminance( const in vec3 color ) {\n\tvec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n\treturn dot( weights, color.rgb );\n}",
        cube_uv_reflection_fragment: "#ifdef ENVMAP_TYPE_CUBE_UV\n#define cubeUV_textureSize (1024.0)\nint getFaceFromDirection(vec3 direction) {\n\tvec3 absDirection = abs(direction);\n\tint face = -1;\n\tif( absDirection.x > absDirection.z ) {\n\t\tif(absDirection.x > absDirection.y )\n\t\t\tface = direction.x > 0.0 ? 0 : 3;\n\t\telse\n\t\t\tface = direction.y > 0.0 ? 1 : 4;\n\t}\n\telse {\n\t\tif(absDirection.z > absDirection.y )\n\t\t\tface = direction.z > 0.0 ? 2 : 5;\n\t\telse\n\t\t\tface = direction.y > 0.0 ? 1 : 4;\n\t}\n\treturn face;\n}\n#define cubeUV_maxLods1  (log2(cubeUV_textureSize*0.25) - 1.0)\n#define cubeUV_rangeClamp (exp2((6.0 - 1.0) * 2.0))\nvec2 MipLevelInfo( vec3 vec, float roughnessLevel, float roughness ) {\n\tfloat scale = exp2(cubeUV_maxLods1 - roughnessLevel);\n\tfloat dxRoughness = dFdx(roughness);\n\tfloat dyRoughness = dFdy(roughness);\n\tvec3 dx = dFdx( vec * scale * dxRoughness );\n\tvec3 dy = dFdy( vec * scale * dyRoughness );\n\tfloat d = max( dot( dx, dx ), dot( dy, dy ) );\n\td = clamp(d, 1.0, cubeUV_rangeClamp);\n\tfloat mipLevel = 0.5 * log2(d);\n\treturn vec2(floor(mipLevel), fract(mipLevel));\n}\n#define cubeUV_maxLods2 (log2(cubeUV_textureSize*0.25) - 2.0)\n#define cubeUV_rcpTextureSize (1.0 / cubeUV_textureSize)\nvec2 getCubeUV(vec3 direction, float roughnessLevel, float mipLevel) {\n\tmipLevel = roughnessLevel > cubeUV_maxLods2 - 3.0 ? 0.0 : mipLevel;\n\tfloat a = 16.0 * cubeUV_rcpTextureSize;\n\tvec2 exp2_packed = exp2( vec2( roughnessLevel, mipLevel ) );\n\tvec2 rcp_exp2_packed = vec2( 1.0 ) / exp2_packed;\n\tfloat powScale = exp2_packed.x * exp2_packed.y;\n\tfloat scale = rcp_exp2_packed.x * rcp_exp2_packed.y * 0.25;\n\tfloat mipOffset = 0.75*(1.0 - rcp_exp2_packed.y) * rcp_exp2_packed.x;\n\tbool bRes = mipLevel == 0.0;\n\tscale =  bRes && (scale < a) ? a : scale;\n\tvec3 r;\n\tvec2 offset;\n\tint face = getFaceFromDirection(direction);\n\tfloat rcpPowScale = 1.0 / powScale;\n\tif( face == 0) {\n\t\tr = vec3(direction.x, -direction.z, direction.y);\n\t\toffset = vec2(0.0+mipOffset,0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 1) {\n\t\tr = vec3(direction.y, direction.x, direction.z);\n\t\toffset = vec2(scale+mipOffset, 0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 2) {\n\t\tr = vec3(direction.z, direction.x, direction.y);\n\t\toffset = vec2(2.0*scale+mipOffset, 0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 3) {\n\t\tr = vec3(direction.x, direction.z, direction.y);\n\t\toffset = vec2(0.0+mipOffset,0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\telse if( face == 4) {\n\t\tr = vec3(direction.y, direction.x, -direction.z);\n\t\toffset = vec2(scale+mipOffset, 0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\telse {\n\t\tr = vec3(direction.z, -direction.x, direction.y);\n\t\toffset = vec2(2.0*scale+mipOffset, 0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\tr = normalize(r);\n\tfloat texelOffset = 0.5 * cubeUV_rcpTextureSize;\n\tvec2 s = ( r.yz / abs( r.x ) + vec2( 1.0 ) ) * 0.5;\n\tvec2 base = offset + vec2( texelOffset );\n\treturn base + s * ( scale - 2.0 * texelOffset );\n}\n#define cubeUV_maxLods3 (log2(cubeUV_textureSize*0.25) - 3.0)\nvec4 textureCubeUV( sampler2D envMap, vec3 reflectedDirection, float roughness ) {\n\tfloat roughnessVal = roughness* cubeUV_maxLods3;\n\tfloat r1 = floor(roughnessVal);\n\tfloat r2 = r1 + 1.0;\n\tfloat t = fract(roughnessVal);\n\tvec2 mipInfo = MipLevelInfo(reflectedDirection, r1, roughness);\n\tfloat s = mipInfo.y;\n\tfloat level0 = mipInfo.x;\n\tfloat level1 = level0 + 1.0;\n\tlevel1 = level1 > 5.0 ? 5.0 : level1;\n\tlevel0 += min( floor( s + 0.5 ), 5.0 );\n\tvec2 uv_10 = getCubeUV(reflectedDirection, r1, level0);\n\tvec4 color10 = envMapTexelToLinear(texture2D(envMap, uv_10));\n\tvec2 uv_20 = getCubeUV(reflectedDirection, r2, level0);\n\tvec4 color20 = envMapTexelToLinear(texture2D(envMap, uv_20));\n\tvec4 result = mix(color10, color20, t);\n\treturn vec4(result.rgb, 1.0);\n}\n#endif",
        defaultnormal_vertex: "vec3 transformedNormal = normalMatrix * objectNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif",
        displacementmap_pars_vertex: "#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif",
        displacementmap_vertex: "#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, uv ).x * displacementScale + displacementBias );\n#endif",
        emissivemap_fragment: "#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif",
        emissivemap_pars_fragment: "#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif",
        encodings_fragment: "gl_FragColor = linearToOutputTexel( gl_FragColor );",
        encodings_pars_fragment: "\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( gammaFactor ) ), value.a );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( 1.0 / gammaFactor ) ), value.a );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n\treturn vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n\tfloat maxComponent = max( max( value.r, value.g ), value.b );\n\tfloat fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n\treturn vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * value.a * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat M = clamp( maxRGB / maxRange, 0.0, 1.0 );\n\tM = ceil( M * 255.0 ) / 255.0;\n\treturn vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat D = max( maxRange / maxRGB, 1.0 );\n\tD = min( floor( D ) / 255.0, 1.0 );\n\treturn vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value )  {\n\tvec3 Xp_Y_XYZp = cLogLuvM * value.rgb;\n\tXp_Y_XYZp = max( Xp_Y_XYZp, vec3( 1e-6, 1e-6, 1e-6 ) );\n\tvec4 vResult;\n\tvResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n\tfloat Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n\tvResult.w = fract( Le );\n\tvResult.z = ( Le - ( floor( vResult.w * 255.0 ) ) / 255.0 ) / 255.0;\n\treturn vResult;\n}\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n\tfloat Le = value.z * 255.0 + value.w;\n\tvec3 Xp_Y_XYZp;\n\tXp_Y_XYZp.y = exp2( ( Le - 127.0 ) / 2.0 );\n\tXp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n\tXp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n\tvec3 vRGB = cLogLuvInverseM * Xp_Y_XYZp.rgb;\n\treturn vec4( max( vRGB, 0.0 ), 1.0 );\n}",
        envmap_fragment: "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\tvec2 sampleUV;\n\t\treflectVec = normalize( reflectVec );\n\t\tsampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\t\tsampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\t\tvec4 envColor = texture2D( envMap, sampleUV );\n\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\treflectVec = normalize( reflectVec );\n\t\tvec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0, 0.0, 1.0 ) );\n\t\tvec4 envColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5 );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\tenvColor = envMapTexelToLinear( envColor );\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif",
        envmap_pars_fragment: "#if defined( USE_ENVMAP ) || defined( PHYSICAL )\n\tuniform float reflectivity;\n\tuniform float envMapIntensity;\n#endif\n#ifdef USE_ENVMAP\n\t#if ! defined( PHYSICAL ) && ( defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) )\n\t\tvarying vec3 vWorldPosition;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\tuniform float flipEnvMap;\n\tuniform int maxMipLevel;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( PHYSICAL )\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif",
        envmap_pars_vertex: "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif",
        envmap_physical_pars_fragment: "#if defined( USE_ENVMAP ) && defined( PHYSICAL )\n\tvec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\n\t\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, queryVec, 1.0 );\n\t\t#else\n\t\t\tvec4 envMapColor = vec4( 0.0 );\n\t\t#endif\n\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t}\n\tfloat getSpecularMIPLevel( const in float blinnShininessExponent, const in int maxMIPLevel ) {\n\t\tfloat maxMIPLevelScalar = float( maxMIPLevel );\n\t\tfloat desiredMIPLevel = maxMIPLevelScalar + 0.79248 - 0.5 * log2( pow2( blinnShininessExponent ) + 1.0 );\n\t\treturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n\t}\n\tvec3 getLightProbeIndirectRadiance( const in GeometricContext geometry, const in float blinnShininessExponent, const in int maxMIPLevel ) {\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( -geometry.viewDir, geometry.normal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( -geometry.viewDir, geometry.normal, refractionRatio );\n\t\t#endif\n\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\tfloat specularMIPLevel = getSpecularMIPLevel( blinnShininessExponent, maxMIPLevel );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, queryReflectVec, BlinnExponentToGGXRoughness(blinnShininessExponent ));\n\t\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\t\tvec2 sampleUV;\n\t\t\tsampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\t\t\tsampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, sampleUV, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, sampleUV, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\t\tvec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0,0.0,1.0 ) );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#endif\n\t\treturn envMapColor.rgb * envMapIntensity;\n\t}\n#endif",
        envmap_vertex: "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif",
        fog_vertex: "#ifdef USE_FOG\n\tfogDepth = -mvPosition.z;\n#endif",
        fog_pars_vertex: "#ifdef USE_FOG\n\tvarying float fogDepth;\n#endif",
        fog_fragment: "#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = whiteCompliment( exp2( - fogDensity * fogDensity * fogDepth * fogDepth * LOG2 ) );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, fogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif",
        fog_pars_fragment: "#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float fogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif",
        gradientmap_pars_fragment: "#ifdef TOON\n\tuniform sampler2D gradientMap;\n\tvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\t\tfloat dotNL = dot( normal, lightDirection );\n\t\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t\t#ifdef USE_GRADIENTMAP\n\t\t\treturn texture2D( gradientMap, coord ).rgb;\n\t\t#else\n\t\t\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n\t\t#endif\n\t}\n#endif",
        lightmap_fragment: "#ifdef USE_LIGHTMAP\n\treflectedLight.indirectDiffuse += PI * texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n#endif",
        lightmap_pars_fragment: "#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif",
        lights_lambert_vertex: "vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\nvIndirectFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n\tvIndirectBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\n#if NUM_POINT_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tgetPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tgetSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_DIR_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tgetDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\tvIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\n\t\t#endif\n\t}\n#endif",
        lights_pars_begin: "uniform vec3 ambientLightColor;\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treturn irradiance;\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tdirectLight.color = directionalLight.color;\n\t\tdirectLight.direction = directionalLight.direction;\n\t\tdirectLight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t\tfloat shadowCameraNear;\n\t\tfloat shadowCameraFar;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tdirectLight.color = pointLight.color;\n\t\tdirectLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\n\t\tdirectLight.visible = ( directLight.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight  ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tfloat angleCos = dot( directLight.direction, spotLight.direction );\n\t\tif ( angleCos > spotLight.coneCos ) {\n\t\t\tfloat spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\t\tdirectLight.color = spotLight.color;\n\t\t\tdirectLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tdirectLight.visible = true;\n\t\t} else {\n\t\t\tdirectLight.color = vec3( 0.0 );\n\t\t\tdirectLight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n\t\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tirradiance *= PI;\n\t\t#endif\n\t\treturn irradiance;\n\t}\n#endif",
        lights_phong_fragment: "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;",
        lights_phong_pars_fragment: "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct BlinnPhongMaterial {\n\tvec3\tdiffuseColor;\n\tvec3\tspecularColor;\n\tfloat\tspecularShininess;\n\tfloat\tspecularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\t#ifdef TOON\n\t\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\t#else\n\t\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\t\tvec3 irradiance = dotNL * directLight.color;\n\t#endif\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)",
        lights_physical_fragment: "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nmaterial.specularRoughness = clamp( roughnessFactor, 0.04, 1.0 );\n#ifdef STANDARD\n\tmaterial.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\n\tmaterial.clearCoat = saturate( clearCoat );\tmaterial.clearCoatRoughness = clamp( clearCoatRoughness, 0.04, 1.0 );\n#endif",
        lights_physical_pars_fragment: "struct PhysicalMaterial {\n\tvec3\tdiffuseColor;\n\tfloat\tspecularRoughness;\n\tvec3\tspecularColor;\n\t#ifndef STANDARD\n\t\tfloat clearCoat;\n\t\tfloat clearCoatRoughness;\n\t#endif\n};\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\nfloat clearCoatDHRApprox( const in float roughness, const in float dotNL ) {\n\treturn DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.specularRoughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\t#ifndef STANDARD\n\t\tfloat clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\n\t#else\n\t\tfloat clearCoatDHR = 0.0;\n\t#endif\n\treflectedLight.directSpecular += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry, material.specularColor, material.specularRoughness );\n\treflectedLight.directDiffuse += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\t#ifndef STANDARD\n\t\treflectedLight.directSpecular += irradiance * material.clearCoat * BRDF_Specular_GGX( directLight, geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\n\t#endif\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t#ifndef ENVMAP_TYPE_CUBE_UV\n\t\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\t#endif\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearCoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\t#ifndef STANDARD\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\tfloat dotNL = dotNV;\n\t\tfloat clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\n\t#else\n\t\tfloat clearCoatDHR = 0.0;\n\t#endif\n\tfloat clearCoatInv = 1.0 - clearCoatDHR;\n\t#if defined( ENVMAP_TYPE_CUBE_UV )\n\t\tvec3 singleScattering = vec3( 0.0 );\n\t\tvec3 multiScattering = vec3( 0.0 );\n\t\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\t\tBRDF_Specular_Multiscattering_Environment( geometry, material.specularColor, material.specularRoughness, singleScattering, multiScattering );\n\t\tvec3 diffuse = material.diffuseColor;\n\t\treflectedLight.indirectSpecular += clearCoatInv * radiance * singleScattering;\n\t\treflectedLight.indirectDiffuse += multiScattering * cosineWeightedIrradiance;\n\t\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n\t#else\n\t\treflectedLight.indirectSpecular += clearCoatInv * radiance * BRDF_Specular_GGX_Environment( geometry, material.specularColor, material.specularRoughness );\n\t#endif\n\t#ifndef STANDARD\n\t\treflectedLight.indirectSpecular += clearCoatRadiance * material.clearCoat * BRDF_Specular_GGX_Environment( geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\n\t#endif\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\n#define Material_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.specularRoughness )\n#define Material_ClearCoat_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.clearCoatRoughness )\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}",
        lights_fragment_begin: "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = normalize( vViewPosition );\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointDirectLightIrradiance( pointLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( pointLight.shadow, directLight.visible ) ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotDirectLightIrradiance( spotLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( spotLight.shadow, directLight.visible ) ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( directionalLight.shadow, directLight.visible ) ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t}\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearCoatRadiance = vec3( 0.0 );\n#endif",
        lights_fragment_maps: "#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec3 lightMapIrradiance = texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tlightMapIrradiance *= PI;\n\t\t#endif\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( PHYSICAL ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tirradiance += getLightProbeIndirectIrradiance( geometry, maxMipLevel );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tradiance += getLightProbeIndirectRadiance( geometry, Material_BlinnShininessExponent( material ), maxMipLevel );\n\t#ifndef STANDARD\n\t\tclearCoatRadiance += getLightProbeIndirectRadiance( geometry, Material_ClearCoat_BlinnShininessExponent( material ), maxMipLevel );\n\t#endif\n#endif",
        lights_fragment_end: "#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, irradiance, clearCoatRadiance, geometry, material, reflectedLight );\n#endif",
        logdepthbuf_fragment: "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif",
        logdepthbuf_pars_fragment: "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n#endif",
        logdepthbuf_pars_vertex: "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t#else\n\t\tuniform float logDepthBufFC;\n\t#endif\n#endif",
        logdepthbuf_vertex: "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t#else\n\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\tgl_Position.z *= gl_Position.w;\n\t#endif\n#endif",
        map_fragment: "#ifdef USE_MAP\n\tvec4 texelColor = texture2D( map, vUv );\n\ttexelColor = mapTexelToLinear( texelColor );\n\tdiffuseColor *= texelColor;\n#endif",
        map_pars_fragment: "#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif",
        map_particle_fragment: "#ifdef USE_MAP\n\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n\tvec4 mapTexel = texture2D( map, uv );\n\tdiffuseColor *= mapTexelToLinear( mapTexel );\n#endif",
        map_particle_pars_fragment: "#ifdef USE_MAP\n\tuniform mat3 uvTransform;\n\tuniform sampler2D map;\n#endif",
        metalnessmap_fragment: "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif",
        metalnessmap_pars_fragment: "#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif",
        morphnormal_vertex: "#ifdef USE_MORPHNORMALS\n\tobjectNormal += ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];\n\tobjectNormal += ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];\n\tobjectNormal += ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];\n\tobjectNormal += ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];\n#endif",
        morphtarget_pars_vertex: "#ifdef USE_MORPHTARGETS\n\t#ifndef USE_MORPHNORMALS\n\tuniform float morphTargetInfluences[ 8 ];\n\t#else\n\tuniform float morphTargetInfluences[ 4 ];\n\t#endif\n#endif",
        morphtarget_vertex: "#ifdef USE_MORPHTARGETS\n\ttransformed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];\n\ttransformed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];\n\ttransformed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];\n\ttransformed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];\n\t#ifndef USE_MORPHNORMALS\n\ttransformed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];\n\ttransformed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];\n\ttransformed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];\n\ttransformed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];\n\t#endif\n#endif",
        normal_fragment_begin: "#ifdef FLAT_SHADED\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t#endif\n#endif",
        normal_fragment_maps: "#ifdef USE_NORMALMAP\n\t#ifdef OBJECTSPACE_NORMALMAP\n\t\tnormal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t\t#ifdef FLIP_SIDED\n\t\t\tnormal = - normal;\n\t\t#endif\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t#endif\n\t\tnormal = normalize( normalMatrix * normal );\n\t#else\n\t\tnormal = perturbNormal2Arb( -vViewPosition, normal );\n\t#endif\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\n#endif",
        normalmap_pars_fragment: "#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n\t#ifdef OBJECTSPACE_NORMALMAP\n\t\tuniform mat3 normalMatrix;\n\t#else\n\t\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {\n\t\t\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n\t\t\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n\t\t\tvec2 st0 = dFdx( vUv.st );\n\t\t\tvec2 st1 = dFdy( vUv.st );\n\t\t\tfloat scale = sign( st1.t * st0.s - st0.t * st1.s );\n\t\t\tvec3 S = normalize( ( q0 * st1.t - q1 * st0.t ) * scale );\n\t\t\tvec3 T = normalize( ( - q0 * st1.s + q1 * st0.s ) * scale );\n\t\t\tvec3 N = normalize( surf_norm );\n\t\t\tmat3 tsn = mat3( S, T, N );\n\t\t\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t\t\tmapN.xy *= normalScale;\n\t\t\tmapN.xy *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t\treturn normalize( tsn * mapN );\n\t\t}\n\t#endif\n#endif",
        packing: "vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}",
        premultiplied_alpha_fragment: "#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif",
        project_vertex: "vec4 mvPosition = modelViewMatrix * vec4( transformed, 1.0 );\ngl_Position = projectionMatrix * mvPosition;",
        dithering_fragment: "#if defined( DITHERING )\n  gl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif",
        dithering_pars_fragment: "#if defined( DITHERING )\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif",
        roughnessmap_fragment: "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.g;\n#endif",
        roughnessmap_pars_fragment: "#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif",
        shadowmap_pars_fragment: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHTS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHTS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\n\t\tconst vec2 offset = vec2( 0.0, 1.0 );\n\t\tvec2 texelSize = vec2( 1.0 ) / size;\n\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\n\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\n\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\n\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\n\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\n\t\tvec2 f = fract( uv * size + 0.5 );\n\t\tfloat a = mix( lb, lt, f.y );\n\t\tfloat b = mix( rb, rt, f.y );\n\t\tfloat c = mix( a, b, f.x );\n\t\treturn c;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tshadow = (\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif",
        shadowmap_pars_vertex: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHTS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHTS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\n\t#endif\n#endif",
        shadowmap_vertex: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n#endif",
        shadowmask_pars_fragment: "float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\tDirectionalLight directionalLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tshadow *= bool( directionalLight.shadow ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\tSpotLight spotLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tshadow *= bool( spotLight.shadow ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\tPointLight pointLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tshadow *= bool( pointLight.shadow ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#endif\n\t#endif\n\treturn shadow;\n}",
        skinbase_vertex: "#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif",
        skinning_pars_vertex: "#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\t#ifdef BONE_TEXTURE\n\t\tuniform sampler2D boneTexture;\n\t\tuniform int boneTextureSize;\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tfloat j = i * 4.0;\n\t\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\t\ty = dy * ( y + 0.5 );\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\t\treturn bone;\n\t\t}\n\t#else\n\t\tuniform mat4 boneMatrices[ MAX_BONES ];\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tmat4 bone = boneMatrices[ int(i) ];\n\t\t\treturn bone;\n\t\t}\n\t#endif\n#endif",
        skinning_vertex: "#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif",
        skinnormal_vertex: "#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n#endif",
        specularmap_fragment: "float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif",
        specularmap_pars_fragment: "#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif",
        tonemapping_fragment: "#if defined( TONE_MAPPING )\n  gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif",
        tonemapping_pars_fragment: "#ifndef saturate\n\t#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nuniform float toneMappingWhitePoint;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\n#define Uncharted2Helper( x ) max( ( ( x * ( 0.15 * x + 0.10 * 0.50 ) + 0.20 * 0.02 ) / ( x * ( 0.15 * x + 0.50 ) + 0.20 * 0.30 ) ) - 0.02 / 0.30, vec3( 0.0 ) )\nvec3 Uncharted2ToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( Uncharted2Helper( color ) / Uncharted2Helper( vec3( toneMappingWhitePoint ) ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( ( color * ( 2.51 * color + 0.03 ) ) / ( color * ( 2.43 * color + 0.59 ) + 0.14 ) );\n}",
        uv_pars_fragment: "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvarying vec2 vUv;\n#endif",
        uv_pars_vertex: "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvarying vec2 vUv;\n\tuniform mat3 uvTransform;\n#endif",
        uv_vertex: "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif",
        uv2_pars_fragment: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif",
        uv2_pars_vertex: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n#endif",
        uv2_vertex: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = uv2;\n#endif",
        worldpos_vertex: "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP )\n\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\n#endif",
        background_frag: "uniform sampler2D t2D;\nvarying vec2 vUv;\nvoid main() {\n\tvec4 texColor = texture2D( t2D, vUv );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
        background_vert: "varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\n}",
        cube_frag: "uniform samplerCube tCube;\nuniform float tFlip;\nuniform float opacity;\nvarying vec3 vWorldDirection;\nvoid main() {\n\tvec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\tgl_FragColor.a *= opacity;\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
        cube_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}",
        depth_frag: "#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - gl_FragCoord.z ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( gl_FragCoord.z );\n\t#endif\n}",
        depth_vert: "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n}",
        distanceRGBA_frag: "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}",
        distanceRGBA_vert: "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}",
        equirect_frag: "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV;\n\tsampleUV.y = asin( clamp( direction.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\tsampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;\n\tvec4 texColor = texture2D( tEquirect, sampleUV );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
        equirect_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}",
        linedashed_frag: "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",
        linedashed_vert: "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\tvLineDistance = scale * lineDistance;\n\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}",
        meshbasic_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\treflectedLight.indirectDiffuse += texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",
        meshbasic_vert: "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_ENVMAP\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}",
        meshlambert_frag: "uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\treflectedLight.indirectDiffuse = getAmbientLightIrradiance( ambientLightColor );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\n\t#else\n\t\treflectedLight.indirectDiffuse += vIndirectFront;\n\t#endif\n\t#include <lightmap_fragment>\n\treflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\t#else\n\t\treflectedLight.directDiffuse = vLightFront;\n\t#endif\n\treflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
        meshlambert_vert: "#define LAMBERT\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
        meshmatcap_frag: "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\t#ifdef USE_MATCAP\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t\tmatcapColor = matcapTexelToLinear( matcapColor );\n\t#else\n\t\tvec4 matcapColor = vec4( 1.0 );\n\t#endif\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",
        meshmatcap_vert: "#define MATCAP\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#ifndef FLAT_SHADED\n\t\tvNormal = normalize( transformedNormal );\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\tvViewPosition = - mvPosition.xyz;\n}",
        meshphong_frag: "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
        meshphong_vert: "#define PHONG\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
        meshphysical_frag: "#define PHYSICAL\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifndef STANDARD\n\tuniform float clearCoat;\n\tuniform float clearCoatRoughness;\n#endif\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <envmap_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <lights_physical_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
        meshphysical_vert: "#define PHYSICAL\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
        normal_frag: "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || ( defined( USE_NORMALMAP ) && ! defined( OBJECTSPACE_NORMALMAP ) )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\nvoid main() {\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n}",
        normal_vert: "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || ( defined( USE_NORMALMAP ) && ! defined( OBJECTSPACE_NORMALMAP ) )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || ( defined( USE_NORMALMAP ) && ! defined( OBJECTSPACE_NORMALMAP ) )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}",
        points_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",
        points_vert: "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}",
        shadow_frag: "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <fog_fragment>\n}",
        shadow_vert: "#include <fog_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
        sprite_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",
        sprite_vert: "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec2 scale;\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}"
    }, ao = {
        clone: Pe,
        merge: t
    }, oo = {
        aliceblue: 15792383,
        antiquewhite: 16444375,
        aqua: 65535,
        aquamarine: 8388564,
        azure: 15794175,
        beige: 16119260,
        bisque: 16770244,
        black: 0,
        blanchedalmond: 16772045,
        blue: 255,
        blueviolet: 9055202,
        brown: 10824234,
        burlywood: 14596231,
        cadetblue: 6266528,
        chartreuse: 8388352,
        chocolate: 13789470,
        coral: 16744272,
        cornflowerblue: 6591981,
        cornsilk: 16775388,
        crimson: 14423100,
        cyan: 65535,
        darkblue: 139,
        darkcyan: 35723,
        darkgoldenrod: 12092939,
        darkgray: 11119017,
        darkgreen: 25600,
        darkgrey: 11119017,
        darkkhaki: 12433259,
        darkmagenta: 9109643,
        darkolivegreen: 5597999,
        darkorange: 16747520,
        darkorchid: 10040012,
        darkred: 9109504,
        darksalmon: 15308410,
        darkseagreen: 9419919,
        darkslateblue: 4734347,
        darkslategray: 3100495,
        darkslategrey: 3100495,
        darkturquoise: 52945,
        darkviolet: 9699539,
        deeppink: 16716947,
        deepskyblue: 49151,
        dimgray: 6908265,
        dimgrey: 6908265,
        dodgerblue: 2003199,
        firebrick: 11674146,
        floralwhite: 16775920,
        forestgreen: 2263842,
        fuchsia: 16711935,
        gainsboro: 14474460,
        ghostwhite: 16316671,
        gold: 16766720,
        goldenrod: 14329120,
        gray: 8421504,
        green: 32768,
        greenyellow: 11403055,
        grey: 8421504,
        honeydew: 15794160,
        hotpink: 16738740,
        indianred: 13458524,
        indigo: 4915330,
        ivory: 16777200,
        khaki: 15787660,
        lavender: 15132410,
        lavenderblush: 16773365,
        lawngreen: 8190976,
        lemonchiffon: 16775885,
        lightblue: 11393254,
        lightcoral: 15761536,
        lightcyan: 14745599,
        lightgoldenrodyellow: 16448210,
        lightgray: 13882323,
        lightgreen: 9498256,
        lightgrey: 13882323,
        lightpink: 16758465,
        lightsalmon: 16752762,
        lightseagreen: 2142890,
        lightskyblue: 8900346,
        lightslategray: 7833753,
        lightslategrey: 7833753,
        lightsteelblue: 11584734,
        lightyellow: 16777184,
        lime: 65280,
        limegreen: 3329330,
        linen: 16445670,
        magenta: 16711935,
        maroon: 8388608,
        mediumaquamarine: 6737322,
        mediumblue: 205,
        mediumorchid: 12211667,
        mediumpurple: 9662683,
        mediumseagreen: 3978097,
        mediumslateblue: 8087790,
        mediumspringgreen: 64154,
        mediumturquoise: 4772300,
        mediumvioletred: 13047173,
        midnightblue: 1644912,
        mintcream: 16121850,
        mistyrose: 16770273,
        moccasin: 16770229,
        navajowhite: 16768685,
        navy: 128,
        oldlace: 16643558,
        olive: 8421376,
        olivedrab: 7048739,
        orange: 16753920,
        orangered: 16729344,
        orchid: 14315734,
        palegoldenrod: 15657130,
        palegreen: 10025880,
        paleturquoise: 11529966,
        palevioletred: 14381203,
        papayawhip: 16773077,
        peachpuff: 16767673,
        peru: 13468991,
        pink: 16761035,
        plum: 14524637,
        powderblue: 11591910,
        purple: 8388736,
        rebeccapurple: 6697881,
        red: 16711680,
        rosybrown: 12357519,
        royalblue: 4286945,
        saddlebrown: 9127187,
        salmon: 16416882,
        sandybrown: 16032864,
        seagreen: 3050327,
        seashell: 16774638,
        sienna: 10506797,
        silver: 12632256,
        skyblue: 8900331,
        slateblue: 6970061,
        slategray: 7372944,
        slategrey: 7372944,
        snow: 16775930,
        springgreen: 65407,
        steelblue: 4620980,
        tan: 13808780,
        teal: 32896,
        thistle: 14204888,
        tomato: 16737095,
        turquoise: 4251856,
        violet: 15631086,
        wheat: 16113331,
        white: 16777215,
        whitesmoke: 16119285,
        yellow: 16776960,
        yellowgreen: 10145074
    };
    function so(e) {
        return e < .0031308 ? 12.92 * e : 1.055 * Math.pow(e, .41666) - .055
    }
    function co(e) {
        return e < .04045 ? .0773993808 * e : Math.pow(.9478672986 * e + .0521327014, 2.4)
    }
    function ho(e, t, i) {
        return i < 0 && (i += 1),
        1 < i && --i,
        i < 1 / 6 ? e + 6 * (t - e) * i : i < .5 ? t : i < 2 / 3 ? e + 6 * (t - e) * (2 / 3 - i) : e
    }
    Object.assign(d.prototype, {
        isColor: !0,
        r: 1,
        g: 1,
        b: 1,
        set: function(e) {
            return e && e.isColor ? this.copy(e) : "number" == typeof e ? this.setHex(e) : "string" == typeof e && this.setStyle(e),
            this
        },
        setScalar: function(e) {
            return this.b = this.g = this.r = e,
            this
        },
        setHex: function(e) {
            return e = Math.floor(e),
            this.r = (e >> 16 & 255) / 255,
            this.g = (e >> 8 & 255) / 255,
            this.b = (255 & e) / 255,
            this
        },
        setRGB: function(e, t, i) {
            return this.r = e,
            this.g = t,
            this.b = i,
            this
        },
        setHSL: function(e, t, i) {
            return e = Se.euclideanModulo(e, 1),
            t = Se.clamp(t, 0, 1),
            i = Se.clamp(i, 0, 1),
            0 === t ? this.r = this.g = this.b = i : (this.r = ho(i = 2 * i - (t = i <= .5 ? i * (1 + t) : i + t - i * t), t, e + 1 / 3),
            this.g = ho(i, t, e),
            this.b = ho(i, t, e - 1 / 3)),
            this
        },
        setStyle: function(t) {
            function e(e) {
                void 0 !== e && parseFloat(e) < 1 && console.warn("THREE.Color: Alpha component of " + t + " will be ignored.")
            }
            var i;
            if (i = /^((?:rgb|hsl)a?)\(\s*([^\)]*)\)/.exec(t)) {
                var n, r, a = i[2];
                switch (i[1]) {
                case "rgb":
                case "rgba":
                    if (i = /^(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(a))
                        return this.r = Math.min(255, parseInt(i[1], 10)) / 255,
                        this.g = Math.min(255, parseInt(i[2], 10)) / 255,
                        this.b = Math.min(255, parseInt(i[3], 10)) / 255,
                        e(i[5]),
                        this;
                    if (i = /^(\d+)%\s*,\s*(\d+)%\s*,\s*(\d+)%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(a))
                        return this.r = Math.min(100, parseInt(i[1], 10)) / 100,
                        this.g = Math.min(100, parseInt(i[2], 10)) / 100,
                        this.b = Math.min(100, parseInt(i[3], 10)) / 100,
                        e(i[5]),
                        this;
                    break;
                case "hsl":
                case "hsla":
                    if (i = /^([0-9]*\.?[0-9]+)\s*,\s*(\d+)%\s*,\s*(\d+)%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(a))
                        return a = parseFloat(i[1]) / 360,
                        n = parseInt(i[2], 10) / 100,
                        r = parseInt(i[3], 10) / 100,
                        e(i[5]),
                        this.setHSL(a, n, r)
                }
            } else if (i = /^#([A-Fa-f0-9]+)$/.exec(t)) {
                if (3 === (a = (i = i[1]).length))
                    return this.r = parseInt(i.charAt(0) + i.charAt(0), 16) / 255,
                    this.g = parseInt(i.charAt(1) + i.charAt(1), 16) / 255,
                    this.b = parseInt(i.charAt(2) + i.charAt(2), 16) / 255,
                    this;
                if (6 === a)
                    return this.r = parseInt(i.charAt(0) + i.charAt(1), 16) / 255,
                    this.g = parseInt(i.charAt(2) + i.charAt(3), 16) / 255,
                    this.b = parseInt(i.charAt(4) + i.charAt(5), 16) / 255,
                    this
            }
            return t && 0 < t.length && (void 0 !== (i = oo[t]) ? this.setHex(i) : console.warn("THREE.Color: Unknown color " + t)),
            this
        },
        clone: function() {
            return new this.constructor(this.r,this.g,this.b)
        },
        copy: function(e) {
            return this.r = e.r,
            this.g = e.g,
            this.b = e.b,
            this
        },
        copyGammaToLinear: function(e, t) {
            return void 0 === t && (t = 2),
            this.r = Math.pow(e.r, t),
            this.g = Math.pow(e.g, t),
            this.b = Math.pow(e.b, t),
            this
        },
        copyLinearToGamma: function(e, t) {
            return t = 0 < (t = void 0 === t ? 2 : t) ? 1 / t : 1,
            this.r = Math.pow(e.r, t),
            this.g = Math.pow(e.g, t),
            this.b = Math.pow(e.b, t),
            this
        },
        convertGammaToLinear: function(e) {
            return this.copyGammaToLinear(this, e),
            this
        },
        convertLinearToGamma: function(e) {
            return this.copyLinearToGamma(this, e),
            this
        },
        copySRGBToLinear: function(e) {
            return this.r = co(e.r),
            this.g = co(e.g),
            this.b = co(e.b),
            this
        },
        copyLinearToSRGB: function(e) {
            return this.r = so(e.r),
            this.g = so(e.g),
            this.b = so(e.b),
            this
        },
        convertSRGBToLinear: function() {
            return this.copySRGBToLinear(this),
            this
        },
        convertLinearToSRGB: function() {
            return this.copyLinearToSRGB(this),
            this
        },
        getHex: function() {
            return 255 * this.r << 16 ^ 255 * this.g << 8 ^ 255 * this.b << 0
        },
        getHexString: function() {
            return ("000000" + this.getHex().toString(16)).slice(-6)
        },
        getHSL: function(e) {
            void 0 === e && (console.warn("THREE.Color: .getHSL() target is now required"),
            e = {
                h: 0,
                s: 0,
                l: 0
            });
            var t, i = this.r, n = this.g, r = this.b, a = Math.max(i, n, r), o = ((c = Math.min(i, n, r)) + a) / 2;
            if (c === a)
                c = t = 0;
            else {
                var s = a - c
                  , c = o <= .5 ? s / (a + c) : s / (2 - a - c);
                switch (a) {
                case i:
                    t = (n - r) / s + (n < r ? 6 : 0);
                    break;
                case n:
                    t = (r - i) / s + 2;
                    break;
                case r:
                    t = (i - n) / s + 4
                }
                t /= 6
            }
            return e.h = t,
            e.s = c,
            e.l = o,
            e
        },
        getStyle: function() {
            return "rgb(" + (255 * this.r | 0) + "," + (255 * this.g | 0) + "," + (255 * this.b | 0) + ")"
        },
        offsetHSL: (ro = {},
        function(e, t, i) {
            return this.getHSL(ro),
            ro.h += e,
            ro.s += t,
            ro.l += i,
            this.setHSL(ro.h, ro.s, ro.l),
            this
        }
        ),
        add: function(e) {
            return this.r += e.r,
            this.g += e.g,
            this.b += e.b,
            this
        },
        addColors: function(e, t) {
            return this.r = e.r + t.r,
            this.g = e.g + t.g,
            this.b = e.b + t.b,
            this
        },
        addScalar: function(e) {
            return this.r += e,
            this.g += e,
            this.b += e,
            this
        },
        sub: function(e) {
            return this.r = Math.max(0, this.r - e.r),
            this.g = Math.max(0, this.g - e.g),
            this.b = Math.max(0, this.b - e.b),
            this
        },
        multiply: function(e) {
            return this.r *= e.r,
            this.g *= e.g,
            this.b *= e.b,
            this
        },
        multiplyScalar: function(e) {
            return this.r *= e,
            this.g *= e,
            this.b *= e,
            this
        },
        lerp: function(e, t) {
            return this.r += (e.r - this.r) * t,
            this.g += (e.g - this.g) * t,
            this.b += (e.b - this.b) * t,
            this
        },
        lerpHSL: (io = {
            h: 0,
            s: 0,
            l: 0
        },
        no = {
            h: 0,
            s: 0,
            l: 0
        },
        function(e, t) {
            this.getHSL(io),
            e.getHSL(no),
            e = Se.lerp(io.h, no.h, t);
            var i = Se.lerp(io.s, no.s, t);
            return t = Se.lerp(io.l, no.l, t),
            this.setHSL(e, i, t),
            this
        }
        ),
        equals: function(e) {
            return e.r === this.r && e.g === this.g && e.b === this.b
        },
        fromArray: function(e, t) {
            return this.r = e[t = void 0 === t ? 0 : t],
            this.g = e[t + 1],
            this.b = e[t + 2],
            this
        },
        toArray: function(e, t) {
            return (e = void 0 === e ? [] : e)[t = void 0 === t ? 0 : t] = this.r,
            e[t + 1] = this.g,
            e[t + 2] = this.b,
            e
        },
        toJSON: function() {
            return this.getHex()
        }
    });
    var lo, uo, po, fo, mo, go, vo, yo, xo, bo, wo, _o, Mo, Eo, So, To, Ao, Lo, Po, Ro, Co, Oo, Io, Do, Bo, No, zo, Uo, Go, Fo, Ho, ko, Vo, jo, Wo, qo, Xo, Yo, Jo, Zo, Qo, Ko, $o, es, ts, is, ns, rs, as, os, ss, cs, hs, ls, us, ps, ds, fs, ms, gs, vs, ys, xs, bs, ws, _s, Ms, Es, Ss, Ts, As, Ls, Ps, Rs, Cs, Os, Te = {
        common: {
            diffuse: {
                value: new d(15658734)
            },
            opacity: {
                value: 1
            },
            map: {
                value: null
            },
            uvTransform: {
                value: new g
            },
            alphaMap: {
                value: null
            }
        },
        specularmap: {
            specularMap: {
                value: null
            }
        },
        envmap: {
            envMap: {
                value: null
            },
            flipEnvMap: {
                value: -1
            },
            reflectivity: {
                value: 1
            },
            refractionRatio: {
                value: .98
            },
            maxMipLevel: {
                value: 0
            }
        },
        aomap: {
            aoMap: {
                value: null
            },
            aoMapIntensity: {
                value: 1
            }
        },
        lightmap: {
            lightMap: {
                value: null
            },
            lightMapIntensity: {
                value: 1
            }
        },
        emissivemap: {
            emissiveMap: {
                value: null
            }
        },
        bumpmap: {
            bumpMap: {
                value: null
            },
            bumpScale: {
                value: 1
            }
        },
        normalmap: {
            normalMap: {
                value: null
            },
            normalScale: {
                value: new Y(1,1)
            }
        },
        displacementmap: {
            displacementMap: {
                value: null
            },
            displacementScale: {
                value: 1
            },
            displacementBias: {
                value: 0
            }
        },
        roughnessmap: {
            roughnessMap: {
                value: null
            }
        },
        metalnessmap: {
            metalnessMap: {
                value: null
            }
        },
        gradientmap: {
            gradientMap: {
                value: null
            }
        },
        fog: {
            fogDensity: {
                value: 25e-5
            },
            fogNear: {
                value: 1
            },
            fogFar: {
                value: 2e3
            },
            fogColor: {
                value: new d(16777215)
            }
        },
        lights: {
            ambientLightColor: {
                value: []
            },
            directionalLights: {
                value: [],
                properties: {
                    direction: {},
                    color: {},
                    shadow: {},
                    shadowBias: {},
                    shadowRadius: {},
                    shadowMapSize: {}
                }
            },
            directionalShadowMap: {
                value: []
            },
            directionalShadowMatrix: {
                value: []
            },
            spotLights: {
                value: [],
                properties: {
                    color: {},
                    position: {},
                    direction: {},
                    distance: {},
                    coneCos: {},
                    penumbraCos: {},
                    decay: {},
                    shadow: {},
                    shadowBias: {},
                    shadowRadius: {},
                    shadowMapSize: {}
                }
            },
            spotShadowMap: {
                value: []
            },
            spotShadowMatrix: {
                value: []
            },
            pointLights: {
                value: [],
                properties: {
                    color: {},
                    position: {},
                    decay: {},
                    distance: {},
                    shadow: {},
                    shadowBias: {},
                    shadowRadius: {},
                    shadowMapSize: {},
                    shadowCameraNear: {},
                    shadowCameraFar: {}
                }
            },
            pointShadowMap: {
                value: []
            },
            pointShadowMatrix: {
                value: []
            },
            hemisphereLights: {
                value: [],
                properties: {
                    direction: {},
                    skyColor: {},
                    groundColor: {}
                }
            },
            rectAreaLights: {
                value: [],
                properties: {
                    color: {},
                    position: {},
                    width: {},
                    height: {}
                }
            }
        },
        points: {
            diffuse: {
                value: new d(15658734)
            },
            opacity: {
                value: 1
            },
            size: {
                value: 1
            },
            scale: {
                value: 1
            },
            map: {
                value: null
            },
            uvTransform: {
                value: new g
            }
        },
        sprite: {
            diffuse: {
                value: new d(15658734)
            },
            opacity: {
                value: 1
            },
            center: {
                value: new Y(.5,.5)
            },
            rotation: {
                value: 0
            },
            map: {
                value: null
            },
            uvTransform: {
                value: new g
            }
        }
    }, Is = {
        basic: {
            uniforms: t([Te.common, Te.specularmap, Te.envmap, Te.aomap, Te.lightmap, Te.fog]),
            vertexShader: T.meshbasic_vert,
            fragmentShader: T.meshbasic_frag
        },
        lambert: {
            uniforms: t([Te.common, Te.specularmap, Te.envmap, Te.aomap, Te.lightmap, Te.emissivemap, Te.fog, Te.lights, {
                emissive: {
                    value: new d(0)
                }
            }]),
            vertexShader: T.meshlambert_vert,
            fragmentShader: T.meshlambert_frag
        },
        phong: {
            uniforms: t([Te.common, Te.specularmap, Te.envmap, Te.aomap, Te.lightmap, Te.emissivemap, Te.bumpmap, Te.normalmap, Te.displacementmap, Te.gradientmap, Te.fog, Te.lights, {
                emissive: {
                    value: new d(0)
                },
                specular: {
                    value: new d(1118481)
                },
                shininess: {
                    value: 30
                }
            }]),
            vertexShader: T.meshphong_vert,
            fragmentShader: T.meshphong_frag
        },
        standard: {
            uniforms: t([Te.common, Te.envmap, Te.aomap, Te.lightmap, Te.emissivemap, Te.bumpmap, Te.normalmap, Te.displacementmap, Te.roughnessmap, Te.metalnessmap, Te.fog, Te.lights, {
                emissive: {
                    value: new d(0)
                },
                roughness: {
                    value: .5
                },
                metalness: {
                    value: .5
                },
                envMapIntensity: {
                    value: 1
                }
            }]),
            vertexShader: T.meshphysical_vert,
            fragmentShader: T.meshphysical_frag
        },
        matcap: {
            uniforms: t([Te.common, Te.bumpmap, Te.normalmap, Te.displacementmap, Te.fog, {
                matcap: {
                    value: null
                }
            }]),
            vertexShader: T.meshmatcap_vert,
            fragmentShader: T.meshmatcap_frag
        },
        points: {
            uniforms: t([Te.points, Te.fog]),
            vertexShader: T.points_vert,
            fragmentShader: T.points_frag
        },
        dashed: {
            uniforms: t([Te.common, Te.fog, {
                scale: {
                    value: 1
                },
                dashSize: {
                    value: 1
                },
                totalSize: {
                    value: 2
                }
            }]),
            vertexShader: T.linedashed_vert,
            fragmentShader: T.linedashed_frag
        },
        depth: {
            uniforms: t([Te.common, Te.displacementmap]),
            vertexShader: T.depth_vert,
            fragmentShader: T.depth_frag
        },
        normal: {
            uniforms: t([Te.common, Te.bumpmap, Te.normalmap, Te.displacementmap, {
                opacity: {
                    value: 1
                }
            }]),
            vertexShader: T.normal_vert,
            fragmentShader: T.normal_frag
        },
        sprite: {
            uniforms: t([Te.sprite, Te.fog]),
            vertexShader: T.sprite_vert,
            fragmentShader: T.sprite_frag
        },
        background: {
            uniforms: {
                uvTransform: {
                    value: new g
                },
                t2D: {
                    value: null
                }
            },
            vertexShader: T.background_vert,
            fragmentShader: T.background_frag
        },
        cube: {
            uniforms: {
                tCube: {
                    value: null
                },
                tFlip: {
                    value: -1
                },
                opacity: {
                    value: 1
                }
            },
            vertexShader: T.cube_vert,
            fragmentShader: T.cube_frag
        },
        equirect: {
            uniforms: {
                tEquirect: {
                    value: null
                }
            },
            vertexShader: T.equirect_vert,
            fragmentShader: T.equirect_frag
        },
        distanceRGBA: {
            uniforms: t([Te.common, Te.displacementmap, {
                referencePosition: {
                    value: new Me
                },
                nearDistance: {
                    value: 1
                },
                farDistance: {
                    value: 1e3
                }
            }]),
            vertexShader: T.distanceRGBA_vert,
            fragmentShader: T.distanceRGBA_frag
        },
        shadow: {
            uniforms: t([Te.lights, Te.fog, {
                color: {
                    value: new d(0)
                },
                opacity: {
                    value: 1
                }
            }]),
            vertexShader: T.shadow_vert,
            fragmentShader: T.shadow_frag
        }
    }, Ds = (Is.physical = {
        uniforms: t([Is.standard.uniforms, {
            clearCoat: {
                value: 0
            },
            clearCoatRoughness: {
                value: 0
            }
        }]),
        vertexShader: T.meshphysical_vert,
        fragmentShader: T.meshphysical_frag
    },
    Object.assign(B.prototype, {
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(e) {
            this.a = e.a,
            this.b = e.b,
            this.c = e.c,
            this.normal.copy(e.normal),
            this.color.copy(e.color),
            this.materialIndex = e.materialIndex;
            for (var t = 0, i = e.vertexNormals.length; t < i; t++)
                this.vertexNormals[t] = e.vertexNormals[t].clone();
            for (t = 0,
            i = e.vertexColors.length; t < i; t++)
                this.vertexColors[t] = e.vertexColors[t].clone();
            return this
        }
    }),
    N.RotationOrders = "XYZ YZX ZXY XZY YXZ ZYX".split(" "),
    N.DefaultOrder = "XYZ",
    Object.defineProperties(N.prototype, {
        x: {
            get: function() {
                return this._x
            },
            set: function(e) {
                this._x = e,
                this.onChangeCallback()
            }
        },
        y: {
            get: function() {
                return this._y
            },
            set: function(e) {
                this._y = e,
                this.onChangeCallback()
            }
        },
        z: {
            get: function() {
                return this._z
            },
            set: function(e) {
                this._z = e,
                this.onChangeCallback()
            }
        },
        order: {
            get: function() {
                return this._order
            },
            set: function(e) {
                this._order = e,
                this.onChangeCallback()
            }
        }
    }),
    Object.assign(N.prototype, {
        isEuler: !0,
        set: function(e, t, i, n) {
            return this._x = e,
            this._y = t,
            this._z = i,
            this._order = n || this._order,
            this.onChangeCallback(),
            this
        },
        clone: function() {
            return new this.constructor(this._x,this._y,this._z,this._order)
        },
        copy: function(e) {
            return this._x = e._x,
            this._y = e._y,
            this._z = e._z,
            this._order = e._order,
            this.onChangeCallback(),
            this
        },
        setFromRotationMatrix: function(e, t, i) {
            var n = Se.clamp
              , r = (e = (u = e.elements)[0],
            u[4])
              , a = u[8]
              , o = u[1]
              , s = u[5]
              , c = u[9]
              , h = u[2]
              , l = u[6]
              , u = u[10];
            return "XYZ" === (t = t || this._order) ? (this._y = Math.asin(n(a, -1, 1)),
            Math.abs(a) < .99999 ? (this._x = Math.atan2(-c, u),
            this._z = Math.atan2(-r, e)) : (this._x = Math.atan2(l, s),
            this._z = 0)) : "YXZ" === t ? (this._x = Math.asin(-n(c, -1, 1)),
            Math.abs(c) < .99999 ? (this._y = Math.atan2(a, u),
            this._z = Math.atan2(o, s)) : (this._y = Math.atan2(-h, e),
            this._z = 0)) : "ZXY" === t ? (this._x = Math.asin(n(l, -1, 1)),
            Math.abs(l) < .99999 ? (this._y = Math.atan2(-h, u),
            this._z = Math.atan2(-r, s)) : (this._y = 0,
            this._z = Math.atan2(o, e))) : "ZYX" === t ? (this._y = Math.asin(-n(h, -1, 1)),
            Math.abs(h) < .99999 ? (this._x = Math.atan2(l, u),
            this._z = Math.atan2(o, e)) : (this._x = 0,
            this._z = Math.atan2(-r, s))) : "YZX" === t ? (this._z = Math.asin(n(o, -1, 1)),
            Math.abs(o) < .99999 ? (this._x = Math.atan2(-c, s),
            this._y = Math.atan2(-h, e)) : (this._x = 0,
            this._y = Math.atan2(a, u))) : "XZY" === t ? (this._z = Math.asin(-n(r, -1, 1)),
            Math.abs(r) < .99999 ? (this._x = Math.atan2(l, s),
            this._y = Math.atan2(a, e)) : (this._x = Math.atan2(-c, u),
            this._y = 0)) : console.warn("THREE.Euler: .setFromRotationMatrix() given unsupported order: " + t),
            this._order = t,
            !1 !== i && this.onChangeCallback(),
            this
        },
        setFromQuaternion: (uo = new _e,
        function(e, t, i) {
            return uo.makeRotationFromQuaternion(e),
            this.setFromRotationMatrix(uo, t, i)
        }
        ),
        setFromVector3: function(e, t) {
            return this.set(e.x, e.y, e.z, t || this._order)
        },
        reorder: (lo = new M,
        function(e) {
            return lo.setFromEuler(this),
            this.setFromQuaternion(lo, e)
        }
        ),
        equals: function(e) {
            return e._x === this._x && e._y === this._y && e._z === this._z && e._order === this._order
        },
        fromArray: function(e) {
            return this._x = e[0],
            this._y = e[1],
            this._z = e[2],
            void 0 !== e[3] && (this._order = e[3]),
            this.onChangeCallback(),
            this
        },
        toArray: function(e, t) {
            return (e = void 0 === e ? [] : e)[t = void 0 === t ? 0 : t] = this._x,
            e[t + 1] = this._y,
            e[t + 2] = this._z,
            e[t + 3] = this._order,
            e
        },
        toVector3: function(e) {
            return e ? e.set(this._x, this._y, this._z) : new Me(this._x,this._y,this._z)
        },
        onChange: function(e) {
            return this.onChangeCallback = e,
            this
        },
        onChangeCallback: function() {}
    }),
    Object.assign(G.prototype, {
        set: function(e) {
            this.mask = 1 << e | 0
        },
        enable: function(e) {
            this.mask = this.mask | 1 << e | 0
        },
        toggle: function(e) {
            this.mask ^= 1 << e | 0
        },
        disable: function(e) {
            this.mask &= ~(1 << e | 0)
        },
        test: function(e) {
            return 0 != (this.mask & e.mask)
        }
    }),
    0), Bs = (u.DefaultUp = new Me(0,1,0),
    u.DefaultMatrixAutoUpdate = !0,
    u.prototype = Object.assign(Object.create(L.prototype), {
        constructor: u,
        isObject3D: !0,
        onBeforeRender: function() {},
        onAfterRender: function() {},
        applyMatrix: function(e) {
            this.matrix.multiplyMatrices(e, this.matrix),
            this.matrix.decompose(this.position, this.quaternion, this.scale)
        },
        applyQuaternion: function(e) {
            return this.quaternion.premultiply(e),
            this
        },
        setRotationFromAxisAngle: function(e, t) {
            this.quaternion.setFromAxisAngle(e, t)
        },
        setRotationFromEuler: function(e) {
            this.quaternion.setFromEuler(e, !0)
        },
        setRotationFromMatrix: function(e) {
            this.quaternion.setFromRotationMatrix(e)
        },
        setRotationFromQuaternion: function(e) {
            this.quaternion.copy(e)
        },
        rotateOnAxis: (Ro = new M,
        function(e, t) {
            return Ro.setFromAxisAngle(e, t),
            this.quaternion.multiply(Ro),
            this
        }
        ),
        rotateOnWorldAxis: (Po = new M,
        function(e, t) {
            return Po.setFromAxisAngle(e, t),
            this.quaternion.premultiply(Po),
            this
        }
        ),
        rotateX: (Lo = new Me(1,0,0),
        function(e) {
            return this.rotateOnAxis(Lo, e)
        }
        ),
        rotateY: (Ao = new Me(0,1,0),
        function(e) {
            return this.rotateOnAxis(Ao, e)
        }
        ),
        rotateZ: (To = new Me(0,0,1),
        function(e) {
            return this.rotateOnAxis(To, e)
        }
        ),
        translateOnAxis: (So = new Me,
        function(e, t) {
            return So.copy(e).applyQuaternion(this.quaternion),
            this.position.add(So.multiplyScalar(t)),
            this
        }
        ),
        translateX: (Eo = new Me(1,0,0),
        function(e) {
            return this.translateOnAxis(Eo, e)
        }
        ),
        translateY: (Mo = new Me(0,1,0),
        function(e) {
            return this.translateOnAxis(Mo, e)
        }
        ),
        translateZ: (_o = new Me(0,0,1),
        function(e) {
            return this.translateOnAxis(_o, e)
        }
        ),
        localToWorld: function(e) {
            return e.applyMatrix4(this.matrixWorld)
        },
        worldToLocal: (wo = new _e,
        function(e) {
            return e.applyMatrix4(wo.getInverse(this.matrixWorld))
        }
        ),
        lookAt: (vo = new M,
        yo = new _e,
        xo = new Me,
        bo = new Me,
        function(e, t, i) {
            e.isVector3 ? xo.copy(e) : xo.set(e, t, i),
            e = this.parent,
            this.updateWorldMatrix(!0, !1),
            bo.setFromMatrixPosition(this.matrixWorld),
            this.isCamera || this.isLight ? yo.lookAt(bo, xo, this.up) : yo.lookAt(xo, bo, this.up),
            this.quaternion.setFromRotationMatrix(yo),
            e && (yo.extractRotation(e.matrixWorld),
            vo.setFromRotationMatrix(yo),
            this.quaternion.premultiply(vo.inverse()))
        }
        ),
        add: function(e) {
            if (1 < arguments.length)
                for (var t = 0; t < arguments.length; t++)
                    this.add(arguments[t]);
            else
                e === this ? console.error("THREE.Object3D.add: object can't be added as a child of itself.", e) : e && e.isObject3D ? (null !== e.parent && e.parent.remove(e),
                e.parent = this,
                e.dispatchEvent({
                    type: "added"
                }),
                this.children.push(e)) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", e);
            return this
        },
        remove: function(e) {
            if (1 < arguments.length)
                for (var t = 0; t < arguments.length; t++)
                    this.remove(arguments[t]);
            else
                -1 !== (t = this.children.indexOf(e)) && (e.parent = null,
                e.dispatchEvent({
                    type: "removed"
                }),
                this.children.splice(t, 1));
            return this
        },
        getObjectById: function(e) {
            return this.getObjectByProperty("id", e)
        },
        getObjectByName: function(e) {
            return this.getObjectByProperty("name", e)
        },
        getObjectByProperty: function(e, t) {
            if (this[e] === t)
                return this;
            for (var i = 0, n = this.children.length; i < n; i++) {
                var r = this.children[i].getObjectByProperty(e, t);
                if (void 0 !== r)
                    return r
            }
        },
        getWorldPosition: function(e) {
            return void 0 === e && (console.warn("THREE.Object3D: .getWorldPosition() target is now required"),
            e = new Me),
            this.updateMatrixWorld(!0),
            e.setFromMatrixPosition(this.matrixWorld)
        },
        getWorldQuaternion: (mo = new Me,
        go = new Me,
        function(e) {
            return void 0 === e && (console.warn("THREE.Object3D: .getWorldQuaternion() target is now required"),
            e = new M),
            this.updateMatrixWorld(!0),
            this.matrixWorld.decompose(mo, e, go),
            e
        }
        ),
        getWorldScale: (po = new Me,
        fo = new M,
        function(e) {
            return void 0 === e && (console.warn("THREE.Object3D: .getWorldScale() target is now required"),
            e = new Me),
            this.updateMatrixWorld(!0),
            this.matrixWorld.decompose(po, fo, e),
            e
        }
        ),
        getWorldDirection: function(e) {
            void 0 === e && (console.warn("THREE.Object3D: .getWorldDirection() target is now required"),
            e = new Me),
            this.updateMatrixWorld(!0);
            var t = this.matrixWorld.elements;
            return e.set(t[8], t[9], t[10]).normalize()
        },
        raycast: function() {},
        traverse: function(e) {
            e(this);
            for (var t = this.children, i = 0, n = t.length; i < n; i++)
                t[i].traverse(e)
        },
        traverseVisible: function(e) {
            if (!1 !== this.visible) {
                e(this);
                for (var t = this.children, i = 0, n = t.length; i < n; i++)
                    t[i].traverseVisible(e)
            }
        },
        traverseAncestors: function(e) {
            var t = this.parent;
            null !== t && (e(t),
            t.traverseAncestors(e))
        },
        updateMatrix: function() {
            this.matrix.compose(this.position, this.quaternion, this.scale),
            this.matrixWorldNeedsUpdate = !0
        },
        updateMatrixWorld: function(e) {
            this.matrixAutoUpdate && this.updateMatrix(),
            (this.matrixWorldNeedsUpdate || e) && (null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix),
            e = !(this.matrixWorldNeedsUpdate = !1));
            for (var t = this.children, i = 0, n = t.length; i < n; i++)
                t[i].updateMatrixWorld(e)
        },
        updateWorldMatrix: function(e, t) {
            var i = this.parent;
            if (!0 === e && null !== i && i.updateWorldMatrix(!0, !1),
            this.matrixAutoUpdate && this.updateMatrix(),
            null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix),
            !0 === t)
                for (t = 0,
                i = (e = this.children).length; t < i; t++)
                    e[t].updateWorldMatrix(!1, !0)
        },
        toJSON: function(i) {
            function e(e, t) {
                return void 0 === e[t.uuid] && (e[t.uuid] = t.toJSON(i)),
                t.uuid
            }
            function t(e) {
                var t, i = [];
                for (t in e) {
                    var n = e[t];
                    delete n.metadata,
                    i.push(n)
                }
                return i
            }
            var n, r = void 0 === i || "string" == typeof i, a = {}, o = (r && (i = {
                geometries: {},
                materials: {},
                textures: {},
                images: {},
                shapes: {}
            },
            a.metadata = {
                version: 4.5,
                type: "Object",
                generator: "Object3D.toJSON"
            }),
            {});
            if (o.uuid = this.uuid,
            o.type = this.type,
            "" !== this.name && (o.name = this.name),
            !0 === this.castShadow && (o.castShadow = !0),
            !0 === this.receiveShadow && (o.receiveShadow = !0),
            !1 === this.visible && (o.visible = !1),
            !1 === this.frustumCulled && (o.frustumCulled = !1),
            0 !== this.renderOrder && (o.renderOrder = this.renderOrder),
            "{}" !== JSON.stringify(this.userData) && (o.userData = this.userData),
            o.layers = this.layers.mask,
            o.matrix = this.matrix.toArray(),
            !1 === this.matrixAutoUpdate && (o.matrixAutoUpdate = !1),
            this.isMesh && 0 !== this.drawMode && (o.drawMode = this.drawMode),
            this.isMesh || this.isLine || this.isPoints) {
                o.geometry = e(i.geometries, this.geometry);
                var s = this.geometry.parameters;
                if (void 0 !== s && void 0 !== s.shapes)
                    if (s = s.shapes,
                    Array.isArray(s))
                        for (var c = 0, h = s.length; c < h; c++)
                            e(i.shapes, s[c]);
                    else
                        e(i.shapes, s)
            }
            if (void 0 !== this.material)
                if (Array.isArray(this.material)) {
                    for (s = [],
                    c = 0,
                    h = this.material.length; c < h; c++)
                        s.push(e(i.materials, this.material[c]));
                    o.material = s
                } else
                    o.material = e(i.materials, this.material);
            if (0 < this.children.length)
                for (o.children = [],
                c = 0; c < this.children.length; c++)
                    o.children.push(this.children[c].toJSON(i).object);
            return r && (r = t(i.geometries),
            c = t(i.materials),
            h = t(i.textures),
            n = t(i.images),
            s = t(i.shapes),
            0 < r.length && (a.geometries = r),
            0 < c.length && (a.materials = c),
            0 < h.length && (a.textures = h),
            0 < n.length && (a.images = n),
            0 < s.length) && (a.shapes = s),
            a.object = o,
            a
        },
        clone: function(e) {
            return (new this.constructor).copy(this, e)
        },
        copy: function(e, t) {
            if (void 0 === t && (t = !0),
            this.name = e.name,
            this.up.copy(e.up),
            this.position.copy(e.position),
            this.quaternion.copy(e.quaternion),
            this.scale.copy(e.scale),
            this.matrix.copy(e.matrix),
            this.matrixWorld.copy(e.matrixWorld),
            this.matrixAutoUpdate = e.matrixAutoUpdate,
            this.matrixWorldNeedsUpdate = e.matrixWorldNeedsUpdate,
            this.layers.mask = e.layers.mask,
            this.visible = e.visible,
            this.castShadow = e.castShadow,
            this.receiveShadow = e.receiveShadow,
            this.frustumCulled = e.frustumCulled,
            this.renderOrder = e.renderOrder,
            this.userData = JSON.parse(JSON.stringify(e.userData)),
            !0 === t)
                for (t = 0; t < e.children.length; t++)
                    this.add(e.children[t].clone());
            return this
        }
    }),
    0), Ns = (f.prototype = Object.assign(Object.create(L.prototype), {
        constructor: f,
        isGeometry: !0,
        applyMatrix: function(e) {
            for (var t = (new g).getNormalMatrix(e), i = 0, n = this.vertices.length; i < n; i++)
                this.vertices[i].applyMatrix4(e);
            for (i = 0,
            n = this.faces.length; i < n; i++) {
                (e = this.faces[i]).normal.applyMatrix3(t).normalize();
                for (var r = 0, a = e.vertexNormals.length; r < a; r++)
                    e.vertexNormals[r].applyMatrix3(t).normalize()
            }
            return null !== this.boundingBox && this.computeBoundingBox(),
            null !== this.boundingSphere && this.computeBoundingSphere(),
            this.normalsNeedUpdate = this.verticesNeedUpdate = !0,
            this
        },
        rotateX: (zo = new _e,
        function(e) {
            return zo.makeRotationX(e),
            this.applyMatrix(zo),
            this
        }
        ),
        rotateY: (No = new _e,
        function(e) {
            return No.makeRotationY(e),
            this.applyMatrix(No),
            this
        }
        ),
        rotateZ: (Bo = new _e,
        function(e) {
            return Bo.makeRotationZ(e),
            this.applyMatrix(Bo),
            this
        }
        ),
        translate: (Do = new _e,
        function(e, t, i) {
            return Do.makeTranslation(e, t, i),
            this.applyMatrix(Do),
            this
        }
        ),
        scale: (Io = new _e,
        function(e, t, i) {
            return Io.makeScale(e, t, i),
            this.applyMatrix(Io),
            this
        }
        ),
        lookAt: (Oo = new u,
        function(e) {
            Oo.lookAt(e),
            Oo.updateMatrix(),
            this.applyMatrix(Oo.matrix)
        }
        ),
        fromBufferGeometry: function(e) {
            function t(e, t, i, n) {
                var r = void 0 === s ? [] : [a.colors[e].clone(), a.colors[t].clone(), a.colors[i].clone()];
                n = new B(e,t,i,void 0 === o ? [] : [(new Me).fromArray(o, 3 * e), (new Me).fromArray(o, 3 * t), (new Me).fromArray(o, 3 * i)],r,n),
                a.faces.push(n),
                void 0 !== c && a.faceVertexUvs[0].push([(new Y).fromArray(c, 2 * e), (new Y).fromArray(c, 2 * t), (new Y).fromArray(c, 2 * i)]),
                void 0 !== h && a.faceVertexUvs[1].push([(new Y).fromArray(h, 2 * e), (new Y).fromArray(h, 2 * t), (new Y).fromArray(h, 2 * i)])
            }
            var a = this
              , i = null !== e.index ? e.index.array : void 0
              , n = e.attributes
              , r = n.position.array
              , o = void 0 !== n.normal ? n.normal.array : void 0
              , s = void 0 !== n.color ? n.color.array : void 0
              , c = void 0 !== n.uv ? n.uv.array : void 0
              , h = void 0 !== n.uv2 ? n.uv2.array : void 0;
            void 0 !== h && (this.faceVertexUvs[1] = []);
            for (var l = n = 0; n < r.length; n += 3,
            l += 2)
                a.vertices.push((new Me).fromArray(r, n)),
                void 0 !== s && a.colors.push((new d).fromArray(s, n));
            var u = e.groups;
            if (0 < u.length)
                for (n = 0; n < u.length; n++) {
                    var p = (r = u[n]).start
                      , l = p;
                    for (p += r.count; l < p; l += 3)
                        void 0 !== i ? t(i[l], i[l + 1], i[l + 2], r.materialIndex) : t(l, l + 1, l + 2, r.materialIndex)
                }
            else if (void 0 !== i)
                for (n = 0; n < i.length; n += 3)
                    t(i[n], i[n + 1], i[n + 2]);
            else
                for (n = 0; n < r.length / 3; n += 3)
                    t(n, n + 1, n + 2);
            return this.computeFaceNormals(),
            null !== e.boundingBox && (this.boundingBox = e.boundingBox.clone()),
            null !== e.boundingSphere && (this.boundingSphere = e.boundingSphere.clone()),
            this
        },
        center: (Co = new Me,
        function() {
            return this.computeBoundingBox(),
            this.boundingBox.getCenter(Co).negate(),
            this.translate(Co.x, Co.y, Co.z),
            this
        }
        ),
        normalize: function() {
            this.computeBoundingSphere();
            var e = this.boundingSphere.center
              , t = 0 === (t = this.boundingSphere.radius) ? 1 : 1 / t
              , i = new _e;
            return i.set(t, 0, 0, -t * e.x, 0, t, 0, -t * e.y, 0, 0, t, -t * e.z, 0, 0, 0, 1),
            this.applyMatrix(i),
            this
        },
        computeFaceNormals: function() {
            for (var e = new Me, t = new Me, i = 0, n = this.faces.length; i < n; i++) {
                var r = this.faces[i]
                  , a = this.vertices[r.a]
                  , o = this.vertices[r.b];
                e.subVectors(this.vertices[r.c], o),
                t.subVectors(a, o),
                e.cross(t),
                e.normalize(),
                r.normal.copy(e)
            }
        },
        computeVertexNormals: function(e) {
            void 0 === e && (e = !0);
            var t = Array(this.vertices.length)
              , i = 0;
            for (a = this.vertices.length; i < a; i++)
                t[i] = new Me;
            if (e) {
                var n = new Me
                  , r = new Me;
                for (e = 0,
                i = this.faces.length; e < i; e++) {
                    var a = this.faces[e]
                      , o = this.vertices[a.a]
                      , s = this.vertices[a.b]
                      , c = this.vertices[a.c];
                    n.subVectors(c, s),
                    r.subVectors(o, s),
                    n.cross(r),
                    t[a.a].add(n),
                    t[a.b].add(n),
                    t[a.c].add(n)
                }
            } else
                for (this.computeFaceNormals(),
                e = 0,
                i = this.faces.length; e < i; e++)
                    t[(a = this.faces[e]).a].add(a.normal),
                    t[a.b].add(a.normal),
                    t[a.c].add(a.normal);
            for (i = 0,
            a = this.vertices.length; i < a; i++)
                t[i].normalize();
            for (e = 0,
            i = this.faces.length; e < i; e++)
                3 === (o = (a = this.faces[e]).vertexNormals).length ? (o[0].copy(t[a.a]),
                o[1].copy(t[a.b]),
                o[2].copy(t[a.c])) : (o[0] = t[a.a].clone(),
                o[1] = t[a.b].clone(),
                o[2] = t[a.c].clone());
            0 < this.faces.length && (this.normalsNeedUpdate = !0)
        },
        computeFlatVertexNormals: function() {
            this.computeFaceNormals();
            for (var e = 0, t = this.faces.length; e < t; e++) {
                var i = this.faces[e]
                  , n = i.vertexNormals;
                3 === n.length ? (n[0].copy(i.normal),
                n[1].copy(i.normal),
                n[2].copy(i.normal)) : (n[0] = i.normal.clone(),
                n[1] = i.normal.clone(),
                n[2] = i.normal.clone())
            }
            0 < this.faces.length && (this.normalsNeedUpdate = !0)
        },
        computeMorphNormals: function() {
            var e = 0;
            for (o = this.faces.length; e < o; e++) {
                (r = this.faces[e]).__originalFaceNormal ? r.__originalFaceNormal.copy(r.normal) : r.__originalFaceNormal = r.normal.clone(),
                r.__originalVertexNormals || (r.__originalVertexNormals = []);
                for (var t = 0, i = r.vertexNormals.length; t < i; t++)
                    r.__originalVertexNormals[t] ? r.__originalVertexNormals[t].copy(r.vertexNormals[t]) : r.__originalVertexNormals[t] = r.vertexNormals[t].clone()
            }
            var n = new f;
            for (n.faces = this.faces,
            t = 0,
            i = this.morphTargets.length; t < i; t++) {
                if (!this.morphNormals[t]) {
                    this.morphNormals[t] = {},
                    this.morphNormals[t].faceNormals = [],
                    this.morphNormals[t].vertexNormals = [];
                    for (var r = this.morphNormals[t].faceNormals, a = this.morphNormals[t].vertexNormals, e = 0, o = this.faces.length; e < o; e++) {
                        var s = new Me
                          , c = {
                            a: new Me,
                            b: new Me,
                            c: new Me
                        };
                        r.push(s),
                        a.push(c)
                    }
                }
                for (a = this.morphNormals[t],
                n.vertices = this.morphTargets[t].vertices,
                n.computeFaceNormals(),
                n.computeVertexNormals(),
                e = 0,
                o = this.faces.length; e < o; e++)
                    r = this.faces[e],
                    s = a.faceNormals[e],
                    c = a.vertexNormals[e],
                    s.copy(r.normal),
                    c.a.copy(r.vertexNormals[0]),
                    c.b.copy(r.vertexNormals[1]),
                    c.c.copy(r.vertexNormals[2])
            }
            for (e = 0,
            o = this.faces.length; e < o; e++)
                (r = this.faces[e]).normal = r.__originalFaceNormal,
                r.vertexNormals = r.__originalVertexNormals
        },
        computeBoundingBox: function() {
            null === this.boundingBox && (this.boundingBox = new O),
            this.boundingBox.setFromPoints(this.vertices)
        },
        computeBoundingSphere: function() {
            null === this.boundingSphere && (this.boundingSphere = new I),
            this.boundingSphere.setFromPoints(this.vertices)
        },
        merge: function(e, t, i) {
            if (e && e.isGeometry) {
                var n, r = this.vertices.length, a = this.vertices, o = e.vertices, s = this.faces, c = e.faces, h = this.faceVertexUvs[0], l = e.faceVertexUvs[0], u = this.colors, p = e.colors;
                void 0 === i && (i = 0),
                void 0 !== t && (n = (new g).getNormalMatrix(t)),
                e = 0;
                for (var d = o.length; e < d; e++) {
                    var f = o[e].clone();
                    void 0 !== t && f.applyMatrix4(t),
                    a.push(f)
                }
                for (e = 0,
                d = p.length; e < d; e++)
                    u.push(p[e].clone());
                for (e = 0,
                d = c.length; e < d; e++) {
                    var m = (o = c[e]).vertexNormals
                      , p = o.vertexColors;
                    for ((u = new B(o.a + r,o.b + r,o.c + r)).normal.copy(o.normal),
                    void 0 !== n && u.normal.applyMatrix3(n).normalize(),
                    t = 0,
                    a = m.length; t < a; t++)
                        f = m[t].clone(),
                        void 0 !== n && f.applyMatrix3(n).normalize(),
                        u.vertexNormals.push(f);
                    for (u.color.copy(o.color),
                    t = 0,
                    a = p.length; t < a; t++)
                        f = p[t],
                        u.vertexColors.push(f.clone());
                    u.materialIndex = o.materialIndex + i,
                    s.push(u)
                }
                for (e = 0,
                d = l.length; e < d; e++)
                    if (n = [],
                    void 0 !== (i = l[e])) {
                        for (t = 0,
                        a = i.length; t < a; t++)
                            n.push(i[t].clone());
                        h.push(n)
                    }
            } else
                console.error("THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.", e)
        },
        mergeMesh: function(e) {
            e && e.isMesh ? (e.matrixAutoUpdate && e.updateMatrix(),
            this.merge(e.geometry, e.matrix)) : console.error("THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.", e)
        },
        mergeVertices: function() {
            for (var e = {}, t = [], i = [], n = Math.pow(10, 4), r = 0, a = this.vertices.length; r < a; r++) {
                var o = this.vertices[r];
                void 0 === e[o = Math.round(o.x * n) + "_" + Math.round(o.y * n) + "_" + Math.round(o.z * n)] ? (e[o] = r,
                t.push(this.vertices[r]),
                i[r] = t.length - 1) : i[r] = i[e[o]]
            }
            for (e = [],
            r = 0,
            a = this.faces.length; r < a; r++)
                for ((n = this.faces[r]).a = i[n.a],
                n.b = i[n.b],
                n.c = i[n.c],
                n = [n.a, n.b, n.c],
                o = 0; o < 3; o++)
                    if (n[o] === n[(o + 1) % 3]) {
                        e.push(r);
                        break
                    }
            for (r = e.length - 1; 0 <= r; r--)
                for (n = e[r],
                this.faces.splice(n, 1),
                i = 0,
                a = this.faceVertexUvs.length; i < a; i++)
                    this.faceVertexUvs[i].splice(n, 1);
            return r = this.vertices.length - t.length,
            this.vertices = t,
            r
        },
        setFromPoints: function(e) {
            this.vertices = [];
            for (var t = 0, i = e.length; t < i; t++) {
                var n = e[t];
                this.vertices.push(new Me(n.x,n.y,n.z || 0))
            }
            return this
        },
        sortFacesByMaterialIndex: function() {
            for (var e = this.faces, t = e.length, i = 0; i < t; i++)
                e[i]._id = i;
            e.sort(function(e, t) {
                return e.materialIndex - t.materialIndex
            });
            var n, r, a = this.faceVertexUvs[0], o = this.faceVertexUvs[1];
            for (a && a.length === t && (n = []),
            o && o.length === t && (r = []),
            i = 0; i < t; i++) {
                var s = e[i]._id;
                n && n.push(a[s]),
                r && r.push(o[s])
            }
            n && (this.faceVertexUvs[0] = n),
            r && (this.faceVertexUvs[1] = r)
        },
        toJSON: function() {
            function e(e, t, i) {
                return i ? e | 1 << t : e & ~(1 << t)
            }
            function t(e) {
                var t = e.x.toString() + e.y.toString() + e.z.toString();
                return void 0 === c[t] && (c[t] = s.length / 3,
                s.push(e.x, e.y, e.z)),
                c[t]
            }
            function i(e) {
                var t = e.r.toString() + e.g.toString() + e.b.toString();
                return void 0 === l[t] && (l[t] = h.length,
                h.push(e.getHex())),
                l[t]
            }
            function n(e) {
                var t = e.x.toString() + e.y.toString();
                return void 0 === p[t] && (p[t] = u.length / 2,
                u.push(e.x, e.y)),
                p[t]
            }
            var r = {
                metadata: {
                    version: 4.5,
                    type: "Geometry",
                    generator: "Geometry.toJSON"
                }
            };
            if (r.uuid = this.uuid,
            r.type = this.type,
            "" !== this.name && (r.name = this.name),
            void 0 !== this.parameters) {
                var a = this.parameters;
                for (d in a)
                    void 0 !== a[d] && (r[d] = a[d])
            } else {
                for (a = [],
                d = 0; d < this.vertices.length; d++) {
                    var o = this.vertices[d];
                    a.push(o.x, o.y, o.z)
                }
                for (var o = [], s = [], c = {}, h = [], l = {}, u = [], p = {}, d = 0; d < this.faces.length; d++) {
                    var f, m = this.faces[d], g = void 0 !== this.faceVertexUvs[0][d], v = 0 < m.normal.length(), y = 0 < m.vertexNormals.length, x = 1 !== m.color.r || 1 !== m.color.g || 1 !== m.color.b, b = 0 < m.vertexColors.length;
                    f = e(2, 3, g),
                    f = e(f, 4, v),
                    f = e(f, 5, y),
                    f = e(f, 6, x),
                    f = e(f, 7, b),
                    o.push(f),
                    o.push(m.a, m.b, m.c),
                    o.push(m.materialIndex),
                    g && (g = this.faceVertexUvs[0][d],
                    o.push(n(g[0]), n(g[1]), n(g[2]))),
                    v && o.push(t(m.normal)),
                    y && (v = m.vertexNormals,
                    o.push(t(v[0]), t(v[1]), t(v[2]))),
                    x && o.push(i(m.color)),
                    b && (m = m.vertexColors,
                    o.push(i(m[0]), i(m[1]), i(m[2])))
                }
                r.data = {},
                r.data.vertices = a,
                r.data.normals = s,
                0 < h.length && (r.data.colors = h),
                0 < u.length && (r.data.uvs = [u]),
                r.data.faces = o
            }
            return r
        },
        clone: function() {
            return (new f).copy(this)
        },
        copy: function(e) {
            this.vertices = [],
            this.colors = [],
            this.faces = [],
            this.faceVertexUvs = [[]],
            this.morphTargets = [],
            this.morphNormals = [],
            this.skinWeights = [],
            this.skinIndices = [],
            this.lineDistances = [],
            this.boundingSphere = this.boundingBox = null,
            this.name = e.name;
            for (var t, i = e.vertices, n = 0, r = i.length; n < r; n++)
                this.vertices.push(i[n].clone());
            for (n = 0,
            r = (i = e.colors).length; n < r; n++)
                this.colors.push(i[n].clone());
            for (n = 0,
            r = (i = e.faces).length; n < r; n++)
                this.faces.push(i[n].clone());
            for (n = 0,
            r = e.faceVertexUvs.length; n < r; n++) {
                var a = e.faceVertexUvs[n];
                for (void 0 === this.faceVertexUvs[n] && (this.faceVertexUvs[n] = []),
                i = 0,
                t = a.length; i < t; i++) {
                    for (var o = a[i], s = [], c = 0, h = o.length; c < h; c++)
                        s.push(o[c].clone());
                    this.faceVertexUvs[n].push(s)
                }
            }
            for (n = 0,
            r = (c = e.morphTargets).length; n < r; n++) {
                if ((h = {}).name = c[n].name,
                void 0 !== c[n].vertices)
                    for (h.vertices = [],
                    i = 0,
                    t = c[n].vertices.length; i < t; i++)
                        h.vertices.push(c[n].vertices[i].clone());
                if (void 0 !== c[n].normals)
                    for (h.normals = [],
                    i = 0,
                    t = c[n].normals.length; i < t; i++)
                        h.normals.push(c[n].normals[i].clone());
                this.morphTargets.push(h)
            }
            for (n = 0,
            r = (c = e.morphNormals).length; n < r; n++) {
                if (h = {},
                void 0 !== c[n].vertexNormals)
                    for (h.vertexNormals = [],
                    i = 0,
                    t = c[n].vertexNormals.length; i < t; i++)
                        a = c[n].vertexNormals[i],
                        (o = {}).a = a.a.clone(),
                        o.b = a.b.clone(),
                        o.c = a.c.clone(),
                        h.vertexNormals.push(o);
                if (void 0 !== c[n].faceNormals)
                    for (h.faceNormals = [],
                    i = 0,
                    t = c[n].faceNormals.length; i < t; i++)
                        h.faceNormals.push(c[n].faceNormals[i].clone());
                this.morphNormals.push(h)
            }
            for (n = 0,
            r = (i = e.skinWeights).length; n < r; n++)
                this.skinWeights.push(i[n].clone());
            for (n = 0,
            r = (i = e.skinIndices).length; n < r; n++)
                this.skinIndices.push(i[n].clone());
            for (n = 0,
            r = (i = e.lineDistances).length; n < r; n++)
                this.lineDistances.push(i[n]);
            return null !== (n = e.boundingBox) && (this.boundingBox = n.clone()),
            null !== (n = e.boundingSphere) && (this.boundingSphere = n.clone()),
            this.elementsNeedUpdate = e.elementsNeedUpdate,
            this.verticesNeedUpdate = e.verticesNeedUpdate,
            this.uvsNeedUpdate = e.uvsNeedUpdate,
            this.normalsNeedUpdate = e.normalsNeedUpdate,
            this.colorsNeedUpdate = e.colorsNeedUpdate,
            this.lineDistancesNeedUpdate = e.lineDistancesNeedUpdate,
            this.groupsNeedUpdate = e.groupsNeedUpdate,
            this
        },
        dispose: function() {
            this.dispatchEvent({
                type: "dispose"
            })
        }
    }),
    Object.defineProperty(m.prototype, "needsUpdate", {
        set: function(e) {
            !0 === e && this.version++
        }
    }),
    Object.assign(m.prototype, {
        isBufferAttribute: !0,
        onUploadCallback: function() {},
        setArray: function(e) {
            if (Array.isArray(e))
                throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
            return this.count = void 0 !== e ? e.length / this.itemSize : 0,
            this.array = e,
            this
        },
        setDynamic: function(e) {
            return this.dynamic = e,
            this
        },
        copy: function(e) {
            return this.name = e.name,
            this.array = new e.array.constructor(e.array),
            this.itemSize = e.itemSize,
            this.count = e.count,
            this.normalized = e.normalized,
            this.dynamic = e.dynamic,
            this
        },
        copyAt: function(e, t, i) {
            e *= this.itemSize,
            i *= t.itemSize;
            for (var n = 0, r = this.itemSize; n < r; n++)
                this.array[e + n] = t.array[i + n];
            return this
        },
        copyArray: function(e) {
            return this.array.set(e),
            this
        },
        copyColorsArray: function(e) {
            for (var t = this.array, i = 0, n = 0, r = e.length; n < r; n++) {
                var a = e[n];
                void 0 === a && (console.warn("THREE.BufferAttribute.copyColorsArray(): color is undefined", n),
                a = new d),
                t[i++] = a.r,
                t[i++] = a.g,
                t[i++] = a.b
            }
            return this
        },
        copyVector2sArray: function(e) {
            for (var t = this.array, i = 0, n = 0, r = e.length; n < r; n++) {
                var a = e[n];
                void 0 === a && (console.warn("THREE.BufferAttribute.copyVector2sArray(): vector is undefined", n),
                a = new Y),
                t[i++] = a.x,
                t[i++] = a.y
            }
            return this
        },
        copyVector3sArray: function(e) {
            for (var t = this.array, i = 0, n = 0, r = e.length; n < r; n++) {
                var a = e[n];
                void 0 === a && (console.warn("THREE.BufferAttribute.copyVector3sArray(): vector is undefined", n),
                a = new Me),
                t[i++] = a.x,
                t[i++] = a.y,
                t[i++] = a.z
            }
            return this
        },
        copyVector4sArray: function(e) {
            for (var t = this.array, i = 0, n = 0, r = e.length; n < r; n++) {
                var a = e[n];
                void 0 === a && (console.warn("THREE.BufferAttribute.copyVector4sArray(): vector is undefined", n),
                a = new Ee),
                t[i++] = a.x,
                t[i++] = a.y,
                t[i++] = a.z,
                t[i++] = a.w
            }
            return this
        },
        set: function(e, t) {
            return this.array.set(e, t = void 0 === t ? 0 : t),
            this
        },
        getX: function(e) {
            return this.array[e * this.itemSize]
        },
        setX: function(e, t) {
            return this.array[e * this.itemSize] = t,
            this
        },
        getY: function(e) {
            return this.array[e * this.itemSize + 1]
        },
        setY: function(e, t) {
            return this.array[e * this.itemSize + 1] = t,
            this
        },
        getZ: function(e) {
            return this.array[e * this.itemSize + 2]
        },
        setZ: function(e, t) {
            return this.array[e * this.itemSize + 2] = t,
            this
        },
        getW: function(e) {
            return this.array[e * this.itemSize + 3]
        },
        setW: function(e, t) {
            return this.array[e * this.itemSize + 3] = t,
            this
        },
        setXY: function(e, t, i) {
            return e *= this.itemSize,
            this.array[e + 0] = t,
            this.array[e + 1] = i,
            this
        },
        setXYZ: function(e, t, i, n) {
            return e *= this.itemSize,
            this.array[e + 0] = t,
            this.array[e + 1] = i,
            this.array[e + 2] = n,
            this
        },
        setXYZW: function(e, t, i, n, r) {
            return e *= this.itemSize,
            this.array[e + 0] = t,
            this.array[e + 1] = i,
            this.array[e + 2] = n,
            this.array[e + 3] = r,
            this
        },
        onUpload: function(e) {
            return this.onUploadCallback = e,
            this
        },
        clone: function() {
            return new this.constructor(this.array,this.itemSize).copy(this)
        }
    }),
    (F.prototype = Object.create(m.prototype)).constructor = F,
    (H.prototype = Object.create(m.prototype)).constructor = H,
    (k.prototype = Object.create(m.prototype)).constructor = k,
    (V.prototype = Object.create(m.prototype)).constructor = V,
    j.prototype = Object.create(m.prototype),
    j.prototype.constructor = j,
    (W.prototype = Object.create(m.prototype)).constructor = W,
    q.prototype = Object.create(m.prototype),
    q.prototype.constructor = q,
    (z.prototype = Object.create(m.prototype)).constructor = z,
    (X.prototype = Object.create(m.prototype)).constructor = X,
    Object.assign(J.prototype, {
        computeGroups: function(e) {
            var t = []
              , i = void 0;
            e = e.faces;
            for (var n = 0; n < e.length; n++) {
                var r, a = e[n];
                a.materialIndex !== i && (i = a.materialIndex,
                void 0 !== r && (r.count = 3 * n - r.start,
                t.push(r)),
                r = {
                    start: 3 * n,
                    materialIndex: i
                })
            }
            void 0 !== r && (r.count = 3 * n - r.start,
            t.push(r)),
            this.groups = t
        },
        fromGeometry: function(e) {
            var t = e.faces
              , i = e.vertices
              , n = e.faceVertexUvs
              , r = n[0] && 0 < n[0].length
              , a = n[1] && 0 < n[1].length
              , o = e.morphTargets
              , s = o.length;
            if (0 < s) {
                for (var c = [], h = 0; h < s; h++)
                    c[h] = {
                        name: o[h].name,
                        data: []
                    };
                this.morphTargets.position = c
            }
            var l = e.morphNormals
              , u = l.length;
            if (0 < u) {
                for (var p = [], h = 0; h < u; h++)
                    p[h] = {
                        name: l[h].name,
                        data: []
                    };
                this.morphTargets.normal = p
            }
            var d = e.skinIndices
              , f = e.skinWeights
              , m = d.length === i.length
              , g = f.length === i.length;
            for (0 < i.length && 0 === t.length && console.error("THREE.DirectGeometry: Faceless geometries are not supported."),
            h = 0; h < t.length; h++) {
                var v = t[h]
                  , y = (this.vertices.push(i[v.a], i[v.b], i[v.c]),
                v.vertexNormals);
                for (3 === y.length ? this.normals.push(y[0], y[1], y[2]) : (y = v.normal,
                this.normals.push(y, y, y)),
                3 === (y = v.vertexColors).length ? this.colors.push(y[0], y[1], y[2]) : (y = v.color,
                this.colors.push(y, y, y)),
                !0 === r && (void 0 !== (y = n[0][h]) ? this.uvs.push(y[0], y[1], y[2]) : (console.warn("THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ", h),
                this.uvs.push(new Y, new Y, new Y))),
                !0 === a && (void 0 !== (y = n[1][h]) ? this.uvs2.push(y[0], y[1], y[2]) : (console.warn("THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ", h),
                this.uvs2.push(new Y, new Y, new Y))),
                y = 0; y < s; y++) {
                    var x = o[y].vertices;
                    c[y].data.push(x[v.a], x[v.b], x[v.c])
                }
                for (y = 0; y < u; y++)
                    x = l[y].vertexNormals[h],
                    p[y].data.push(x.a, x.b, x.c);
                m && this.skinIndices.push(d[v.a], d[v.b], d[v.c]),
                g && this.skinWeights.push(f[v.a], f[v.b], f[v.c])
            }
            return this.computeGroups(e),
            this.verticesNeedUpdate = e.verticesNeedUpdate,
            this.normalsNeedUpdate = e.normalsNeedUpdate,
            this.colorsNeedUpdate = e.colorsNeedUpdate,
            this.uvsNeedUpdate = e.uvsNeedUpdate,
            this.groupsNeedUpdate = e.groupsNeedUpdate,
            this
        }
    }),
    1), zs = (U.prototype = Object.assign(Object.create(L.prototype), {
        constructor: U,
        isBufferGeometry: !0,
        getIndex: function() {
            return this.index
        },
        setIndex: function(e) {
            Array.isArray(e) ? this.index = new (65535 < Z(e) ? q : j)(e,1) : this.index = e
        },
        addAttribute: function(e, t, i) {
            return t && t.isBufferAttribute || t && t.isInterleavedBufferAttribute ? ("index" === e ? (console.warn("THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute."),
            this.setIndex(t)) : this.attributes[e] = t,
            this) : (console.warn("THREE.BufferGeometry: .addAttribute() now expects ( name, attribute )."),
            this.addAttribute(e, new m(t,i)))
        },
        getAttribute: function(e) {
            return this.attributes[e]
        },
        removeAttribute: function(e) {
            return delete this.attributes[e],
            this
        },
        addGroup: function(e, t, i) {
            this.groups.push({
                start: e,
                count: t,
                materialIndex: void 0 !== i ? i : 0
            })
        },
        clearGroups: function() {
            this.groups = []
        },
        setDrawRange: function(e, t) {
            this.drawRange.start = e,
            this.drawRange.count = t
        },
        applyMatrix: function(e) {
            var t = this.attributes.position;
            return void 0 !== t && (e.applyToBufferAttribute(t),
            t.needsUpdate = !0),
            void 0 !== (t = this.attributes.normal) && ((new g).getNormalMatrix(e).applyToBufferAttribute(t),
            t.needsUpdate = !0),
            null !== this.boundingBox && this.computeBoundingBox(),
            null !== this.boundingSphere && this.computeBoundingSphere(),
            this
        },
        rotateX: (Xo = new _e,
        function(e) {
            return Xo.makeRotationX(e),
            this.applyMatrix(Xo),
            this
        }
        ),
        rotateY: (qo = new _e,
        function(e) {
            return qo.makeRotationY(e),
            this.applyMatrix(qo),
            this
        }
        ),
        rotateZ: (Wo = new _e,
        function(e) {
            return Wo.makeRotationZ(e),
            this.applyMatrix(Wo),
            this
        }
        ),
        translate: (jo = new _e,
        function(e, t, i) {
            return jo.makeTranslation(e, t, i),
            this.applyMatrix(jo),
            this
        }
        ),
        scale: (Vo = new _e,
        function(e, t, i) {
            return Vo.makeScale(e, t, i),
            this.applyMatrix(Vo),
            this
        }
        ),
        lookAt: (ko = new u,
        function(e) {
            ko.lookAt(e),
            ko.updateMatrix(),
            this.applyMatrix(ko.matrix)
        }
        ),
        center: (Ho = new Me,
        function() {
            return this.computeBoundingBox(),
            this.boundingBox.getCenter(Ho).negate(),
            this.translate(Ho.x, Ho.y, Ho.z),
            this
        }
        ),
        setFromObject: function(e) {
            var t, i = e.geometry;
            return e.isPoints || e.isLine ? (e = new z(3 * i.vertices.length,3),
            t = new z(3 * i.colors.length,3),
            this.addAttribute("position", e.copyVector3sArray(i.vertices)),
            this.addAttribute("color", t.copyColorsArray(i.colors)),
            i.lineDistances && i.lineDistances.length === i.vertices.length && (e = new z(i.lineDistances.length,1),
            this.addAttribute("lineDistance", e.copyArray(i.lineDistances))),
            null !== i.boundingSphere && (this.boundingSphere = i.boundingSphere.clone()),
            null !== i.boundingBox && (this.boundingBox = i.boundingBox.clone())) : e.isMesh && i && i.isGeometry && this.fromGeometry(i),
            this
        },
        setFromPoints: function(e) {
            for (var t = [], i = 0, n = e.length; i < n; i++) {
                var r = e[i];
                t.push(r.x, r.y, r.z || 0)
            }
            return this.addAttribute("position", new z(t,3)),
            this
        },
        updateFromObject: function(e) {
            var t = e.geometry;
            if (e.isMesh) {
                var i = t.__directGeometry;
                if (!0 === t.elementsNeedUpdate && (i = void 0,
                t.elementsNeedUpdate = !1),
                void 0 === i)
                    return this.fromGeometry(t);
                i.verticesNeedUpdate = t.verticesNeedUpdate,
                i.normalsNeedUpdate = t.normalsNeedUpdate,
                i.colorsNeedUpdate = t.colorsNeedUpdate,
                i.uvsNeedUpdate = t.uvsNeedUpdate,
                i.groupsNeedUpdate = t.groupsNeedUpdate,
                t.verticesNeedUpdate = !1,
                t.normalsNeedUpdate = !1,
                t.colorsNeedUpdate = !1,
                t.uvsNeedUpdate = !1,
                t.groupsNeedUpdate = !1,
                t = i
            }
            return !0 === t.verticesNeedUpdate && (void 0 !== (i = this.attributes.position) && (i.copyVector3sArray(t.vertices),
            i.needsUpdate = !0),
            t.verticesNeedUpdate = !1),
            !0 === t.normalsNeedUpdate && (void 0 !== (i = this.attributes.normal) && (i.copyVector3sArray(t.normals),
            i.needsUpdate = !0),
            t.normalsNeedUpdate = !1),
            !0 === t.colorsNeedUpdate && (void 0 !== (i = this.attributes.color) && (i.copyColorsArray(t.colors),
            i.needsUpdate = !0),
            t.colorsNeedUpdate = !1),
            t.uvsNeedUpdate && (void 0 !== (i = this.attributes.uv) && (i.copyVector2sArray(t.uvs),
            i.needsUpdate = !0),
            t.uvsNeedUpdate = !1),
            t.lineDistancesNeedUpdate && (void 0 !== (i = this.attributes.lineDistance) && (i.copyArray(t.lineDistances),
            i.needsUpdate = !0),
            t.lineDistancesNeedUpdate = !1),
            t.groupsNeedUpdate && (t.computeGroups(e.geometry),
            this.groups = t.groups,
            t.groupsNeedUpdate = !1),
            this
        },
        fromGeometry: function(e) {
            return e.__directGeometry = (new J).fromGeometry(e),
            this.fromDirectGeometry(e.__directGeometry)
        },
        fromDirectGeometry: function(e) {
            var t, i = new Float32Array(3 * e.vertices.length);
            for (t in this.addAttribute("position", new m(i,3).copyVector3sArray(e.vertices)),
            0 < e.normals.length && (i = new Float32Array(3 * e.normals.length),
            this.addAttribute("normal", new m(i,3).copyVector3sArray(e.normals))),
            0 < e.colors.length && (i = new Float32Array(3 * e.colors.length),
            this.addAttribute("color", new m(i,3).copyColorsArray(e.colors))),
            0 < e.uvs.length && (i = new Float32Array(2 * e.uvs.length),
            this.addAttribute("uv", new m(i,2).copyVector2sArray(e.uvs))),
            0 < e.uvs2.length && (i = new Float32Array(2 * e.uvs2.length),
            this.addAttribute("uv2", new m(i,2).copyVector2sArray(e.uvs2))),
            this.groups = e.groups,
            e.morphTargets) {
                for (var i = [], n = e.morphTargets[t], r = 0, a = n.length; r < a; r++) {
                    var o = n[r]
                      , s = new z(3 * o.data.length,3);
                    s.name = o.name,
                    i.push(s.copyVector3sArray(o.data))
                }
                this.morphAttributes[t] = i
            }
            return 0 < e.skinIndices.length && (t = new z(4 * e.skinIndices.length,4),
            this.addAttribute("skinIndex", t.copyVector4sArray(e.skinIndices))),
            0 < e.skinWeights.length && (t = new z(4 * e.skinWeights.length,4),
            this.addAttribute("skinWeight", t.copyVector4sArray(e.skinWeights))),
            null !== e.boundingSphere && (this.boundingSphere = e.boundingSphere.clone()),
            null !== e.boundingBox && (this.boundingBox = e.boundingBox.clone()),
            this
        },
        computeBoundingBox: function() {
            null === this.boundingBox && (this.boundingBox = new O);
            var e = this.attributes.position;
            void 0 !== e ? this.boundingBox.setFromBufferAttribute(e) : this.boundingBox.makeEmpty(),
            (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this)
        },
        computeBoundingSphere: (Go = new O,
        Fo = new Me,
        function() {
            null === this.boundingSphere && (this.boundingSphere = new I);
            var e = this.attributes.position;
            if (e) {
                var t = this.boundingSphere.center;
                Go.setFromBufferAttribute(e),
                Go.getCenter(t);
                for (var i = 0, n = 0, r = e.count; n < r; n++)
                    Fo.x = e.getX(n),
                    Fo.y = e.getY(n),
                    Fo.z = e.getZ(n),
                    i = Math.max(i, t.distanceToSquared(Fo));
                this.boundingSphere.radius = Math.sqrt(i),
                isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this)
            }
        }
        ),
        computeFaceNormals: function() {},
        computeVertexNormals: function() {
            var e = this.index
              , t = this.attributes;
            if (t.position) {
                var i = t.position.array;
                if (void 0 === t.normal)
                    this.addAttribute("normal", new m(new Float32Array(i.length),3));
                else
                    for (var n = 0, r = (a = t.normal.array).length; n < r; n++)
                        a[n] = 0;
                var a = t.normal.array
                  , o = new Me
                  , s = new Me
                  , c = new Me
                  , h = new Me
                  , l = new Me;
                if (e)
                    for (var u = e.array, n = 0, r = e.count; n < r; n += 3) {
                        var e = 3 * u[n + 0]
                          , p = 3 * u[n + 1]
                          , d = 3 * u[n + 2];
                        o.fromArray(i, e),
                        s.fromArray(i, p),
                        c.fromArray(i, d),
                        h.subVectors(c, s),
                        l.subVectors(o, s),
                        h.cross(l),
                        a[e] += h.x,
                        a[e + 1] += h.y,
                        a[e + 2] += h.z,
                        a[p] += h.x,
                        a[1 + p] += h.y,
                        a[2 + p] += h.z,
                        a[d] += h.x,
                        a[1 + d] += h.y,
                        a[2 + d] += h.z
                    }
                else
                    for (n = 0,
                    r = i.length; n < r; n += 9)
                        o.fromArray(i, n),
                        s.fromArray(i, n + 3),
                        c.fromArray(i, n + 6),
                        h.subVectors(c, s),
                        l.subVectors(o, s),
                        h.cross(l),
                        a[n] = h.x,
                        a[n + 1] = h.y,
                        a[n + 2] = h.z,
                        a[n + 3] = h.x,
                        a[n + 4] = h.y,
                        a[n + 5] = h.z,
                        a[n + 6] = h.x,
                        a[n + 7] = h.y,
                        a[n + 8] = h.z;
                this.normalizeNormals(),
                t.normal.needsUpdate = !0
            }
        },
        merge: function(e, t) {
            if (e && e.isBufferGeometry) {
                void 0 === t && (t = 0,
                console.warn("THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge."));
                var i, n = this.attributes;
                for (i in n)
                    if (void 0 !== e.attributes[i])
                        for (var r = n[i].array, a = (s = e.attributes[i]).array, o = 0, s = s.itemSize * t; o < a.length; o++,
                        s++)
                            r[s] = a[o];
                return this
            }
            console.error("THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.", e)
        },
        normalizeNormals: (Uo = new Me,
        function() {
            for (var e = this.attributes.normal, t = 0, i = e.count; t < i; t++)
                Uo.x = e.getX(t),
                Uo.y = e.getY(t),
                Uo.z = e.getZ(t),
                Uo.normalize(),
                e.setXYZ(t, Uo.x, Uo.y, Uo.z)
        }
        ),
        toNonIndexed: function() {
            function e(e, t) {
                var i = e.array;
                e = e.itemSize;
                for (var n = new i.constructor(t.length * e), r = 0, a = 0, o = t.length; a < o; a++)
                    for (var s = t[a] * e, c = 0; c < e; c++)
                        n[r++] = i[s++];
                return new m(n,e)
            }
            if (null === this.index)
                return console.warn("THREE.BufferGeometry.toNonIndexed(): Geometry is already non-indexed."),
                this;
            var t, i = new U, n = this.index.array;
            for (t in c = this.attributes) {
                var r = e(r = c[t], n);
                i.addAttribute(t, r)
            }
            var a = this.morphAttributes;
            for (t in a) {
                for (var o = [], s = a[t], c = 0, h = s.length; c < h; c++)
                    r = e(r = s[c], n),
                    o.push(r);
                i.morphAttributes[t] = o
            }
            for (c = 0,
            t = (n = this.groups).length; c < t; c++)
                r = n[c],
                i.addGroup(r.start, r.count, r.materialIndex);
            return i
        },
        toJSON: function() {
            var e = {
                metadata: {
                    version: 4.5,
                    type: "BufferGeometry",
                    generator: "BufferGeometry.toJSON"
                }
            };
            if (e.uuid = this.uuid,
            e.type = this.type,
            "" !== this.name && (e.name = this.name),
            0 < Object.keys(this.userData).length && (e.userData = this.userData),
            void 0 !== this.parameters)
                for (r in n = this.parameters)
                    void 0 !== n[r] && (e[r] = n[r]);
            else {
                e.data = {
                    attributes: {}
                };
                var t = this.index;
                for (r in null !== t && (n = Array.prototype.slice.call(t.array),
                e.data.index = {
                    type: t.array.constructor.name,
                    array: n
                }),
                t = this.attributes) {
                    var i = t[r]
                      , n = Array.prototype.slice.call(i.array);
                    e.data.attributes[r] = {
                        itemSize: i.itemSize,
                        type: i.array.constructor.name,
                        array: n,
                        normalized: i.normalized
                    }
                }
                var r = this.groups;
                0 < r.length && (e.data.groups = JSON.parse(JSON.stringify(r))),
                null !== (r = this.boundingSphere) && (e.data.boundingSphere = {
                    center: r.center.toArray(),
                    radius: r.radius
                })
            }
            return e
        },
        clone: function() {
            return (new U).copy(this)
        },
        copy: function(e) {
            for (o in this.index = null,
            this.attributes = {},
            this.morphAttributes = {},
            this.groups = [],
            this.boundingSphere = this.boundingBox = null,
            this.name = e.name,
            null !== (r = e.index) && this.setIndex(r.clone()),
            r = e.attributes)
                this.addAttribute(o, r[o].clone());
            var t = e.morphAttributes;
            for (o in t) {
                for (var i = [], n = t[o], r = 0, a = n.length; r < a; r++)
                    i.push(n[r].clone());
                this.morphAttributes[o] = i
            }
            var o = e.groups;
            for (r = 0,
            a = o.length; r < a; r++)
                t = o[r],
                this.addGroup(t.start, t.count, t.materialIndex);
            return null !== (o = e.boundingBox) && (this.boundingBox = o.clone()),
            null !== (o = e.boundingSphere) && (this.boundingSphere = o.clone()),
            this.drawRange.start = e.drawRange.start,
            this.drawRange.count = e.drawRange.count,
            this.userData = e.userData,
            this
        },
        dispose: function() {
            this.dispatchEvent({
                type: "dispose"
            })
        }
    }),
    (Q.prototype = Object.create(f.prototype)).constructor = Q,
    (K.prototype = Object.create(U.prototype)).constructor = K,
    ($.prototype = Object.create(f.prototype)).constructor = $,
    (ee.prototype = Object.create(U.prototype)).constructor = ee,
    0);
    function Us(e, t, i, n, r, a, o, s) {
        return null === (1 === t.side ? n.intersectTriangle(o, a, r, !0, s) : n.intersectTriangle(r, a, o, 2 !== t.side, s)) || (Os.copy(s),
        Os.applyMatrix4(e.matrixWorld),
        (t = i.ray.origin.distanceTo(Os)) < i.near) || t > i.far ? null : {
            distance: t,
            point: Os.clone(),
            object: e
        }
    }
    function Gs(e, t, i, n, r, a, o, s, c) {
        return _s.fromBufferAttribute(r, o),
        Ms.fromBufferAttribute(r, s),
        Es.fromBufferAttribute(r, c),
        (e = Us(e, t, i, n, _s, Ms, Es, Cs)) && (a && (Ls.fromBufferAttribute(a, o),
        Ps.fromBufferAttribute(a, s),
        Rs.fromBufferAttribute(a, c),
        e.uv = w.getUV(Cs, _s, Ms, Es, Ls, Ps, Rs, new Y)),
        a = new B(o,s,c),
        w.getNormal(_s, Ms, Es, a.normal),
        e.face = a),
        e
    }
    a.prototype = Object.assign(Object.create(L.prototype), {
        constructor: a,
        isMaterial: !0,
        onBeforeCompile: function() {},
        setValues: function(e) {
            if (void 0 !== e)
                for (var t in e) {
                    var i, n = e[t];
                    void 0 === n ? console.warn("THREE.Material: '" + t + "' parameter is undefined.") : "shading" === t ? (console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead."),
                    this.flatShading = 1 === n) : void 0 === (i = this[t]) ? console.warn("THREE." + this.type + ": '" + t + "' is not a property of this material.") : i && i.isColor ? i.set(n) : i && i.isVector3 && n && n.isVector3 ? i.copy(n) : this[t] = n
                }
        },
        toJSON: function(e) {
            function t(e) {
                var t, i = [];
                for (t in e) {
                    var n = e[t];
                    delete n.metadata,
                    i.push(n)
                }
                return i
            }
            var i = void 0 === e || "string" == typeof e
              , n = (i && (e = {
                textures: {},
                images: {}
            }),
            {
                metadata: {
                    version: 4.5,
                    type: "Material",
                    generator: "Material.toJSON"
                }
            });
            return n.uuid = this.uuid,
            n.type = this.type,
            "" !== this.name && (n.name = this.name),
            this.color && this.color.isColor && (n.color = this.color.getHex()),
            void 0 !== this.roughness && (n.roughness = this.roughness),
            void 0 !== this.metalness && (n.metalness = this.metalness),
            this.emissive && this.emissive.isColor && (n.emissive = this.emissive.getHex()),
            1 !== this.emissiveIntensity && (n.emissiveIntensity = this.emissiveIntensity),
            this.specular && this.specular.isColor && (n.specular = this.specular.getHex()),
            void 0 !== this.shininess && (n.shininess = this.shininess),
            void 0 !== this.clearCoat && (n.clearCoat = this.clearCoat),
            void 0 !== this.clearCoatRoughness && (n.clearCoatRoughness = this.clearCoatRoughness),
            this.map && this.map.isTexture && (n.map = this.map.toJSON(e).uuid),
            this.alphaMap && this.alphaMap.isTexture && (n.alphaMap = this.alphaMap.toJSON(e).uuid),
            this.lightMap && this.lightMap.isTexture && (n.lightMap = this.lightMap.toJSON(e).uuid),
            this.aoMap && this.aoMap.isTexture && (n.aoMap = this.aoMap.toJSON(e).uuid,
            n.aoMapIntensity = this.aoMapIntensity),
            this.bumpMap && this.bumpMap.isTexture && (n.bumpMap = this.bumpMap.toJSON(e).uuid,
            n.bumpScale = this.bumpScale),
            this.normalMap && this.normalMap.isTexture && (n.normalMap = this.normalMap.toJSON(e).uuid,
            n.normalMapType = this.normalMapType,
            n.normalScale = this.normalScale.toArray()),
            this.displacementMap && this.displacementMap.isTexture && (n.displacementMap = this.displacementMap.toJSON(e).uuid,
            n.displacementScale = this.displacementScale,
            n.displacementBias = this.displacementBias),
            this.roughnessMap && this.roughnessMap.isTexture && (n.roughnessMap = this.roughnessMap.toJSON(e).uuid),
            this.metalnessMap && this.metalnessMap.isTexture && (n.metalnessMap = this.metalnessMap.toJSON(e).uuid),
            this.emissiveMap && this.emissiveMap.isTexture && (n.emissiveMap = this.emissiveMap.toJSON(e).uuid),
            this.specularMap && this.specularMap.isTexture && (n.specularMap = this.specularMap.toJSON(e).uuid),
            this.envMap && this.envMap.isTexture && (n.envMap = this.envMap.toJSON(e).uuid,
            n.reflectivity = this.reflectivity,
            void 0 !== this.combine && (n.combine = this.combine),
            void 0 !== this.envMapIntensity) && (n.envMapIntensity = this.envMapIntensity),
            this.gradientMap && this.gradientMap.isTexture && (n.gradientMap = this.gradientMap.toJSON(e).uuid),
            void 0 !== this.size && (n.size = this.size),
            void 0 !== this.sizeAttenuation && (n.sizeAttenuation = this.sizeAttenuation),
            1 !== this.blending && (n.blending = this.blending),
            !0 === this.flatShading && (n.flatShading = this.flatShading),
            0 !== this.side && (n.side = this.side),
            0 !== this.vertexColors && (n.vertexColors = this.vertexColors),
            this.opacity < 1 && (n.opacity = this.opacity),
            !0 === this.transparent && (n.transparent = this.transparent),
            n.depthFunc = this.depthFunc,
            n.depthTest = this.depthTest,
            n.depthWrite = this.depthWrite,
            0 !== this.rotation && (n.rotation = this.rotation),
            !0 === this.polygonOffset && (n.polygonOffset = !0),
            0 !== this.polygonOffsetFactor && (n.polygonOffsetFactor = this.polygonOffsetFactor),
            0 !== this.polygonOffsetUnits && (n.polygonOffsetUnits = this.polygonOffsetUnits),
            1 !== this.linewidth && (n.linewidth = this.linewidth),
            void 0 !== this.dashSize && (n.dashSize = this.dashSize),
            void 0 !== this.gapSize && (n.gapSize = this.gapSize),
            void 0 !== this.scale && (n.scale = this.scale),
            !0 === this.dithering && (n.dithering = !0),
            0 < this.alphaTest && (n.alphaTest = this.alphaTest),
            !0 === this.premultipliedAlpha && (n.premultipliedAlpha = this.premultipliedAlpha),
            !0 === this.wireframe && (n.wireframe = this.wireframe),
            1 < this.wireframeLinewidth && (n.wireframeLinewidth = this.wireframeLinewidth),
            "round" !== this.wireframeLinecap && (n.wireframeLinecap = this.wireframeLinecap),
            "round" !== this.wireframeLinejoin && (n.wireframeLinejoin = this.wireframeLinejoin),
            !0 === this.morphTargets && (n.morphTargets = !0),
            !0 === this.skinning && (n.skinning = !0),
            !1 === this.visible && (n.visible = !1),
            "{}" !== JSON.stringify(this.userData) && (n.userData = this.userData),
            i && (i = t(e.textures),
            e = t(e.images),
            0 < i.length && (n.textures = i),
            0 < e.length) && (n.images = e),
            n
        },
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(e) {
            this.name = e.name,
            this.fog = e.fog,
            this.lights = e.lights,
            this.blending = e.blending,
            this.side = e.side,
            this.flatShading = e.flatShading,
            this.vertexColors = e.vertexColors,
            this.opacity = e.opacity,
            this.transparent = e.transparent,
            this.blendSrc = e.blendSrc,
            this.blendDst = e.blendDst,
            this.blendEquation = e.blendEquation,
            this.blendSrcAlpha = e.blendSrcAlpha,
            this.blendDstAlpha = e.blendDstAlpha,
            this.blendEquationAlpha = e.blendEquationAlpha,
            this.depthFunc = e.depthFunc,
            this.depthTest = e.depthTest,
            this.depthWrite = e.depthWrite,
            this.colorWrite = e.colorWrite,
            this.precision = e.precision,
            this.polygonOffset = e.polygonOffset,
            this.polygonOffsetFactor = e.polygonOffsetFactor,
            this.polygonOffsetUnits = e.polygonOffsetUnits,
            this.dithering = e.dithering,
            this.alphaTest = e.alphaTest,
            this.premultipliedAlpha = e.premultipliedAlpha,
            this.visible = e.visible,
            this.userData = JSON.parse(JSON.stringify(e.userData)),
            this.clipShadows = e.clipShadows,
            this.clipIntersection = e.clipIntersection;
            var t = e.clippingPlanes
              , i = null;
            if (null !== t)
                for (var n = t.length, i = Array(n), r = 0; r !== n; ++r)
                    i[r] = t[r].clone();
            return this.clippingPlanes = i,
            this.shadowSide = e.shadowSide,
            this
        },
        dispose: function() {
            this.dispatchEvent({
                type: "dispose"
            })
        }
    }),
    ((te.prototype = Object.create(a.prototype)).constructor = te).prototype.isShaderMaterial = !0,
    te.prototype.copy = function(e) {
        return a.prototype.copy.call(this, e),
        this.fragmentShader = e.fragmentShader,
        this.vertexShader = e.vertexShader,
        this.uniforms = Pe(e.uniforms),
        this.defines = Object.assign({}, e.defines),
        this.wireframe = e.wireframe,
        this.wireframeLinewidth = e.wireframeLinewidth,
        this.lights = e.lights,
        this.clipping = e.clipping,
        this.skinning = e.skinning,
        this.morphTargets = e.morphTargets,
        this.morphNormals = e.morphNormals,
        this.extensions = e.extensions,
        this
    }
    ,
    te.prototype.toJSON = function(e) {
        var t, i, n = a.prototype.toJSON.call(this, e);
        for (t in n.uniforms = {},
        this.uniforms) {
            var r = this.uniforms[t].value;
            n.uniforms[t] = r && r.isTexture ? {
                type: "t",
                value: r.toJSON(e).uuid
            } : r && r.isColor ? {
                type: "c",
                value: r.getHex()
            } : r && r.isVector2 ? {
                type: "v2",
                value: r.toArray()
            } : r && r.isVector3 ? {
                type: "v3",
                value: r.toArray()
            } : r && r.isVector4 ? {
                type: "v4",
                value: r.toArray()
            } : r && r.isMatrix3 ? {
                type: "m3",
                value: r.toArray()
            } : r && r.isMatrix4 ? {
                type: "m4",
                value: r.toArray()
            } : {
                value: r
            }
        }
        for (i in 0 < Object.keys(this.defines).length && (n.defines = this.defines),
        n.vertexShader = this.vertexShader,
        n.fragmentShader = this.fragmentShader,
        e = {},
        this.extensions)
            !0 === this.extensions[i] && (e[i] = !0);
        return 0 < Object.keys(e).length && (n.extensions = e),
        n
    }
    ,
    Object.assign(ie.prototype, {
        set: function(e, t) {
            return this.origin.copy(e),
            this.direction.copy(t),
            this
        },
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(e) {
            return this.origin.copy(e.origin),
            this.direction.copy(e.direction),
            this
        },
        at: function(e, t) {
            return void 0 === t && (console.warn("THREE.Ray: .at() target is now required"),
            t = new Me),
            t.copy(this.direction).multiplyScalar(e).add(this.origin)
        },
        lookAt: function(e) {
            return this.direction.copy(e).sub(this.origin).normalize(),
            this
        },
        recast: (rs = new Me,
        function(e) {
            return this.origin.copy(this.at(e, rs)),
            this
        }
        ),
        closestPointToPoint: function(e, t) {
            return void 0 === t && (console.warn("THREE.Ray: .closestPointToPoint() target is now required"),
            t = new Me),
            t.subVectors(e, this.origin),
            (e = t.dot(this.direction)) < 0 ? t.copy(this.origin) : t.copy(this.direction).multiplyScalar(e).add(this.origin)
        },
        distanceToPoint: function(e) {
            return Math.sqrt(this.distanceSqToPoint(e))
        },
        distanceSqToPoint: (ns = new Me,
        function(e) {
            var t = ns.subVectors(e, this.origin).dot(this.direction);
            return (t < 0 ? this.origin : (ns.copy(this.direction).multiplyScalar(t).add(this.origin),
            ns)).distanceToSquared(e)
        }
        ),
        distanceSqToSegment: (es = new Me,
        ts = new Me,
        is = new Me,
        function(e, t, i, n) {
            es.copy(e).add(t).multiplyScalar(.5),
            ts.copy(t).sub(e).normalize(),
            is.copy(this.origin).sub(es);
            var r, a = .5 * e.distanceTo(t), o = -this.direction.dot(ts), s = is.dot(this.direction), c = -is.dot(ts), h = is.lengthSq(), l = Math.abs(1 - o * o);
            return o = 0 < l ? (t = o * s - c,
            r = a * l,
            0 <= (e = o * c - s) ? -r <= t ? t <= r ? (e *= a = 1 / l) * (e + o * (t *= a) + 2 * s) + t * (o * e + t + 2 * c) + h : (t = a,
            -(e = Math.max(0, -(o * t + s))) * e + t * (t + 2 * c) + h) : (t = -a,
            -(e = Math.max(0, -(o * t + s))) * e + t * (t + 2 * c) + h) : t <= -r ? -(e = Math.max(0, -(-o * a + s))) * e + (t = 0 < e ? -a : Math.min(Math.max(-a, -c), a)) * (t + 2 * c) + h : t <= r ? (e = 0,
            (t = Math.min(Math.max(-a, -c), a)) * (t + 2 * c) + h) : -(e = Math.max(0, -(o * a + s))) * e + (t = 0 < e ? a : Math.min(Math.max(-a, -c), a)) * (t + 2 * c) + h) : (t = 0 < o ? -a : a,
            -(e = Math.max(0, -(o * t + s))) * e + t * (t + 2 * c) + h),
            i && i.copy(this.direction).multiplyScalar(e).add(this.origin),
            n && n.copy(ts).multiplyScalar(t).add(es),
            o
        }
        ),
        intersectSphere: ($o = new Me,
        function(e, t) {
            $o.subVectors(e.center, this.origin);
            var i = $o.dot(this.direction)
              , n = $o.dot($o) - i * i;
            return (e = e.radius * e.radius) < n || (n = i - (e = Math.sqrt(e - n)),
            i += e,
            n < 0 && i < 0) ? null : n < 0 ? this.at(i, t) : this.at(n, t)
        }
        ),
        intersectsSphere: function(e) {
            return this.distanceSqToPoint(e.center) <= e.radius * e.radius
        },
        distanceToPlane: function(e) {
            var t = e.normal.dot(this.direction);
            return 0 === t ? 0 === e.distanceToPoint(this.origin) ? 0 : null : 0 <= (e = -(this.origin.dot(e.normal) + e.constant) / t) ? e : null
        },
        intersectPlane: function(e, t) {
            return null === (e = this.distanceToPlane(e)) ? null : this.at(e, t)
        },
        intersectsPlane: function(e) {
            var t = e.distanceToPoint(this.origin);
            return 0 === t || e.normal.dot(this.direction) * t < 0
        },
        intersectBox: function(e, t) {
            var i, n, r = 1 / this.direction.x, a = 1 / this.direction.y, o = 1 / this.direction.z, s = this.origin;
            return 0 <= r ? (i = (e.min.x - s.x) * r,
            r *= e.max.x - s.x) : (i = (e.max.x - s.x) * r,
            r *= e.min.x - s.x),
            0 <= a ? (n = (e.min.y - s.y) * a,
            a *= e.max.y - s.y) : (n = (e.max.y - s.y) * a,
            a *= e.min.y - s.y),
            a < i || r < n || ((i < n || i != i) && (i = n),
            (a < r || r != r) && (r = a),
            (e = 0 <= o ? (n = (e.min.z - s.z) * o,
            (e.max.z - s.z) * o) : (n = (e.max.z - s.z) * o,
            (e.min.z - s.z) * o)) < i) || r < n || ((i < n || i != i) && (i = n),
            (r = e < r || r != r ? e : r) < 0) ? null : this.at(0 <= i ? i : r, t)
        },
        intersectsBox: (Ko = new Me,
        function(e) {
            return null !== this.intersectBox(e, Ko)
        }
        ),
        intersectTriangle: (Yo = new Me,
        Jo = new Me,
        Zo = new Me,
        Qo = new Me,
        function(e, t, i, n, r) {
            if (Jo.subVectors(t, e),
            Zo.subVectors(i, e),
            Qo.crossVectors(Jo, Zo),
            0 < (t = this.direction.dot(Qo))) {
                if (n)
                    return null;
                n = 1
            } else {
                if (!(t < 0))
                    return null;
                n = -1,
                t = -t
            }
            return Yo.subVectors(this.origin, e),
            (e = n * this.direction.dot(Zo.crossVectors(Yo, Zo))) < 0 || (i = n * this.direction.dot(Jo.cross(Yo))) < 0 || t < e + i || (e = -n * Yo.dot(Qo)) < 0 ? null : this.at(e / t, r)
        }
        ),
        applyMatrix4: function(e) {
            return this.origin.applyMatrix4(e),
            this.direction.transformDirection(e),
            this
        },
        equals: function(e) {
            return e.origin.equals(this.origin) && e.direction.equals(this.direction)
        }
    }),
    Object.assign(w, {
        getNormal: (ls = new Me,
        function(e, t, i, n) {
            return void 0 === n && (console.warn("THREE.Triangle: .getNormal() target is now required"),
            n = new Me),
            n.subVectors(i, t),
            ls.subVectors(e, t),
            n.cross(ls),
            0 < (e = n.lengthSq()) ? n.multiplyScalar(1 / Math.sqrt(e)) : n.set(0, 0, 0)
        }
        ),
        getBarycoord: (ss = new Me,
        cs = new Me,
        hs = new Me,
        function(e, t, i, n, r) {
            ss.subVectors(n, t),
            cs.subVectors(i, t),
            hs.subVectors(e, t),
            e = ss.dot(ss),
            t = ss.dot(cs),
            i = ss.dot(hs);
            var a = cs.dot(cs)
              , o = (n = cs.dot(hs),
            e * a - t * t);
            return void 0 === r && (console.warn("THREE.Triangle: .getBarycoord() target is now required"),
            r = new Me),
            0 == o ? r.set(-2, -1, -1) : r.set(1 - (a = (a * i - t * n) * (o = 1 / o)) - (e = (e * n - t * i) * o), e, a)
        }
        ),
        containsPoint: (os = new Me,
        function(e, t, i, n) {
            return w.getBarycoord(e, t, i, n, os),
            0 <= os.x && 0 <= os.y && os.x + os.y <= 1
        }
        ),
        getUV: (as = new Me,
        function(e, t, i, n, r, a, o, s) {
            return this.getBarycoord(e, t, i, n, as),
            s.set(0, 0),
            s.addScaledVector(r, as.x),
            s.addScaledVector(a, as.y),
            s.addScaledVector(o, as.z),
            s
        }
        )
    }),
    Object.assign(w.prototype, {
        set: function(e, t, i) {
            return this.a.copy(e),
            this.b.copy(t),
            this.c.copy(i),
            this
        },
        setFromPointsAndIndices: function(e, t, i, n) {
            return this.a.copy(e[t]),
            this.b.copy(e[i]),
            this.c.copy(e[n]),
            this
        },
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(e) {
            return this.a.copy(e.a),
            this.b.copy(e.b),
            this.c.copy(e.c),
            this
        },
        getArea: (vs = new Me,
        ys = new Me,
        function() {
            return vs.subVectors(this.c, this.b),
            ys.subVectors(this.a, this.b),
            .5 * vs.cross(ys).length()
        }
        ),
        getMidpoint: function(e) {
            return void 0 === e && (console.warn("THREE.Triangle: .getMidpoint() target is now required"),
            e = new Me),
            e.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3)
        },
        getNormal: function(e) {
            return w.getNormal(this.a, this.b, this.c, e)
        },
        getPlane: function(e) {
            return void 0 === e && (console.warn("THREE.Triangle: .getPlane() target is now required"),
            e = new Me),
            e.setFromCoplanarPoints(this.a, this.b, this.c)
        },
        getBarycoord: function(e, t) {
            return w.getBarycoord(e, this.a, this.b, this.c, t)
        },
        containsPoint: function(e) {
            return w.containsPoint(e, this.a, this.b, this.c)
        },
        getUV: function(e, t, i, n, r) {
            return w.getUV(e, this.a, this.b, this.c, t, i, n, r)
        },
        intersectsBox: function(e) {
            return e.intersectsTriangle(this)
        },
        closestPointToPoint: (us = new Me,
        ps = new Me,
        ds = new Me,
        fs = new Me,
        ms = new Me,
        gs = new Me,
        function(e, t) {
            void 0 === t && (console.warn("THREE.Triangle: .closestPointToPoint() target is now required"),
            t = new Me);
            var i = this.a
              , n = this.b
              , r = this.c
              , a = (us.subVectors(n, i),
            ps.subVectors(r, i),
            fs.subVectors(e, i),
            us.dot(fs))
              , o = ps.dot(fs);
            if (a <= 0 && o <= 0)
                return t.copy(i);
            ms.subVectors(e, n);
            var s = us.dot(ms)
              , c = ps.dot(ms);
            if (0 <= s && c <= s)
                return t.copy(n);
            var h = a * c - s * o;
            if (h <= 0 && 0 <= a && s <= 0)
                return n = a / (a - s),
                t.copy(i).addScaledVector(us, n);
            gs.subVectors(e, r),
            e = us.dot(gs);
            var l = ps.dot(gs);
            return 0 <= l && e <= l ? t.copy(r) : (a = e * o - a * l) <= 0 && 0 <= o && l <= 0 ? (h = o / (o - l),
            t.copy(i).addScaledVector(ps, h)) : (o = s * l - e * c) <= 0 && 0 <= c - s && 0 <= e - l ? (ds.subVectors(r, n),
            h = (c - s) / (c - s + (e - l)),
            t.copy(n).addScaledVector(ds, h)) : (n = a * (r = 1 / (o + a + h)),
            h *= r,
            t.copy(i).addScaledVector(us, n).addScaledVector(ps, h))
        }
        ),
        equals: function(e) {
            return e.a.equals(this.a) && e.b.equals(this.b) && e.c.equals(this.c)
        }
    }),
    ((ne.prototype = Object.create(a.prototype)).constructor = ne).prototype.isMeshBasicMaterial = !0,
    ne.prototype.copy = function(e) {
        return a.prototype.copy.call(this, e),
        this.color.copy(e.color),
        this.map = e.map,
        this.lightMap = e.lightMap,
        this.lightMapIntensity = e.lightMapIntensity,
        this.aoMap = e.aoMap,
        this.aoMapIntensity = e.aoMapIntensity,
        this.specularMap = e.specularMap,
        this.alphaMap = e.alphaMap,
        this.envMap = e.envMap,
        this.combine = e.combine,
        this.reflectivity = e.reflectivity,
        this.refractionRatio = e.refractionRatio,
        this.wireframe = e.wireframe,
        this.wireframeLinewidth = e.wireframeLinewidth,
        this.wireframeLinecap = e.wireframeLinecap,
        this.wireframeLinejoin = e.wireframeLinejoin,
        this.skinning = e.skinning,
        this.morphTargets = e.morphTargets,
        this
    }
    ,
    v.prototype = Object.assign(Object.create(u.prototype), {
        constructor: v,
        isMesh: !0,
        setDrawMode: function(e) {
            this.drawMode = e
        },
        copy: function(e) {
            return u.prototype.copy.call(this, e),
            this.drawMode = e.drawMode,
            void 0 !== e.morphTargetInfluences && (this.morphTargetInfluences = e.morphTargetInfluences.slice()),
            void 0 !== e.morphTargetDictionary && (this.morphTargetDictionary = Object.assign({}, e.morphTargetDictionary)),
            this
        },
        updateMorphTargets: function() {
            if ((e = this.geometry).isBufferGeometry) {
                var e = e.morphAttributes
                  , t = Object.keys(e);
                if (0 < t.length) {
                    var i = e[t[0]];
                    if (void 0 !== i)
                        for (this.morphTargetInfluences = [],
                        this.morphTargetDictionary = {},
                        e = 0,
                        t = i.length; e < t; e++) {
                            var n = i[e].name || String(e);
                            this.morphTargetInfluences.push(0),
                            this.morphTargetDictionary[n] = e
                        }
                }
            } else
                void 0 !== (e = e.morphTargets) && 0 < e.length && console.error("THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")
        },
        raycast: (xs = new _e,
        bs = new ie,
        ws = new I,
        _s = new Me,
        Ms = new Me,
        Es = new Me,
        Ss = new Me,
        Ts = new Me,
        As = new Me,
        Ls = new Y,
        Ps = new Y,
        Rs = new Y,
        Cs = new Me,
        Os = new Me,
        function(e, t) {
            var i = this.geometry
              , n = this.material
              , r = this.matrixWorld;
            if (void 0 !== n && (null === i.boundingSphere && i.computeBoundingSphere(),
            ws.copy(i.boundingSphere),
            ws.applyMatrix4(r),
            !1 !== e.ray.intersectsSphere(ws)) && (xs.getInverse(r),
            bs.copy(e.ray).applyMatrix4(xs),
            null === i.boundingBox || !1 !== bs.intersectsBox(i.boundingBox)))
                if (i.isBufferGeometry) {
                    var a = i.index
                      , o = i.attributes.position
                      , s = i.attributes.uv
                      , c = i.groups
                      , i = i.drawRange;
                    if (null !== a)
                        if (Array.isArray(n))
                            for (var h = 0, l = c.length; h < l; h++)
                                for (var u = c[h], p = n[u.materialIndex], d = Math.max(u.start, i.start), f = r = Math.min(u.start + u.count, i.start + i.count); d < f; d += 3) {
                                    var r = a.getX(d)
                                      , m = a.getX(d + 1)
                                      , g = a.getX(d + 2);
                                    (r = Gs(this, p, e, bs, o, s, r, m, g)) && (r.faceIndex = Math.floor(d / 3),
                                    r.face.materialIndex = u.materialIndex,
                                    t.push(r))
                                }
                        else
                            for (h = d = Math.max(0, i.start),
                            l = r = Math.min(a.count, i.start + i.count); h < l; h += 3)
                                r = a.getX(h),
                                m = a.getX(h + 1),
                                g = a.getX(h + 2),
                                (r = Gs(this, n, e, bs, o, s, r, m, g)) && (r.faceIndex = Math.floor(h / 3),
                                t.push(r));
                    else if (void 0 !== o)
                        if (Array.isArray(n))
                            for (h = 0,
                            l = c.length; h < l; h++)
                                for (p = n[(u = c[h]).materialIndex],
                                d = Math.max(u.start, i.start),
                                f = r = Math.min(u.start + u.count, i.start + i.count); d < f; d += 3)
                                    (r = Gs(this, p, e, bs, o, s, r = d, m = d + 1, g = d + 2)) && (r.faceIndex = Math.floor(d / 3),
                                    r.face.materialIndex = u.materialIndex,
                                    t.push(r));
                        else
                            for (h = d = Math.max(0, i.start),
                            l = r = Math.min(o.count, i.start + i.count); h < l; h += 3)
                                (r = Gs(this, n, e, bs, o, s, r = h, m = h + 1, g = h + 2)) && (r.faceIndex = Math.floor(h / 3),
                                t.push(r))
                } else if (i.isGeometry)
                    for (o = Array.isArray(n),
                    s = i.vertices,
                    c = i.faces,
                    0 < (r = i.faceVertexUvs[0]).length && (a = r),
                    p = 0,
                    d = c.length; p < d; p++)
                        if (f = c[p],
                        void 0 !== (r = o ? n[f.materialIndex] : n)) {
                            if (h = s[f.a],
                            l = s[f.b],
                            u = s[f.c],
                            !0 === r.morphTargets) {
                                m = i.morphTargets,
                                g = this.morphTargetInfluences,
                                _s.set(0, 0, 0),
                                Ms.set(0, 0, 0),
                                Es.set(0, 0, 0);
                                for (var v = 0, y = m.length; v < y; v++) {
                                    var x, b = g[v];
                                    0 !== b && (x = m[v].vertices,
                                    _s.addScaledVector(Ss.subVectors(x[f.a], h), b),
                                    Ms.addScaledVector(Ts.subVectors(x[f.b], l), b),
                                    Es.addScaledVector(As.subVectors(x[f.c], u), b))
                                }
                                _s.add(h),
                                Ms.add(l),
                                Es.add(u),
                                h = _s,
                                l = Ms,
                                u = Es
                            }
                            (r = Us(this, r, e, bs, h, l, u, Cs)) && (a && a[p] && (m = a[p],
                            Ls.copy(m[0]),
                            Ps.copy(m[1]),
                            Rs.copy(m[2]),
                            r.uv = w.getUV(Cs, h, l, u, Ls, Ps, Rs, new Y)),
                            r.face = f,
                            r.faceIndex = p,
                            t.push(r))
                        }
        }
        ),
        clone: function() {
            return new this.constructor(this.geometry,this.material).copy(this)
        }
    }),
    ((ae.prototype = Object.create(p.prototype)).constructor = ae).prototype.isCubeTexture = !0,
    Object.defineProperty(ae.prototype, "images", {
        get: function() {
            return this.image
        },
        set: function(e) {
            this.image = e
        }
    }),
    ((oe.prototype = Object.create(p.prototype)).constructor = oe).prototype.isDataTexture3D = !0;
    var Fs, Hs, ks, Vs, js, Ws, qs, Xs, Ys, Js, Zs, Qs, Ks, $s, ec, tc, ic, nc, rc, ac, oc, sc, cc, hc, lc, uc, pc, dc, fc = new p, mc = new oe, gc = new ae, vc = [], yc = [], xc = new Float32Array(16), bc = new Float32Array(9), wc = new Float32Array(4), _c = (et.prototype.updateCache = function(e) {
        var t = this.cache;
        e instanceof Float32Array && t.length !== e.length && (this.cache = new Float32Array(e.length)),
        s(t, e)
    }
    ,
    tt.prototype.setValue = function(e, t, i) {
        for (var n = this.seq, r = 0, a = n.length; r !== a; ++r) {
            var o = n[r];
            o.setValue(e, t[o.id], i)
        }
    }
    ,
    /([\w\d_]+)(\])?(\[|\.)?/g), Mc = (it.prototype.setValue = function(e, t, i) {
        void 0 !== (t = this.map[t]) && t.setValue(e, i, this.renderer)
    }
    ,
    it.prototype.setOptional = function(e, t, i) {
        void 0 !== (t = t[i]) && this.setValue(e, i, t)
    }
    ,
    it.upload = function(e, t, i, n) {
        for (var r = 0, a = t.length; r !== a; ++r) {
            var o = t[r]
              , s = i[o.id];
            !1 !== s.needsUpdate && o.setValue(e, s.value, n)
        }
    }
    ,
    it.seqWithValue = function(e, t) {
        for (var i = [], n = 0, r = e.length; n !== r; ++n) {
            var a = e[n];
            a.id in t && i.push(a)
        }
        return i
    }
    ,
    0), Ec = 0, Sc = (((_t.prototype = Object.create(a.prototype)).constructor = _t).prototype.isMeshDepthMaterial = !0,
    _t.prototype.copy = function(e) {
        return a.prototype.copy.call(this, e),
        this.depthPacking = e.depthPacking,
        this.skinning = e.skinning,
        this.morphTargets = e.morphTargets,
        this.map = e.map,
        this.alphaMap = e.alphaMap,
        this.displacementMap = e.displacementMap,
        this.displacementScale = e.displacementScale,
        this.displacementBias = e.displacementBias,
        this.wireframe = e.wireframe,
        this.wireframeLinewidth = e.wireframeLinewidth,
        this
    }
    ,
    ((Mt.prototype = Object.create(a.prototype)).constructor = Mt).prototype.isMeshDistanceMaterial = !0,
    Mt.prototype.copy = function(e) {
        return a.prototype.copy.call(this, e),
        this.referencePosition.copy(e.referencePosition),
        this.nearDistance = e.nearDistance,
        this.farDistance = e.farDistance,
        this.skinning = e.skinning,
        this.morphTargets = e.morphTargets,
        this.map = e.map,
        this.alphaMap = e.alphaMap,
        this.displacementMap = e.displacementMap,
        this.displacementScale = e.displacementScale,
        this.displacementBias = e.displacementBias,
        this
    }
    ,
    Lt.prototype = Object.assign(Object.create(u.prototype), {
        constructor: Lt,
        isGroup: !0
    }),
    Pt.prototype = Object.assign(Object.create(u.prototype), {
        constructor: Pt,
        isCamera: !0,
        copy: function(e, t) {
            return u.prototype.copy.call(this, e, t),
            this.matrixWorldInverse.copy(e.matrixWorldInverse),
            this.projectionMatrix.copy(e.projectionMatrix),
            this.projectionMatrixInverse.copy(e.projectionMatrixInverse),
            this
        },
        getWorldDirection: function(e) {
            void 0 === e && (console.warn("THREE.Camera: .getWorldDirection() target is now required"),
            e = new Me),
            this.updateMatrixWorld(!0);
            var t = this.matrixWorld.elements;
            return e.set(-t[8], -t[9], -t[10]).normalize()
        },
        updateMatrixWorld: function(e) {
            u.prototype.updateMatrixWorld.call(this, e),
            this.matrixWorldInverse.getInverse(this.matrixWorld)
        },
        clone: function() {
            return (new this.constructor).copy(this)
        }
    }),
    E.prototype = Object.assign(Object.create(Pt.prototype), {
        constructor: E,
        isPerspectiveCamera: !0,
        copy: function(e, t) {
            return Pt.prototype.copy.call(this, e, t),
            this.fov = e.fov,
            this.zoom = e.zoom,
            this.near = e.near,
            this.far = e.far,
            this.focus = e.focus,
            this.aspect = e.aspect,
            this.view = null === e.view ? null : Object.assign({}, e.view),
            this.filmGauge = e.filmGauge,
            this.filmOffset = e.filmOffset,
            this
        },
        setFocalLength: function(e) {
            e = .5 * this.getFilmHeight() / e,
            this.fov = 2 * Se.RAD2DEG * Math.atan(e),
            this.updateProjectionMatrix()
        },
        getFocalLength: function() {
            var e = Math.tan(.5 * Se.DEG2RAD * this.fov);
            return .5 * this.getFilmHeight() / e
        },
        getEffectiveFOV: function() {
            return 2 * Se.RAD2DEG * Math.atan(Math.tan(.5 * Se.DEG2RAD * this.fov) / this.zoom)
        },
        getFilmWidth: function() {
            return this.filmGauge * Math.min(this.aspect, 1)
        },
        getFilmHeight: function() {
            return this.filmGauge / Math.max(this.aspect, 1)
        },
        setViewOffset: function(e, t, i, n, r, a) {
            this.aspect = e / t,
            null === this.view && (this.view = {
                enabled: !0,
                fullWidth: 1,
                fullHeight: 1,
                offsetX: 0,
                offsetY: 0,
                width: 1,
                height: 1
            }),
            this.view.enabled = !0,
            this.view.fullWidth = e,
            this.view.fullHeight = t,
            this.view.offsetX = i,
            this.view.offsetY = n,
            this.view.width = r,
            this.view.height = a,
            this.updateProjectionMatrix()
        },
        clearViewOffset: function() {
            null !== this.view && (this.view.enabled = !1),
            this.updateProjectionMatrix()
        },
        updateProjectionMatrix: function() {
            var e, t, i = this.near, n = i * Math.tan(.5 * Se.DEG2RAD * this.fov) / this.zoom, r = 2 * n, a = this.aspect * r, o = -.5 * a, s = this.view;
            null !== this.view && this.view.enabled && (e = s.fullWidth,
            t = s.fullHeight,
            o += s.offsetX * a / e,
            n -= s.offsetY * r / t,
            a *= s.width / e,
            r *= s.height / t),
            0 !== (s = this.filmOffset) && (o += i * s / this.getFilmWidth()),
            this.projectionMatrix.makePerspective(o, o + a, n, n - r, i, this.far),
            this.projectionMatrixInverse.getInverse(this.projectionMatrix)
        },
        toJSON: function(e) {
            return (e = u.prototype.toJSON.call(this, e)).object.fov = this.fov,
            e.object.zoom = this.zoom,
            e.object.near = this.near,
            e.object.far = this.far,
            e.object.focus = this.focus,
            e.object.aspect = this.aspect,
            null !== this.view && (e.object.view = Object.assign({}, this.view)),
            e.object.filmGauge = this.filmGauge,
            e.object.filmOffset = this.filmOffset,
            e
        }
    }),
    Rt.prototype = Object.assign(Object.create(E.prototype), {
        constructor: Rt,
        isArrayCamera: !0
    }),
    new Me), Tc = new Me;
    function Ac(e, t, i, n, r, a) {
        js.subVectors(e, i).addScalar(.5).multiply(n),
        void 0 !== r ? (Ws.x = a * js.x - r * js.y,
        Ws.y = r * js.x + a * js.y) : Ws.copy(js),
        e.copy(t),
        e.x += Ws.x,
        e.y += Ws.y,
        e.applyMatrix4(qs)
    }
    Bt.prototype.isFogExp2 = !0,
    Bt.prototype.clone = function() {
        return new Bt(this.color,this.density)
    }
    ,
    Bt.prototype.toJSON = function() {
        return {
            type: "FogExp2",
            color: this.color.getHex(),
            density: this.density
        }
    }
    ,
    Nt.prototype.isFog = !0,
    Nt.prototype.clone = function() {
        return new Nt(this.color,this.near,this.far)
    }
    ,
    Nt.prototype.toJSON = function() {
        return {
            type: "Fog",
            color: this.color.getHex(),
            near: this.near,
            far: this.far
        }
    }
    ,
    zt.prototype = Object.assign(Object.create(u.prototype), {
        constructor: zt,
        isScene: !0,
        copy: function(e, t) {
            return u.prototype.copy.call(this, e, t),
            null !== e.background && (this.background = e.background.clone()),
            null !== e.fog && (this.fog = e.fog.clone()),
            null !== e.overrideMaterial && (this.overrideMaterial = e.overrideMaterial.clone()),
            this.autoUpdate = e.autoUpdate,
            this.matrixAutoUpdate = e.matrixAutoUpdate,
            this
        },
        toJSON: function(e) {
            var t = u.prototype.toJSON.call(this, e);
            return null !== this.background && (t.object.background = this.background.toJSON(e)),
            null !== this.fog && (t.object.fog = this.fog.toJSON()),
            t
        },
        dispose: function() {
            this.dispatchEvent({
                type: "dispose"
            })
        }
    }),
    Object.defineProperty(Ut.prototype, "needsUpdate", {
        set: function(e) {
            !0 === e && this.version++
        }
    }),
    Object.assign(Ut.prototype, {
        isInterleavedBuffer: !0,
        onUploadCallback: function() {},
        setArray: function(e) {
            if (Array.isArray(e))
                throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
            return this.count = void 0 !== e ? e.length / this.stride : 0,
            this.array = e,
            this
        },
        setDynamic: function(e) {
            return this.dynamic = e,
            this
        },
        copy: function(e) {
            return this.array = new e.array.constructor(e.array),
            this.count = e.count,
            this.stride = e.stride,
            this.dynamic = e.dynamic,
            this
        },
        copyAt: function(e, t, i) {
            e *= this.stride,
            i *= t.stride;
            for (var n = 0, r = this.stride; n < r; n++)
                this.array[e + n] = t.array[i + n];
            return this
        },
        set: function(e, t) {
            return this.array.set(e, t = void 0 === t ? 0 : t),
            this
        },
        clone: function() {
            return (new this.constructor).copy(this)
        },
        onUpload: function(e) {
            return this.onUploadCallback = e,
            this
        }
    }),
    Object.defineProperties(Gt.prototype, {
        count: {
            get: function() {
                return this.data.count
            }
        },
        array: {
            get: function() {
                return this.data.array
            }
        }
    }),
    Object.assign(Gt.prototype, {
        isInterleavedBufferAttribute: !0,
        setX: function(e, t) {
            return this.data.array[e * this.data.stride + this.offset] = t,
            this
        },
        setY: function(e, t) {
            return this.data.array[e * this.data.stride + this.offset + 1] = t,
            this
        },
        setZ: function(e, t) {
            return this.data.array[e * this.data.stride + this.offset + 2] = t,
            this
        },
        setW: function(e, t) {
            return this.data.array[e * this.data.stride + this.offset + 3] = t,
            this
        },
        getX: function(e) {
            return this.data.array[e * this.data.stride + this.offset]
        },
        getY: function(e) {
            return this.data.array[e * this.data.stride + this.offset + 1]
        },
        getZ: function(e) {
            return this.data.array[e * this.data.stride + this.offset + 2]
        },
        getW: function(e) {
            return this.data.array[e * this.data.stride + this.offset + 3]
        },
        setXY: function(e, t, i) {
            return e = e * this.data.stride + this.offset,
            this.data.array[e + 0] = t,
            this.data.array[e + 1] = i,
            this
        },
        setXYZ: function(e, t, i, n) {
            return e = e * this.data.stride + this.offset,
            this.data.array[e + 0] = t,
            this.data.array[e + 1] = i,
            this.data.array[e + 2] = n,
            this
        },
        setXYZW: function(e, t, i, n, r) {
            return e = e * this.data.stride + this.offset,
            this.data.array[e + 0] = t,
            this.data.array[e + 1] = i,
            this.data.array[e + 2] = n,
            this.data.array[e + 3] = r,
            this
        }
    }),
    ((Ft.prototype = Object.create(a.prototype)).constructor = Ft).prototype.isSpriteMaterial = !0,
    Ft.prototype.copy = function(e) {
        return a.prototype.copy.call(this, e),
        this.color.copy(e.color),
        this.map = e.map,
        this.rotation = e.rotation,
        this.sizeAttenuation = e.sizeAttenuation,
        this
    }
    ,
    Ht.prototype = Object.assign(Object.create(u.prototype), {
        constructor: Ht,
        isSprite: !0,
        raycast: (Hs = new Me,
        ks = new Me,
        Vs = new Me,
        js = new Y,
        Ws = new Y,
        qs = new _e,
        Xs = new Me,
        Ys = new Me,
        Js = new Me,
        Zs = new Y,
        Qs = new Y,
        Ks = new Y,
        function(e, t) {
            ks.setFromMatrixScale(this.matrixWorld),
            qs.getInverse(this.modelViewMatrix).premultiply(this.matrixWorld),
            Vs.setFromMatrixPosition(this.modelViewMatrix);
            var i, n, r = this.material.rotation;
            0 !== r && (i = Math.cos(r),
            n = Math.sin(r)),
            r = this.center,
            Ac(Xs.set(-.5, -.5, 0), Vs, r, ks, n, i),
            Ac(Ys.set(.5, -.5, 0), Vs, r, ks, n, i),
            Ac(Js.set(.5, .5, 0), Vs, r, ks, n, i),
            Zs.set(0, 0),
            Qs.set(1, 0),
            Ks.set(1, 1),
            null === e.ray.intersectTriangle(Xs, Ys, Js, !1, Hs) && (Ac(Ys.set(-.5, .5, 0), Vs, r, ks, n, i),
            Qs.set(0, 1),
            null === e.ray.intersectTriangle(Xs, Js, Ys, !1, Hs)) || (n = e.ray.origin.distanceTo(Hs)) < e.near || n > e.far || t.push({
                distance: n,
                point: Hs.clone(),
                uv: w.getUV(Hs, Xs, Ys, Js, Zs, Qs, Ks, new Y),
                face: null,
                object: this
            })
        }
        ),
        clone: function() {
            return new this.constructor(this.material).copy(this)
        },
        copy: function(e) {
            return u.prototype.copy.call(this, e),
            void 0 !== e.center && this.center.copy(e.center),
            this
        }
    }),
    kt.prototype = Object.assign(Object.create(u.prototype), {
        constructor: kt,
        copy: function(e) {
            u.prototype.copy.call(this, e, !1);
            for (var t = 0, i = (e = e.levels).length; t < i; t++) {
                var n = e[t];
                this.addLevel(n.object.clone(), n.distance)
            }
            return this
        },
        addLevel: function(e, t) {
            void 0 === t && (t = 0),
            t = Math.abs(t);
            for (var i = this.levels, n = 0; n < i.length && !(t < i[n].distance); n++)
                ;
            i.splice(n, 0, {
                distance: t,
                object: e
            }),
            this.add(e)
        },
        getObjectForDistance: function(e) {
            for (var t = this.levels, i = 1, n = t.length; i < n && !(e < t[i].distance); i++)
                ;
            return t[i - 1].object
        },
        raycast: (tc = new Me,
        function(e, t) {
            tc.setFromMatrixPosition(this.matrixWorld);
            var i = e.ray.origin.distanceTo(tc);
            this.getObjectForDistance(i).raycast(e, t)
        }
        ),
        update: ($s = new Me,
        ec = new Me,
        function(e) {
            var t = this.levels;
            if (1 < t.length) {
                $s.setFromMatrixPosition(e.matrixWorld),
                ec.setFromMatrixPosition(this.matrixWorld),
                e = $s.distanceTo(ec),
                t[0].object.visible = !0;
                for (var i = 1, n = t.length; i < n && e >= t[i].distance; i++)
                    t[i - 1].object.visible = !1,
                    t[i].object.visible = !0;
                for (; i < n; i++)
                    t[i].object.visible = !1
            }
        }
        ),
        toJSON: function(e) {
            (e = u.prototype.toJSON.call(this, e)).object.levels = [];
            for (var t = this.levels, i = 0, n = t.length; i < n; i++) {
                var r = t[i];
                e.object.levels.push({
                    object: r.object.uuid,
                    distance: r.distance
                })
            }
            return e
        }
    }),
    Vt.prototype = Object.assign(Object.create(v.prototype), {
        constructor: Vt,
        isSkinnedMesh: !0,
        bind: function(e, t) {
            this.skeleton = e,
            void 0 === t && (this.updateMatrixWorld(!0),
            this.skeleton.calculateInverses(),
            t = this.matrixWorld),
            this.bindMatrix.copy(t),
            this.bindMatrixInverse.getInverse(t)
        },
        pose: function() {
            this.skeleton.pose()
        },
        normalizeSkinWeights: function() {
            for (var e = new Ee, t = this.geometry.attributes.skinWeight, i = 0, n = t.count; i < n; i++) {
                e.x = t.getX(i),
                e.y = t.getY(i),
                e.z = t.getZ(i),
                e.w = t.getW(i);
                var r = 1 / e.manhattanLength();
                1 / 0 != r ? e.multiplyScalar(r) : e.set(1, 0, 0, 0),
                t.setXYZW(i, e.x, e.y, e.z, e.w)
            }
        },
        updateMatrixWorld: function(e) {
            v.prototype.updateMatrixWorld.call(this, e),
            "attached" === this.bindMode ? this.bindMatrixInverse.getInverse(this.matrixWorld) : "detached" === this.bindMode ? this.bindMatrixInverse.getInverse(this.bindMatrix) : console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode)
        },
        clone: function() {
            return new this.constructor(this.geometry,this.material).copy(this)
        }
    }),
    Object.assign(jt.prototype, {
        calculateInverses: function() {
            this.boneInverses = [];
            for (var e = 0, t = this.bones.length; e < t; e++) {
                var i = new _e;
                this.bones[e] && i.getInverse(this.bones[e].matrixWorld),
                this.boneInverses.push(i)
            }
        },
        pose: function() {
            for (var e, t = 0, i = this.bones.length; t < i; t++)
                (e = this.bones[t]) && e.matrixWorld.getInverse(this.boneInverses[t]);
            for (t = 0,
            i = this.bones.length; t < i; t++)
                (e = this.bones[t]) && (e.parent && e.parent.isBone ? (e.matrix.getInverse(e.parent.matrixWorld),
                e.matrix.multiply(e.matrixWorld)) : e.matrix.copy(e.matrixWorld),
                e.matrix.decompose(e.position, e.quaternion, e.scale))
        },
        update: (ic = new _e,
        nc = new _e,
        function() {
            for (var e = this.bones, t = this.boneInverses, i = this.boneMatrices, n = this.boneTexture, r = 0, a = e.length; r < a; r++)
                ic.multiplyMatrices(e[r] ? e[r].matrixWorld : nc, t[r]),
                ic.toArray(i, 16 * r);
            void 0 !== n && (n.needsUpdate = !0)
        }
        ),
        clone: function() {
            return new jt(this.bones,this.boneInverses)
        },
        getBoneByName: function(e) {
            for (var t = 0, i = this.bones.length; t < i; t++) {
                var n = this.bones[t];
                if (n.name === e)
                    return n
            }
        }
    }),
    Wt.prototype = Object.assign(Object.create(u.prototype), {
        constructor: Wt,
        isBone: !0
    }),
    ((y.prototype = Object.create(a.prototype)).constructor = y).prototype.isLineBasicMaterial = !0,
    y.prototype.copy = function(e) {
        return a.prototype.copy.call(this, e),
        this.color.copy(e.color),
        this.linewidth = e.linewidth,
        this.linecap = e.linecap,
        this.linejoin = e.linejoin,
        this
    }
    ,
    h.prototype = Object.assign(Object.create(u.prototype), {
        constructor: h,
        isLine: !0,
        computeLineDistances: (sc = new Me,
        cc = new Me,
        function() {
            var e = this.geometry;
            if (e.isBufferGeometry)
                if (null === e.index) {
                    for (var t = e.attributes.position, i = [0], n = 1, r = t.count; n < r; n++)
                        sc.fromBufferAttribute(t, n - 1),
                        cc.fromBufferAttribute(t, n),
                        i[n] = i[n - 1],
                        i[n] += sc.distanceTo(cc);
                    e.addAttribute("lineDistance", new z(i,1))
                } else
                    console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
            else if (e.isGeometry)
                for (t = e.vertices,
                (i = e.lineDistances)[0] = 0,
                n = 1,
                r = t.length; n < r; n++)
                    i[n] = i[n - 1],
                    i[n] += t[n - 1].distanceTo(t[n]);
            return this
        }
        ),
        raycast: (rc = new _e,
        ac = new ie,
        oc = new I,
        function(e, t) {
            var i = e.linePrecision
              , n = this.geometry
              , r = this.matrixWorld;
            if (null === n.boundingSphere && n.computeBoundingSphere(),
            oc.copy(n.boundingSphere),
            oc.applyMatrix4(r),
            oc.radius += i,
            !1 !== e.ray.intersectsSphere(oc)) {
                rc.getInverse(r),
                ac.copy(e.ray).applyMatrix4(rc);
                var i = (i /= (this.scale.x + this.scale.y + this.scale.z) / 3) * i
                  , a = new Me
                  , o = new Me
                  , r = new Me
                  , s = new Me
                  , c = this && this.isLineSegments ? 2 : 1;
                if (n.isBufferGeometry) {
                    var h = n.index
                      , l = n.attributes.position.array;
                    if (null !== h)
                        for (var n = 0, u = (h = h.array).length - 1; n < u; n += c) {
                            var p = h[n + 1];
                            a.fromArray(l, 3 * h[n]),
                            o.fromArray(l, 3 * p),
                            i < (p = ac.distanceSqToSegment(a, o, s, r)) || (s.applyMatrix4(this.matrixWorld),
                            (p = e.ray.origin.distanceTo(s)) < e.near) || p > e.far || t.push({
                                distance: p,
                                point: r.clone().applyMatrix4(this.matrixWorld),
                                index: n,
                                face: null,
                                faceIndex: null,
                                object: this
                            })
                        }
                    else
                        for (n = 0,
                        u = l.length / 3 - 1; n < u; n += c)
                            a.fromArray(l, 3 * n),
                            o.fromArray(l, 3 * n + 3),
                            i < (p = ac.distanceSqToSegment(a, o, s, r)) || (s.applyMatrix4(this.matrixWorld),
                            (p = e.ray.origin.distanceTo(s)) < e.near) || p > e.far || t.push({
                                distance: p,
                                point: r.clone().applyMatrix4(this.matrixWorld),
                                index: n,
                                face: null,
                                faceIndex: null,
                                object: this
                            })
                } else if (n.isGeometry)
                    for (o = (a = n.vertices).length,
                    n = 0; n < o - 1; n += c)
                        i < (p = ac.distanceSqToSegment(a[n], a[n + 1], s, r)) || (s.applyMatrix4(this.matrixWorld),
                        (p = e.ray.origin.distanceTo(s)) < e.near) || p > e.far || t.push({
                            distance: p,
                            point: r.clone().applyMatrix4(this.matrixWorld),
                            index: n,
                            face: null,
                            faceIndex: null,
                            object: this
                        })
            }
        }
        ),
        copy: function(e) {
            return u.prototype.copy.call(this, e),
            this.geometry.copy(e.geometry),
            this.material.copy(e.material),
            this
        },
        clone: function() {
            return (new this.constructor).copy(this)
        }
    }),
    x.prototype = Object.assign(Object.create(h.prototype), {
        constructor: x,
        isLineSegments: !0,
        computeLineDistances: (hc = new Me,
        lc = new Me,
        function() {
            var e = this.geometry;
            if (e.isBufferGeometry)
                if (null === e.index) {
                    for (var t = e.attributes.position, i = [], n = 0, r = t.count; n < r; n += 2)
                        hc.fromBufferAttribute(t, n),
                        lc.fromBufferAttribute(t, n + 1),
                        i[n] = 0 === n ? 0 : i[n - 1],
                        i[n + 1] = i[n] + hc.distanceTo(lc);
                    e.addAttribute("lineDistance", new z(i,1))
                } else
                    console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
            else if (e.isGeometry)
                for (t = e.vertices,
                i = e.lineDistances,
                n = 0,
                r = t.length; n < r; n += 2)
                    hc.copy(t[n]),
                    lc.copy(t[n + 1]),
                    i[n] = 0 === n ? 0 : i[n - 1],
                    i[n + 1] = i[n] + hc.distanceTo(lc);
            return this
        }
        )
    }),
    qt.prototype = Object.assign(Object.create(h.prototype), {
        constructor: qt,
        isLineLoop: !0
    }),
    ((Xt.prototype = Object.create(a.prototype)).constructor = Xt).prototype.isPointsMaterial = !0,
    Xt.prototype.copy = function(e) {
        return a.prototype.copy.call(this, e),
        this.color.copy(e.color),
        this.map = e.map,
        this.size = e.size,
        this.sizeAttenuation = e.sizeAttenuation,
        this.morphTargets = e.morphTargets,
        this
    }
    ,
    Yt.prototype = Object.assign(Object.create(u.prototype), {
        constructor: Yt,
        isPoints: !0,
        raycast: (uc = new _e,
        pc = new ie,
        dc = new I,
        function(n, r) {
            function e(e, t) {
                var i = pc.distanceSqToPoint(e);
                i < s && (pc.closestPointToPoint(e, c),
                c.applyMatrix4(o),
                (e = n.ray.origin.distanceTo(c)) < n.near || e > n.far || r.push({
                    distance: e,
                    distanceToRay: Math.sqrt(i),
                    point: c.clone(),
                    index: t,
                    face: null,
                    object: a
                }))
            }
            var a = this
              , t = this.geometry
              , o = this.matrixWorld
              , i = n.params.Points.threshold;
            if (null === t.boundingSphere && t.computeBoundingSphere(),
            dc.copy(t.boundingSphere),
            dc.applyMatrix4(o),
            dc.radius += i,
            !1 !== n.ray.intersectsSphere(dc)) {
                uc.getInverse(o),
                pc.copy(n.ray).applyMatrix4(uc);
                var s = (i /= (this.scale.x + this.scale.y + this.scale.z) / 3) * i
                  , i = new Me
                  , c = new Me;
                if (t.isBufferGeometry) {
                    var h = t.index
                      , t = t.attributes.position.array;
                    if (null !== h)
                        for (var l = h.array, h = 0, u = l.length; h < u; h++) {
                            var p = l[h];
                            i.fromArray(t, 3 * p),
                            e(i, p)
                        }
                    else
                        for (h = 0,
                        l = t.length / 3; h < l; h++)
                            i.fromArray(t, 3 * h),
                            e(i, h)
                } else
                    for (h = 0,
                    l = (i = t.vertices).length; h < l; h++)
                        e(i[h], h)
            }
        }
        ),
        clone: function() {
            return new this.constructor(this.geometry,this.material).copy(this)
        }
    }),
    Jt.prototype = Object.assign(Object.create(p.prototype), {
        constructor: Jt,
        isVideoTexture: !0,
        update: function() {
            var e = this.image;
            e.readyState >= e.HAVE_CURRENT_DATA && (this.needsUpdate = !0)
        }
    }),
    ((Zt.prototype = Object.create(p.prototype)).constructor = Zt).prototype.isCompressedTexture = !0,
    ((Qt.prototype = Object.create(p.prototype)).constructor = Qt).prototype.isCanvasTexture = !0,
    ((Kt.prototype = Object.create(p.prototype)).constructor = Kt).prototype.isDepthTexture = !0,
    ($t.prototype = Object.create(U.prototype)).constructor = $t,
    (ei.prototype = Object.create(f.prototype)).constructor = ei,
    (ti.prototype = Object.create(U.prototype)).constructor = ti,
    (ii.prototype = Object.create(f.prototype)).constructor = ii,
    (ni.prototype = Object.create(U.prototype)).constructor = ni,
    (ri.prototype = Object.create(f.prototype)).constructor = ri,
    (ai.prototype = Object.create(ni.prototype)).constructor = ai,
    (oi.prototype = Object.create(f.prototype)).constructor = oi,
    (si.prototype = Object.create(ni.prototype)).constructor = si,
    (ci.prototype = Object.create(f.prototype)).constructor = ci,
    (hi.prototype = Object.create(ni.prototype)).constructor = hi,
    (li.prototype = Object.create(f.prototype)).constructor = li,
    (ui.prototype = Object.create(ni.prototype)).constructor = ui,
    (pi.prototype = Object.create(f.prototype)).constructor = pi,
    (di.prototype = Object.create(U.prototype)).constructor = di,
    (fi.prototype = Object.create(f.prototype)).constructor = fi,
    (mi.prototype = Object.create(U.prototype)).constructor = mi,
    (gi.prototype = Object.create(f.prototype)).constructor = gi,
    (vi.prototype = Object.create(U.prototype)).constructor = vi;
    var Lc, Pc, Rc, Cc, Oc = function(e, t, i) {
        i = i || 2;
        var n, r = (c = t && t.length) ? t[0] * i : e.length, a = yi(e, 0, r, i, !0), o = [];
        if (a) {
            if (c) {
                for (var s = i, c = [], h = 0, l = t.length; h < l; h++) {
                    var u = t[h] * s;
                    (u = yi(e, u, h < l - 1 ? t[h + 1] * s : e.length, s, !1)) === u.next && (u.steiner = !0),
                    c.push(function(e) {
                        for (var t = e, i = e; t.x < i.x && (i = t),
                        (t = t.next) !== e; )
                            ;
                        return i
                    }(u))
                }
                for (c.sort(bi),
                h = 0; h < c.length; h++)
                    (s = function(e, t) {
                        var i = t
                          , n = e.x
                          , r = e.y
                          , a = -1 / 0;
                        do {
                            if (r <= i.y && r >= i.next.y && i.next.y !== i.y) {
                                var o = i.x + (r - i.y) * (i.next.x - i.x) / (i.next.y - i.y);
                                if (o <= n && a < o) {
                                    if ((a = o) === n) {
                                        if (r === i.y)
                                            return i;
                                        if (r === i.next.y)
                                            return i.next
                                    }
                                    var s = i.x < i.next.x ? i : i.next
                                }
                            }
                        } while ((i = i.next) !== t);
                        if (!s)
                            return null;
                        if (n === a)
                            return s.prev;
                        for (var c, o = (t = s).x, h = s.y, l = 1 / 0, i = s.next; i !== t; )
                            n >= i.x && i.x >= o && n !== i.x && _i(r < h ? n : a, r, o, h, r < h ? a : n, r, i.x, i.y) && ((c = Math.abs(r - i.y) / (n - i.x)) < l || c === l && i.x > s.x) && Si(i, e) && (s = i,
                            l = c),
                            i = i.next;
                        return s
                    }(t = c[h], s = a)) && xi(t = Ti(s, t), t.next),
                    a = xi(a, a.next)
            }
            if (e.length > 80 * i) {
                for (var p = n = e[0], d = c = e[1], s = i; s < r; s += i)
                    (h = e[s]) < p && (p = h),
                    (t = e[s + 1]) < d && (d = t),
                    n < h && (n = h),
                    c < t && (c = t);
                n = 0 !== (n = Math.max(n - p, c - d)) ? 1 / n : 0
            }
            !function e(t, i, n, r, a, o, s) {
                if (t) {
                    if (!s && o) {
                        for (var c = l = t; null === c.z && (c.z = wi(c.x, c.y, r, a, o)),
                        c.prevZ = c.prev,
                        (c = c.nextZ = c.next) !== l; )
                            ;
                        c.prevZ.nextZ = null,
                        c.prevZ = null;
                        var h, l = c, u = 1;
                        do {
                            for (var c = l, p = l = null, d = 0; c; ) {
                                d++;
                                for (var f = c, m = h = 0; m < u && (h++,
                                f = f.nextZ); m++)
                                    ;
                                for (g = u; 0 < h || 0 < g && f; )
                                    0 !== h && (0 === g || !f || c.z <= f.z) ? (c = (m = c).nextZ,
                                    h--) : (f = (m = f).nextZ,
                                    g--),
                                    p ? p.nextZ = m : l = m,
                                    m.prevZ = p,
                                    p = m;
                                c = f
                            }
                        } while (p.nextZ = null,
                        u *= 2,
                        1 < d)
                    }
                    for (l = t; t.prev !== t.next; ) {
                        if (c = t.prev,
                        f = t.next,
                        o)
                            e: {
                                var g = r
                                  , v = a;
                                if (0 <= b(d = (p = t).prev, h = p, u = p.next))
                                    p = !1;
                                else {
                                    var y = (d.x > h.x ? d.x > u.x ? d : u : h.x > u.x ? h : u).x
                                      , x = (d.y > h.y ? d.y > u.y ? d : u : h.y > u.y ? h : u).y;
                                    for (m = wi((d.x < h.x ? d.x < u.x ? d : u : h.x < u.x ? h : u).x, (d.y < h.y ? d.y < u.y ? d : u : h.y < u.y ? h : u).y, g, v, o),
                                    g = wi(y, x, g, v, o),
                                    v = p.nextZ; v && v.z <= g; ) {
                                        if (v !== p.prev && v !== p.next && _i(d.x, d.y, h.x, h.y, u.x, u.y, v.x, v.y) && 0 <= b(v.prev, v, v.next)) {
                                            p = !1;
                                            break e
                                        }
                                        v = v.nextZ
                                    }
                                    for (v = p.prevZ; v && v.z >= m; ) {
                                        if (v !== p.prev && v !== p.next && _i(d.x, d.y, h.x, h.y, u.x, u.y, v.x, v.y) && 0 <= b(v.prev, v, v.next)) {
                                            p = !1;
                                            break e
                                        }
                                        v = v.prevZ
                                    }
                                    p = !0
                                }
                            }
                        else
                            e: if (0 <= b(d = (p = t).prev, h = p, u = p.next))
                                p = !1;
                            else {
                                for (m = p.next.next; m !== p.prev; ) {
                                    if (_i(d.x, d.y, h.x, h.y, u.x, u.y, m.x, m.y) && 0 <= b(m.prev, m, m.next)) {
                                        p = !1;
                                        break e
                                    }
                                    m = m.next
                                }
                                p = !0
                            }
                        if (p)
                            i.push(c.i / n),
                            i.push(t.i / n),
                            i.push(f.i / n),
                            Li(t),
                            l = t = f.next;
                        else if ((t = f) === l) {
                            if (s) {
                                if (1 === s) {
                                    for (s = i,
                                    l = n,
                                    c = t; !Mi(f = c.prev, p = c.next.next) && Ei(f, c, c.next, p) && Si(f, p) && Si(p, f) && (s.push(f.i / l),
                                    s.push(c.i / l),
                                    s.push(p.i / l),
                                    Li(c),
                                    Li(c.next),
                                    c = t = p),
                                    (c = c.next) !== t; )
                                        ;
                                    e(t = c, i, n, r, a, o, 2)
                                } else if (2 === s)
                                    e: {
                                        s = t;
                                        do {
                                            for (l = s.next.next; l !== s.prev; ) {
                                                if (c = s.i !== l.i) {
                                                    if (f = l,
                                                    p = (c = s).next.i !== f.i && c.prev.i !== f.i) {
                                                        t: {
                                                            p = c;
                                                            do {
                                                                if (p.i !== c.i && p.next.i !== c.i && p.i !== f.i && p.next.i !== f.i && Ei(p, p.next, c, f)) {
                                                                    p = !0;
                                                                    break t
                                                                }
                                                            } while ((p = p.next) !== c);
                                                            p = !1
                                                        }
                                                        p = !p
                                                    }
                                                    if (p = p && Si(c, f) && Si(f, c)) {
                                                        for (d = !1,
                                                        h = ((p = c).x + f.x) / 2,
                                                        f = (c.y + f.y) / 2; p.y > f != p.next.y > f && p.next.y !== p.y && h < (p.next.x - p.x) * (f - p.y) / (p.next.y - p.y) + p.x && (d = !d),
                                                        (p = p.next) !== c; )
                                                            ;
                                                        p = d
                                                    }
                                                    c = p
                                                }
                                                if (c) {
                                                    t = Ti(s, l),
                                                    s = xi(s, s.next),
                                                    t = xi(t, t.next),
                                                    e(s, i, n, r, a, o),
                                                    e(t, i, n, r, a, o);
                                                    break e
                                                }
                                                l = l.next
                                            }
                                        } while ((s = s.next) !== t)
                                    }
                            } else
                                e(xi(t), i, n, r, a, o, 1);
                            break
                        }
                    }
                }
            }(a, o, i, p, d, n)
        }
        return o
    }, Ic = {
        area: function(e) {
            for (var t = e.length, i = 0, n = t - 1, r = 0; r < t; n = r++)
                i += e[n].x * e[r].y - e[r].x * e[n].y;
            return .5 * i
        },
        isClockWise: function(e) {
            return Ic.area(e) < 0
        },
        triangulateShape: function(e, t) {
            var i = []
              , n = []
              , r = []
              , a = (Ri(e),
            Ci(i, e),
            e.length);
            for (t.forEach(Ri),
            e = 0; e < t.length; e++)
                n.push(a),
                a += t[e].length,
                Ci(i, t[e]);
            for (t = Oc(i, n),
            e = 0; e < t.length; e += 3)
                r.push(t.slice(e, e + 3));
            return r
        }
    }, Dc = (((Oi.prototype = Object.create(f.prototype)).constructor = Oi).prototype.toJSON = function() {
        var e = f.prototype.toJSON.call(this);
        return Di(this.parameters.shapes, this.parameters.options, e)
    }
    ,
    ((Ii.prototype = Object.create(U.prototype)).constructor = Ii).prototype.toJSON = function() {
        var e = U.prototype.toJSON.call(this);
        return Di(this.parameters.shapes, this.parameters.options, e)
    }
    ,
    {
        generateTopUV: function(e, t, i, n, r) {
            e = t[3 * n],
            n = t[3 * n + 1];
            var a = t[3 * r];
            return r = t[3 * r + 1],
            [new Y(t[3 * i],t[3 * i + 1]), new Y(e,n), new Y(a,r)]
        },
        generateSideWallUV: function(e, t, i, n, r, a) {
            e = t[3 * i];
            var o = t[3 * i + 1]
              , s = (i = t[3 * i + 2],
            t[3 * n])
              , c = t[3 * n + 1]
              , h = (n = t[3 * n + 2],
            t[3 * r])
              , l = t[3 * r + 1]
              , u = (r = t[3 * r + 2],
            t[3 * a])
              , p = t[3 * a + 1];
            return t = t[3 * a + 2],
            Math.abs(o - c) < .01 ? [new Y(e,1 - i), new Y(s,1 - n), new Y(h,1 - r), new Y(u,1 - t)] : [new Y(o,1 - i), new Y(c,1 - n), new Y(l,1 - r), new Y(p,1 - t)]
        }
    }), Bc = ((Bi.prototype = Object.create(f.prototype)).constructor = Bi,
    (Ni.prototype = Object.create(Ii.prototype)).constructor = Ni,
    (zi.prototype = Object.create(f.prototype)).constructor = zi,
    (Ui.prototype = Object.create(U.prototype)).constructor = Ui,
    (Gi.prototype = Object.create(f.prototype)).constructor = Gi,
    (Fi.prototype = Object.create(U.prototype)).constructor = Fi,
    (Hi.prototype = Object.create(f.prototype)).constructor = Hi,
    (ki.prototype = Object.create(U.prototype)).constructor = ki,
    ((Vi.prototype = Object.create(f.prototype)).constructor = Vi).prototype.toJSON = function() {
        var e = f.prototype.toJSON.call(this);
        return Wi(this.parameters.shapes, e)
    }
    ,
    ((ji.prototype = Object.create(U.prototype)).constructor = ji).prototype.toJSON = function() {
        var e = U.prototype.toJSON.call(this);
        return Wi(this.parameters.shapes, e)
    }
    ,
    (qi.prototype = Object.create(U.prototype)).constructor = qi,
    (Xi.prototype = Object.create(f.prototype)).constructor = Xi,
    (Yi.prototype = Object.create(U.prototype)).constructor = Yi,
    (Ji.prototype = Object.create(Xi.prototype)).constructor = Ji,
    (Zi.prototype = Object.create(Yi.prototype)).constructor = Zi,
    (Qi.prototype = Object.create(f.prototype)).constructor = Qi,
    (Ki.prototype = Object.create(U.prototype)).constructor = Ki,
    Object.freeze({
        WireframeGeometry: $t,
        ParametricGeometry: ei,
        ParametricBufferGeometry: ti,
        TetrahedronGeometry: ri,
        TetrahedronBufferGeometry: ai,
        OctahedronGeometry: oi,
        OctahedronBufferGeometry: si,
        IcosahedronGeometry: ci,
        IcosahedronBufferGeometry: hi,
        DodecahedronGeometry: li,
        DodecahedronBufferGeometry: ui,
        PolyhedronGeometry: ii,
        PolyhedronBufferGeometry: ni,
        TubeGeometry: pi,
        TubeBufferGeometry: di,
        TorusKnotGeometry: fi,
        TorusKnotBufferGeometry: mi,
        TorusGeometry: gi,
        TorusBufferGeometry: vi,
        TextGeometry: Bi,
        TextBufferGeometry: Ni,
        SphereGeometry: zi,
        SphereBufferGeometry: Ui,
        RingGeometry: Gi,
        RingBufferGeometry: Fi,
        PlaneGeometry: $,
        PlaneBufferGeometry: ee,
        LatheGeometry: Hi,
        LatheBufferGeometry: ki,
        ShapeGeometry: Vi,
        ShapeBufferGeometry: ji,
        ExtrudeGeometry: Oi,
        ExtrudeBufferGeometry: Ii,
        EdgesGeometry: qi,
        ConeGeometry: Ji,
        ConeBufferGeometry: Zi,
        CylinderGeometry: Xi,
        CylinderBufferGeometry: Yi,
        CircleGeometry: Qi,
        CircleBufferGeometry: Ki,
        BoxGeometry: Q,
        BoxBufferGeometry: K
    })), Nc = ((($i.prototype = Object.create(a.prototype)).constructor = $i).prototype.isShadowMaterial = !0,
    $i.prototype.copy = function(e) {
        return a.prototype.copy.call(this, e),
        this.color.copy(e.color),
        this
    }
    ,
    ((en.prototype = Object.create(te.prototype)).constructor = en).prototype.isRawShaderMaterial = !0,
    ((tn.prototype = Object.create(a.prototype)).constructor = tn).prototype.isMeshStandardMaterial = !0,
    tn.prototype.copy = function(e) {
        return a.prototype.copy.call(this, e),
        this.defines = {
            STANDARD: ""
        },
        this.color.copy(e.color),
        this.roughness = e.roughness,
        this.metalness = e.metalness,
        this.map = e.map,
        this.lightMap = e.lightMap,
        this.lightMapIntensity = e.lightMapIntensity,
        this.aoMap = e.aoMap,
        this.aoMapIntensity = e.aoMapIntensity,
        this.emissive.copy(e.emissive),
        this.emissiveMap = e.emissiveMap,
        this.emissiveIntensity = e.emissiveIntensity,
        this.bumpMap = e.bumpMap,
        this.bumpScale = e.bumpScale,
        this.normalMap = e.normalMap,
        this.normalMapType = e.normalMapType,
        this.normalScale.copy(e.normalScale),
        this.displacementMap = e.displacementMap,
        this.displacementScale = e.displacementScale,
        this.displacementBias = e.displacementBias,
        this.roughnessMap = e.roughnessMap,
        this.metalnessMap = e.metalnessMap,
        this.alphaMap = e.alphaMap,
        this.envMap = e.envMap,
        this.envMapIntensity = e.envMapIntensity,
        this.refractionRatio = e.refractionRatio,
        this.wireframe = e.wireframe,
        this.wireframeLinewidth = e.wireframeLinewidth,
        this.wireframeLinecap = e.wireframeLinecap,
        this.wireframeLinejoin = e.wireframeLinejoin,
        this.skinning = e.skinning,
        this.morphTargets = e.morphTargets,
        this.morphNormals = e.morphNormals,
        this
    }
    ,
    ((nn.prototype = Object.create(tn.prototype)).constructor = nn).prototype.isMeshPhysicalMaterial = !0,
    nn.prototype.copy = function(e) {
        return tn.prototype.copy.call(this, e),
        this.defines = {
            PHYSICAL: ""
        },
        this.reflectivity = e.reflectivity,
        this.clearCoat = e.clearCoat,
        this.clearCoatRoughness = e.clearCoatRoughness,
        this
    }
    ,
    ((rn.prototype = Object.create(a.prototype)).constructor = rn).prototype.isMeshPhongMaterial = !0,
    rn.prototype.copy = function(e) {
        return a.prototype.copy.call(this, e),
        this.color.copy(e.color),
        this.specular.copy(e.specular),
        this.shininess = e.shininess,
        this.map = e.map,
        this.lightMap = e.lightMap,
        this.lightMapIntensity = e.lightMapIntensity,
        this.aoMap = e.aoMap,
        this.aoMapIntensity = e.aoMapIntensity,
        this.emissive.copy(e.emissive),
        this.emissiveMap = e.emissiveMap,
        this.emissiveIntensity = e.emissiveIntensity,
        this.bumpMap = e.bumpMap,
        this.bumpScale = e.bumpScale,
        this.normalMap = e.normalMap,
        this.normalMapType = e.normalMapType,
        this.normalScale.copy(e.normalScale),
        this.displacementMap = e.displacementMap,
        this.displacementScale = e.displacementScale,
        this.displacementBias = e.displacementBias,
        this.specularMap = e.specularMap,
        this.alphaMap = e.alphaMap,
        this.envMap = e.envMap,
        this.combine = e.combine,
        this.reflectivity = e.reflectivity,
        this.refractionRatio = e.refractionRatio,
        this.wireframe = e.wireframe,
        this.wireframeLinewidth = e.wireframeLinewidth,
        this.wireframeLinecap = e.wireframeLinecap,
        this.wireframeLinejoin = e.wireframeLinejoin,
        this.skinning = e.skinning,
        this.morphTargets = e.morphTargets,
        this.morphNormals = e.morphNormals,
        this
    }
    ,
    ((an.prototype = Object.create(rn.prototype)).constructor = an).prototype.isMeshToonMaterial = !0,
    an.prototype.copy = function(e) {
        return rn.prototype.copy.call(this, e),
        this.gradientMap = e.gradientMap,
        this
    }
    ,
    ((on.prototype = Object.create(a.prototype)).constructor = on).prototype.isMeshNormalMaterial = !0,
    on.prototype.copy = function(e) {
        return a.prototype.copy.call(this, e),
        this.bumpMap = e.bumpMap,
        this.bumpScale = e.bumpScale,
        this.normalMap = e.normalMap,
        this.normalMapType = e.normalMapType,
        this.normalScale.copy(e.normalScale),
        this.displacementMap = e.displacementMap,
        this.displacementScale = e.displacementScale,
        this.displacementBias = e.displacementBias,
        this.wireframe = e.wireframe,
        this.wireframeLinewidth = e.wireframeLinewidth,
        this.skinning = e.skinning,
        this.morphTargets = e.morphTargets,
        this.morphNormals = e.morphNormals,
        this
    }
    ,
    ((sn.prototype = Object.create(a.prototype)).constructor = sn).prototype.isMeshLambertMaterial = !0,
    sn.prototype.copy = function(e) {
        return a.prototype.copy.call(this, e),
        this.color.copy(e.color),
        this.map = e.map,
        this.lightMap = e.lightMap,
        this.lightMapIntensity = e.lightMapIntensity,
        this.aoMap = e.aoMap,
        this.aoMapIntensity = e.aoMapIntensity,
        this.emissive.copy(e.emissive),
        this.emissiveMap = e.emissiveMap,
        this.emissiveIntensity = e.emissiveIntensity,
        this.specularMap = e.specularMap,
        this.alphaMap = e.alphaMap,
        this.envMap = e.envMap,
        this.combine = e.combine,
        this.reflectivity = e.reflectivity,
        this.refractionRatio = e.refractionRatio,
        this.wireframe = e.wireframe,
        this.wireframeLinewidth = e.wireframeLinewidth,
        this.wireframeLinecap = e.wireframeLinecap,
        this.wireframeLinejoin = e.wireframeLinejoin,
        this.skinning = e.skinning,
        this.morphTargets = e.morphTargets,
        this.morphNormals = e.morphNormals,
        this
    }
    ,
    ((cn.prototype = Object.create(a.prototype)).constructor = cn).prototype.isMeshMatcapMaterial = !0,
    cn.prototype.copy = function(e) {
        return a.prototype.copy.call(this, e),
        this.defines = {
            MATCAP: ""
        },
        this.color.copy(e.color),
        this.matcap = e.matcap,
        this.map = e.map,
        this.bumpMap = e.bumpMap,
        this.bumpScale = e.bumpScale,
        this.normalMap = e.normalMap,
        this.normalMapType = e.normalMapType,
        this.normalScale.copy(e.normalScale),
        this.displacementMap = e.displacementMap,
        this.displacementScale = e.displacementScale,
        this.displacementBias = e.displacementBias,
        this.alphaMap = e.alphaMap,
        this.skinning = e.skinning,
        this.morphTargets = e.morphTargets,
        this.morphNormals = e.morphNormals,
        this
    }
    ,
    ((hn.prototype = Object.create(y.prototype)).constructor = hn).prototype.isLineDashedMaterial = !0,
    hn.prototype.copy = function(e) {
        return y.prototype.copy.call(this, e),
        this.scale = e.scale,
        this.dashSize = e.dashSize,
        this.gapSize = e.gapSize,
        this
    }
    ,
    Object.freeze({
        ShadowMaterial: $i,
        SpriteMaterial: Ft,
        RawShaderMaterial: en,
        ShaderMaterial: te,
        PointsMaterial: Xt,
        MeshPhysicalMaterial: nn,
        MeshStandardMaterial: tn,
        MeshPhongMaterial: rn,
        MeshToonMaterial: an,
        MeshNormalMaterial: on,
        MeshLambertMaterial: sn,
        MeshDepthMaterial: _t,
        MeshDistanceMaterial: Mt,
        MeshBasicMaterial: ne,
        MeshMatcapMaterial: cn,
        LineDashedMaterial: hn,
        LineBasicMaterial: y,
        Material: a
    })), A = {
        arraySlice: function(e, t, i) {
            return A.isTypedArray(e) ? new e.constructor(e.subarray(t, void 0 !== i ? i : e.length)) : e.slice(t, i)
        },
        convertArray: function(e, t, i) {
            return !e || !i && e.constructor === t ? e : "number" == typeof t.BYTES_PER_ELEMENT ? new t(e) : Array.prototype.slice.call(e)
        },
        isTypedArray: function(e) {
            return ArrayBuffer.isView(e) && !(e instanceof DataView)
        },
        getKeyframeOrder: function(i) {
            for (var e = i.length, t = Array(e), n = 0; n !== e; ++n)
                t[n] = n;
            return t.sort(function(e, t) {
                return i[e] - i[t]
            }),
            t
        },
        sortedArray: function(e, t, i) {
            for (var n = e.length, r = new e.constructor(n), a = 0, o = 0; o !== n; ++a)
                for (var s = i[a] * t, c = 0; c !== t; ++c)
                    r[o++] = e[s + c];
            return r
        },
        flattenJSON: function(e, t, i, n) {
            for (var r = 1, a = e[0]; void 0 !== a && void 0 === a[n]; )
                a = e[r++];
            if (void 0 !== a) {
                var o = a[n];
                if (void 0 !== o)
                    if (Array.isArray(o))
                        for (; void 0 !== (o = a[n]) && (t.push(a.time),
                        i.push.apply(i, o)),
                        void 0 !== (a = e[r++]); )
                            ;
                    else if (void 0 !== o.toArray)
                        for (; void 0 !== (o = a[n]) && (t.push(a.time),
                        o.toArray(i, i.length)),
                        void 0 !== (a = e[r++]); )
                            ;
                    else
                        for (; void 0 !== (o = a[n]) && (t.push(a.time),
                        i.push(o)),
                        void 0 !== (a = e[r++]); )
                            ;
            }
        }
    }, zc = (Object.assign(ln.prototype, {
        evaluate: function(e) {
            var t = this.parameterPositions
              , i = this._cachedIndex
              , n = t[i]
              , r = t[i - 1];
            e: {
                t: {
                    i: {
                        n: if (!(e < n)) {
                            for (var a = i + 2; ; ) {
                                if (void 0 === n) {
                                    if (e < r)
                                        break n;
                                    return this._cachedIndex = i = t.length,
                                    this.afterEnd_(i - 1, e, r)
                                }
                                if (i === a)
                                    break;
                                if (r = n,
                                e < (n = t[++i]))
                                    break t
                            }
                            n = t.length;
                            break i
                        }
                        if (r <= e)
                            break e;
                        for (e < (a = t[1]) && (i = 2,
                        r = a),
                        a = i - 2; ; ) {
                            if (void 0 === r)
                                return this._cachedIndex = 0,
                                this.beforeStart_(0, e, n);
                            if (i === a)
                                break;
                            if (n = r,
                            (r = t[--i - 1]) <= e)
                                break t
                        }
                        n = i,
                        i = 0
                    }
                    for (; i < n; )
                        e < t[r = i + n >>> 1] ? n = r : i = r + 1;
                    if (n = t[i],
                    void 0 === (r = t[i - 1]))
                        return this._cachedIndex = 0,
                        this.beforeStart_(0, e, n);
                    if (void 0 === n)
                        return this._cachedIndex = i = t.length,
                        this.afterEnd_(i - 1, r, e)
                }
                this._cachedIndex = i,
                this.intervalChanged_(i, r, n)
            }
            return this.interpolate_(i, r, e, n)
        },
        settings: null,
        DefaultSettings_: {},
        getSettings_: function() {
            return this.settings || this.DefaultSettings_
        },
        copySampleValue_: function(e) {
            var t = this.resultBuffer
              , i = this.sampleValues
              , n = this.valueSize;
            e *= n;
            for (var r = 0; r !== n; ++r)
                t[r] = i[e + r];
            return t
        },
        interpolate_: function() {
            throw Error("call to abstract method")
        },
        intervalChanged_: function() {}
    }),
    Object.assign(ln.prototype, {
        beforeStart_: ln.prototype.copySampleValue_,
        afterEnd_: ln.prototype.copySampleValue_
    }),
    un.prototype = Object.assign(Object.create(ln.prototype), {
        constructor: un,
        DefaultSettings_: {
            endingStart: 2400,
            endingEnd: 2400
        },
        intervalChanged_: function(e, t, i) {
            var n = this.parameterPositions
              , r = e - 2
              , a = e + 1
              , o = n[r]
              , s = n[a];
            if (void 0 === o)
                switch (this.getSettings_().endingStart) {
                case 2401:
                    r = e,
                    o = 2 * t - i;
                    break;
                case 2402:
                    o = t + n[r = n.length - 2] - n[r + 1];
                    break;
                default:
                    r = e,
                    o = i
                }
            if (void 0 === s)
                switch (this.getSettings_().endingEnd) {
                case 2401:
                    a = e,
                    s = 2 * i - t;
                    break;
                case 2402:
                    s = i + n[a = 1] - n[0];
                    break;
                default:
                    a = e - 1,
                    s = t
                }
            n = this.valueSize,
            this._weightPrev = (e = .5 * (i - t)) / (t - o),
            this._weightNext = e / (s - i),
            this._offsetPrev = r * n,
            this._offsetNext = a * n
        },
        interpolate_: function(e, t, i, n) {
            var r = this.resultBuffer
              , a = this.sampleValues
              , o = this.valueSize
              , s = (e *= o) - o
              , c = this._offsetPrev
              , h = this._offsetNext
              , l = this._weightPrev
              , u = this._weightNext
              , p = (i - t) / (n - t);
            for (t = -l * (n = (i = p * p) * p) + 2 * l * i - l * p,
            l = (1 + l) * n + (-1.5 - 2 * l) * i + (-.5 + l) * p + 1,
            p = (-1 - u) * n + (1.5 + u) * i + .5 * p,
            u = u * n - u * i,
            i = 0; i !== o; ++i)
                r[i] = t * a[c + i] + l * a[s + i] + p * a[e + i] + u * a[h + i];
            return r
        }
    }),
    pn.prototype = Object.assign(Object.create(ln.prototype), {
        constructor: pn,
        interpolate_: function(e, t, i, n) {
            var r = this.resultBuffer
              , a = this.sampleValues
              , o = this.valueSize
              , s = (e *= o) - o;
            for (i = 1 - (t = (i - t) / (n - t)),
            n = 0; n !== o; ++n)
                r[n] = a[s + n] * i + a[e + n] * t;
            return r
        }
    }),
    dn.prototype = Object.assign(Object.create(ln.prototype), {
        constructor: dn,
        interpolate_: function(e) {
            return this.copySampleValue_(e - 1)
        }
    }),
    Object.assign(c, {
        toJSON: function(e) {
            var t, i = e.constructor;
            return void 0 !== i.toJSON ? i = i.toJSON(e) : (i = {
                name: e.name,
                times: A.convertArray(e.times, Array),
                values: A.convertArray(e.values, Array)
            },
            (t = e.getInterpolation()) !== e.DefaultInterpolation && (i.interpolation = t)),
            i.type = e.ValueTypeName,
            i
        }
    }),
    Object.assign(c.prototype, {
        constructor: c,
        TimeBufferType: Float32Array,
        ValueBufferType: Float32Array,
        DefaultInterpolation: 2301,
        InterpolantFactoryMethodDiscrete: function(e) {
            return new dn(this.times,this.values,this.getValueSize(),e)
        },
        InterpolantFactoryMethodLinear: function(e) {
            return new pn(this.times,this.values,this.getValueSize(),e)
        },
        InterpolantFactoryMethodSmooth: function(e) {
            return new un(this.times,this.values,this.getValueSize(),e)
        },
        setInterpolation: function(e) {
            switch (e) {
            case 2300:
                var t = this.InterpolantFactoryMethodDiscrete;
                break;
            case 2301:
                t = this.InterpolantFactoryMethodLinear;
                break;
            case 2302:
                t = this.InterpolantFactoryMethodSmooth
            }
            if (void 0 === t) {
                if (t = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name,
                void 0 === this.createInterpolant) {
                    if (e === this.DefaultInterpolation)
                        throw Error(t);
                    this.setInterpolation(this.DefaultInterpolation)
                }
                console.warn("THREE.KeyframeTrack:", t)
            } else
                this.createInterpolant = t;
            return this
        },
        getInterpolation: function() {
            switch (this.createInterpolant) {
            case this.InterpolantFactoryMethodDiscrete:
                return 2300;
            case this.InterpolantFactoryMethodLinear:
                return 2301;
            case this.InterpolantFactoryMethodSmooth:
                return 2302
            }
        },
        getValueSize: function() {
            return this.values.length / this.times.length
        },
        shift: function(e) {
            if (0 !== e)
                for (var t = this.times, i = 0, n = t.length; i !== n; ++i)
                    t[i] += e;
            return this
        },
        scale: function(e) {
            if (1 !== e)
                for (var t = this.times, i = 0, n = t.length; i !== n; ++i)
                    t[i] *= e;
            return this
        },
        trim: function(e, t) {
            for (var i = this.times, n = i.length, r = 0, a = n - 1; r !== n && i[r] < e; )
                ++r;
            for (; -1 !== a && i[a] > t; )
                --a;
            return ++a,
            0 === r && a === n || (a <= r && (r = (a = Math.max(a, 1)) - 1),
            e = this.getValueSize(),
            this.times = A.arraySlice(i, r, a),
            this.values = A.arraySlice(this.values, r * e, a * e)),
            this
        },
        validate: function() {
            var e = !0
              , t = (0 != (i = this.getValueSize()) - Math.floor(i) && (console.error("THREE.KeyframeTrack: Invalid value size in track.", this),
            e = !1),
            this.times)
              , i = this.values
              , n = t.length;
            0 === n && (console.error("THREE.KeyframeTrack: Track is empty.", this),
            e = !1);
            for (var r = null, a = 0; a !== n; a++) {
                var o = t[a];
                if ("number" == typeof o && isNaN(o)) {
                    console.error("THREE.KeyframeTrack: Time is not a valid number.", this, a, o),
                    e = !1;
                    break
                }
                if (null !== r && o < r) {
                    console.error("THREE.KeyframeTrack: Out of order keys.", this, a, o, r),
                    e = !1;
                    break
                }
                r = o
            }
            if (void 0 !== i && A.isTypedArray(i))
                for (a = 0,
                t = i.length; a !== t; ++a)
                    if (n = i[a],
                    isNaN(n)) {
                        console.error("THREE.KeyframeTrack: Value is not a valid number.", this, a, n),
                        e = !1;
                        break
                    }
            return e
        },
        optimize: function() {
            for (var e = this.times, t = this.values, i = this.getValueSize(), n = 2302 === this.getInterpolation(), r = 1, a = e.length - 1, o = 1; o < a; ++o) {
                var s = !1;
                if ((u = e[o]) !== e[o + 1] && (1 !== o || u !== u[0]))
                    if (n)
                        s = !0;
                    else
                        for (var c = o * i, h = c - i, l = c + i, u = 0; u !== i; ++u) {
                            var p = t[c + u];
                            if (p !== t[h + u] || p !== t[l + u]) {
                                s = !0;
                                break
                            }
                        }
                if (s) {
                    if (o !== r)
                        for (e[r] = e[o],
                        s = o * i,
                        c = r * i,
                        u = 0; u !== i; ++u)
                            t[c + u] = t[s + u];
                    ++r
                }
            }
            if (0 < a) {
                for (e[r] = e[a],
                s = a * i,
                c = r * i,
                u = 0; u !== i; ++u)
                    t[c + u] = t[s + u];
                ++r
            }
            return r !== e.length && (this.times = A.arraySlice(e, 0, r),
            this.values = A.arraySlice(t, 0, r * i)),
            this
        },
        clone: function() {
            var e = A.arraySlice(this.times, 0)
              , t = A.arraySlice(this.values, 0);
            return (e = new this.constructor(this.name,e,t)).createInterpolant = this.createInterpolant,
            e
        }
    }),
    fn.prototype = Object.assign(Object.create(c.prototype), {
        constructor: fn,
        ValueTypeName: "bool",
        ValueBufferType: Array,
        DefaultInterpolation: 2300,
        InterpolantFactoryMethodLinear: void 0,
        InterpolantFactoryMethodSmooth: void 0
    }),
    mn.prototype = Object.assign(Object.create(c.prototype), {
        constructor: mn,
        ValueTypeName: "color"
    }),
    gn.prototype = Object.assign(Object.create(c.prototype), {
        constructor: gn,
        ValueTypeName: "number"
    }),
    vn.prototype = Object.assign(Object.create(ln.prototype), {
        constructor: vn,
        interpolate_: function(e, t, i, n) {
            var r = this.resultBuffer
              , a = this.sampleValues
              , o = this.valueSize;
            for (t = (i - t) / (n - t),
            i = (e *= o) + o; e !== i; e += 4)
                M.slerpFlat(r, 0, a, e - o, a, e, t);
            return r
        }
    }),
    yn.prototype = Object.assign(Object.create(c.prototype), {
        constructor: yn,
        ValueTypeName: "quaternion",
        DefaultInterpolation: 2301,
        InterpolantFactoryMethodLinear: function(e) {
            return new vn(this.times,this.values,this.getValueSize(),e)
        },
        InterpolantFactoryMethodSmooth: void 0
    }),
    xn.prototype = Object.assign(Object.create(c.prototype), {
        constructor: xn,
        ValueTypeName: "string",
        ValueBufferType: Array,
        DefaultInterpolation: 2300,
        InterpolantFactoryMethodLinear: void 0,
        InterpolantFactoryMethodSmooth: void 0
    }),
    bn.prototype = Object.assign(Object.create(c.prototype), {
        constructor: bn,
        ValueTypeName: "vector"
    }),
    Object.assign(wn, {
        parse: function(e) {
            for (var t = [], i = e.tracks, n = 1 / (e.fps || 1), r = 0, a = i.length; r !== a; ++r)
                t.push(_n(i[r]).scale(n));
            return new wn(e.name,e.duration,t)
        },
        toJSON: function(e) {
            var t = []
              , i = e.tracks;
            e = {
                name: e.name,
                duration: e.duration,
                tracks: t,
                uuid: e.uuid
            };
            for (var n = 0, r = i.length; n !== r; ++n)
                t.push(c.toJSON(i[n]));
            return e
        },
        CreateFromMorphTargetSequence: function(e, t, i, n) {
            for (var r = t.length, a = [], o = 0; o < r; o++) {
                var s = []
                  , c = ((h = []).push((o + r - 1) % r, o, (o + 1) % r),
                s.push(0, 1, 0),
                A.getKeyframeOrder(h))
                  , h = A.sortedArray(h, 1, c)
                  , s = A.sortedArray(s, 1, c);
                n || 0 !== h[0] || (h.push(r),
                s.push(s[0])),
                a.push(new gn(".morphTargetInfluences[" + t[o].name + "]",h,s).scale(1 / i))
            }
            return new wn(e,-1,a)
        },
        findByName: function(e, t) {
            var i = e;
            for (Array.isArray(e) || (i = e.geometry && e.geometry.animations || e.animations),
            e = 0; e < i.length; e++)
                if (i[e].name === t)
                    return i[e];
            return null
        },
        CreateClipsFromMorphTargetSequences: function(e, t, i) {
            for (var n = {}, r = /^([\w-]*?)([\d]+)$/, a = 0, o = e.length; a < o; a++) {
                var s, c = e[a], h = c.name.match(r);
                h && 1 < h.length && ((h = n[s = h[1]]) || (n[s] = h = []),
                h.push(c))
            }
            for (s in e = [],
            n)
                e.push(wn.CreateFromMorphTargetSequence(s, n[s], t, i));
            return e
        },
        parseAnimation: function(e, t) {
            if (!e)
                return console.error("THREE.AnimationClip: No animation in JSONLoader data."),
                null;
            function i(e, t, i, n, r) {
                var a;
                0 !== i.length && (A.flattenJSON(i, i = [], a = [], n),
                0 !== i.length) && r.push(new e(t,i,a))
            }
            var n = []
              , r = e.name || "default"
              , a = e.length || -1
              , o = e.fps || 30;
            e = e.hierarchy || [];
            for (var s = 0; s < e.length; s++) {
                var c = e[s].keys;
                if (c && 0 !== c.length)
                    if (c[0].morphTargets) {
                        for (var h, a = {}, l = 0; l < c.length; l++)
                            if (c[l].morphTargets)
                                for (var u = 0; u < c[l].morphTargets.length; u++)
                                    a[c[l].morphTargets[u]] = -1;
                        for (h in a) {
                            for (var p = [], d = [], u = 0; u !== c[l].morphTargets.length; ++u) {
                                var f = c[l];
                                p.push(f.time),
                                d.push(f.morphTarget === h ? 1 : 0)
                            }
                            n.push(new gn(".morphTargetInfluence[" + h + "]",p,d))
                        }
                        a = a.length * (o || 1)
                    } else
                        i(bn, (l = ".bones[" + t[s].name + "]") + ".position", c, "pos", n),
                        i(yn, l + ".quaternion", c, "rot", n),
                        i(bn, l + ".scale", c, "scl", n)
            }
            return 0 === n.length ? null : new wn(r,a,n)
        }
    }),
    Object.assign(wn.prototype, {
        resetDuration: function() {
            for (var e = 0, t = 0, i = this.tracks.length; t !== i; ++t)
                var n = this.tracks[t]
                  , e = Math.max(e, n.times[n.times.length - 1]);
            return this.duration = e,
            this
        },
        trim: function() {
            for (var e = 0; e < this.tracks.length; e++)
                this.tracks[e].trim(0, this.duration);
            return this
        },
        validate: function() {
            for (var e = !0, t = 0; t < this.tracks.length; t++)
                e = e && this.tracks[t].validate();
            return e
        },
        optimize: function() {
            for (var e = 0; e < this.tracks.length; e++)
                this.tracks[e].optimize();
            return this
        },
        clone: function() {
            for (var e = [], t = 0; t < this.tracks.length; t++)
                e.push(this.tracks[t].clone());
            return new wn(this.name,this.duration,e)
        }
    }),
    {
        enabled: !1,
        files: {},
        add: function(e, t) {
            !1 !== this.enabled && (this.files[e] = t)
        },
        get: function(e) {
            if (!1 !== this.enabled)
                return this.files[e]
        },
        remove: function(e) {
            delete this.files[e]
        },
        clear: function() {
            this.files = {}
        }
    }), Uc = new Mn, Gc = {}, Fc = (Object.assign(En.prototype, {
        load: function(o, e, t, i) {
            void 0 === o && (o = ""),
            void 0 !== this.path && (o = this.path + o),
            o = this.manager.resolveURL(o);
            var s = this
              , n = zc.get(o);
            if (void 0 !== n)
                return s.manager.itemStart(o),
                setTimeout(function() {
                    e && e(n),
                    s.manager.itemEnd(o)
                }, 0),
                n;
            if (void 0 === Gc[o]) {
                if (a = o.match(/^data:(.*?)(;base64)?,(.*)$/)) {
                    t = a[1];
                    var r = !!a[2]
                      , a = a[3];
                    a = decodeURIComponent(a),
                    r && (a = atob(a));
                    try {
                        var c = (this.responseType || "").toLowerCase();
                        switch (c) {
                        case "arraybuffer":
                        case "blob":
                            for (var h = new Uint8Array(a.length), r = 0; r < a.length; r++)
                                h[r] = a.charCodeAt(r);
                            var l = "blob" === c ? new Blob([h.buffer],{
                                type: t
                            }) : h.buffer;
                            break;
                        case "document":
                            l = (new DOMParser).parseFromString(a, t);
                            break;
                        case "json":
                            l = JSON.parse(a);
                            break;
                        default:
                            l = a
                        }
                        setTimeout(function() {
                            e && e(l),
                            s.manager.itemEnd(o)
                        }, 0)
                    } catch (e) {
                        setTimeout(function() {
                            i && i(e),
                            s.manager.itemError(o),
                            s.manager.itemEnd(o)
                        }, 0)
                    }
                } else {
                    Gc[o] = [],
                    Gc[o].push({
                        onLoad: e,
                        onProgress: t,
                        onError: i
                    });
                    var u = new XMLHttpRequest;
                    for (r in u.open("GET", o, !0),
                    u.addEventListener("load", function(e) {
                        var t = this.response
                          , i = (zc.add(o, t),
                        Gc[o]);
                        if (delete Gc[o],
                        200 === this.status || 0 === this.status) {
                            0 === this.status && console.warn("THREE.FileLoader: HTTP Status 0 received.");
                            for (var n = 0, r = i.length; n < r; n++) {
                                var a = i[n];
                                a.onLoad && a.onLoad(t)
                            }
                        } else {
                            for (n = 0,
                            r = i.length; n < r; n++)
                                (a = i[n]).onError && a.onError(e);
                            s.manager.itemError(o)
                        }
                        s.manager.itemEnd(o)
                    }, !1),
                    u.addEventListener("progress", function(e) {
                        for (var t = Gc[o], i = 0, n = t.length; i < n; i++) {
                            var r = t[i];
                            r.onProgress && r.onProgress(e)
                        }
                    }, !1),
                    u.addEventListener("error", function(e) {
                        var t = Gc[o];
                        delete Gc[o];
                        for (var i = 0, n = t.length; i < n; i++) {
                            var r = t[i];
                            r.onError && r.onError(e)
                        }
                        s.manager.itemError(o),
                        s.manager.itemEnd(o)
                    }, !1),
                    u.addEventListener("abort", function(e) {
                        var t = Gc[o];
                        delete Gc[o];
                        for (var i = 0, n = t.length; i < n; i++) {
                            var r = t[i];
                            r.onError && r.onError(e)
                        }
                        s.manager.itemError(o),
                        s.manager.itemEnd(o)
                    }, !1),
                    void 0 !== this.responseType && (u.responseType = this.responseType),
                    void 0 !== this.withCredentials && (u.withCredentials = this.withCredentials),
                    u.overrideMimeType && u.overrideMimeType(void 0 !== this.mimeType ? this.mimeType : "text/plain"),
                    this.requestHeader)
                        u.setRequestHeader(r, this.requestHeader[r]);
                    u.send(null)
                }
                return s.manager.itemStart(o),
                u
            }
            Gc[o].push({
                onLoad: e,
                onProgress: t,
                onError: i
            })
        },
        setPath: function(e) {
            return this.path = e,
            this
        },
        setResponseType: function(e) {
            return this.responseType = e,
            this
        },
        setWithCredentials: function(e) {
            return this.withCredentials = e,
            this
        },
        setMimeType: function(e) {
            return this.mimeType = e,
            this
        },
        setRequestHeader: function(e) {
            return this.requestHeader = e,
            this
        }
    }),
    Object.assign(Sn.prototype, {
        load: function(e, t, i, n) {
            var r = this
              , a = new En(r.manager);
            a.setPath(r.path),
            a.load(e, function(e) {
                t(r.parse(JSON.parse(e)))
            }, i, n)
        },
        parse: function(e, t) {
            for (var i = [], n = 0; n < e.length; n++) {
                var r = wn.parse(e[n]);
                i.push(r)
            }
            t(i)
        },
        setPath: function(e) {
            return this.path = e,
            this
        }
    }),
    Object.assign(Tn.prototype, {
        load: function(e, r, i, n) {
            var a = this
              , o = []
              , s = new Zt
              , c = (s.image = o,
            new En(this.manager));
            if (c.setPath(this.path),
            c.setResponseType("arraybuffer"),
            Array.isArray(e))
                for (var h = 0, t = 0, l = e.length; t < l; ++t)
                    !function(t) {
                        c.load(e[t], function(e) {
                            e = a._parser(e, !0),
                            o[t] = {
                                width: e.width,
                                height: e.height,
                                format: e.format,
                                mipmaps: e.mipmaps
                            },
                            6 === (h += 1) && (1 === e.mipmapCount && (s.minFilter = 1006),
                            s.format = e.format,
                            s.needsUpdate = !0,
                            r) && r(s)
                        }, i, n)
                    }(t);
            else
                c.load(e, function(e) {
                    if ((e = a._parser(e, !0)).isCubemap)
                        for (var t = e.mipmaps.length / e.mipmapCount, i = 0; i < t; i++) {
                            o[i] = {
                                mipmaps: []
                            };
                            for (var n = 0; n < e.mipmapCount; n++)
                                o[i].mipmaps.push(e.mipmaps[i * e.mipmapCount + n]),
                                o[i].format = e.format,
                                o[i].width = e.width,
                                o[i].height = e.height
                        }
                    else
                        s.image.width = e.width,
                        s.image.height = e.height,
                        s.mipmaps = e.mipmaps;
                    1 === e.mipmapCount && (s.minFilter = 1006),
                    s.format = e.format,
                    s.needsUpdate = !0,
                    r && r(s)
                }, i, n);
            return s
        },
        setPath: function(e) {
            return this.path = e,
            this
        }
    }),
    Object.assign(An.prototype, {
        load: function(e, t, i, n) {
            var r = this
              , a = new Ae
              , o = new En(this.manager);
            return o.setResponseType("arraybuffer"),
            o.setPath(this.path),
            o.load(e, function(e) {
                (e = r._parser(e)) && (void 0 !== e.image ? a.image = e.image : void 0 !== e.data && (a.image.width = e.width,
                a.image.height = e.height,
                a.image.data = e.data),
                a.wrapS = void 0 !== e.wrapS ? e.wrapS : 1001,
                a.wrapT = void 0 !== e.wrapT ? e.wrapT : 1001,
                a.magFilter = void 0 !== e.magFilter ? e.magFilter : 1006,
                a.minFilter = void 0 !== e.minFilter ? e.minFilter : 1008,
                a.anisotropy = void 0 !== e.anisotropy ? e.anisotropy : 1,
                void 0 !== e.format && (a.format = e.format),
                void 0 !== e.type && (a.type = e.type),
                void 0 !== e.mipmaps && (a.mipmaps = e.mipmaps),
                1 === e.mipmapCount && (a.minFilter = 1006),
                a.needsUpdate = !0,
                t) && t(a, e)
            }, i, n),
            a
        },
        setPath: function(e) {
            return this.path = e,
            this
        }
    }),
    Object.assign(Ln.prototype, {
        crossOrigin: "anonymous",
        load: function(t, e, i, n) {
            function r() {
                o.removeEventListener("load", r, !1),
                o.removeEventListener("error", a, !1),
                zc.add(t, this),
                e && e(this),
                s.manager.itemEnd(t)
            }
            function a(e) {
                o.removeEventListener("load", r, !1),
                o.removeEventListener("error", a, !1),
                n && n(e),
                s.manager.itemError(t),
                s.manager.itemEnd(t)
            }
            void 0 === t && (t = ""),
            void 0 !== this.path && (t = this.path + t),
            t = this.manager.resolveURL(t);
            var o, s = this, c = zc.get(t);
            return void 0 !== c ? (s.manager.itemStart(t),
            setTimeout(function() {
                e && e(c),
                s.manager.itemEnd(t)
            }, 0),
            c) : ((o = document.createElementNS("http://www.w3.org/1999/xhtml", "img")).addEventListener("load", r, !1),
            o.addEventListener("error", a, !1),
            "data:" !== t.substr(0, 5) && void 0 !== this.crossOrigin && (o.crossOrigin = this.crossOrigin),
            s.manager.itemStart(t),
            o.src = t,
            o)
        },
        setCrossOrigin: function(e) {
            return this.crossOrigin = e,
            this
        },
        setPath: function(e) {
            return this.path = e,
            this
        }
    }),
    Object.assign(Pn.prototype, {
        crossOrigin: "anonymous",
        load: function(e, i, t, n) {
            var r = new ae
              , a = new Ln(this.manager)
              , o = (a.setCrossOrigin(this.crossOrigin),
            a.setPath(this.path),
            0);
            for (t = 0; t < e.length; ++t)
                !function(t) {
                    a.load(e[t], function(e) {
                        r.images[t] = e,
                        6 === ++o && (r.needsUpdate = !0,
                        i) && i(r)
                    }, void 0, n)
                }(t);
            return r
        },
        setCrossOrigin: function(e) {
            return this.crossOrigin = e,
            this
        },
        setPath: function(e) {
            return this.path = e,
            this
        }
    }),
    Object.assign(Rn.prototype, {
        crossOrigin: "anonymous",
        load: function(t, i, e, n) {
            var r = new p
              , a = new Ln(this.manager);
            return a.setCrossOrigin(this.crossOrigin),
            a.setPath(this.path),
            a.load(t, function(e) {
                r.image = e,
                e = 0 < t.search(/\.jpe?g($|\?)/i) || 0 === t.search(/^data:image\/jpeg/),
                r.format = e ? 1022 : 1023,
                r.needsUpdate = !0,
                void 0 !== i && i(r)
            }, e, n),
            r
        },
        setCrossOrigin: function(e) {
            return this.crossOrigin = e,
            this
        },
        setPath: function(e) {
            return this.path = e,
            this
        }
    }),
    Object.assign(l.prototype, {
        getPoint: function() {
            return console.warn("THREE.Curve: .getPoint() not implemented."),
            null
        },
        getPointAt: function(e, t) {
            return e = this.getUtoTmapping(e),
            this.getPoint(e, t)
        },
        getPoints: function(e) {
            void 0 === e && (e = 5);
            for (var t = [], i = 0; i <= e; i++)
                t.push(this.getPoint(i / e));
            return t
        },
        getSpacedPoints: function(e) {
            void 0 === e && (e = 5);
            for (var t = [], i = 0; i <= e; i++)
                t.push(this.getPointAt(i / e));
            return t
        },
        getLength: function() {
            var e = this.getLengths();
            return e[e.length - 1]
        },
        getLengths: function(e) {
            if (void 0 === e && (e = this.arcLengthDivisions),
            this.cacheArcLengths && this.cacheArcLengths.length === e + 1 && !this.needsUpdate)
                return this.cacheArcLengths;
            this.needsUpdate = !1;
            var t, i = [], n = this.getPoint(0), r = 0;
            for (i.push(0),
            t = 1; t <= e; t++) {
                var a = this.getPoint(t / e);
                r += a.distanceTo(n),
                i.push(r),
                n = a
            }
            return this.cacheArcLengths = i
        },
        updateArcLengths: function() {
            this.needsUpdate = !0,
            this.getLengths()
        },
        getUtoTmapping: function(e, t) {
            var i = this.getLengths()
              , n = i.length;
            t = t || e * i[n - 1];
            for (var r, a = 0, o = n - 1; a <= o; )
                if ((r = i[e = Math.floor(a + (o - a) / 2)] - t) < 0)
                    a = e + 1;
                else {
                    if (!(0 < r)) {
                        o = e;
                        break
                    }
                    o = e - 1
                }
            return i[e = o] === t ? e / (n - 1) : (e + (t - (a = i[e])) / (i[e + 1] - a)) / (n - 1)
        },
        getTangent: function(e) {
            var t = e - 1e-4;
            return 1 < (e += 1e-4) && (e = 1),
            t = this.getPoint(t = t < 0 ? 0 : t),
            this.getPoint(e).clone().sub(t).normalize()
        },
        getTangentAt: function(e) {
            return e = this.getUtoTmapping(e),
            this.getTangent(e)
        },
        computeFrenetFrames: function(e, t) {
            for (var i = new Me, n = [], r = [], a = [], o = new Me, s = new _e, c = 0; c <= e; c++) {
                var h = c / e;
                n[c] = this.getTangentAt(h),
                n[c].normalize()
            }
            r[0] = new Me,
            a[0] = new Me,
            c = Number.MAX_VALUE;
            var h = Math.abs(n[0].x)
              , l = Math.abs(n[0].y)
              , u = Math.abs(n[0].z);
            for (h <= c && (c = h,
            i.set(1, 0, 0)),
            l <= c && (c = l,
            i.set(0, 1, 0)),
            u <= c && i.set(0, 0, 1),
            o.crossVectors(n[0], i).normalize(),
            r[0].crossVectors(n[0], o),
            a[0].crossVectors(n[0], r[0]),
            c = 1; c <= e; c++)
                r[c] = r[c - 1].clone(),
                a[c] = a[c - 1].clone(),
                o.crossVectors(n[c - 1], n[c]),
                o.length() > Number.EPSILON && (o.normalize(),
                i = Math.acos(Se.clamp(n[c - 1].dot(n[c]), -1, 1)),
                r[c].applyMatrix4(s.makeRotationAxis(o, i))),
                a[c].crossVectors(n[c], r[c]);
            if (!0 === t)
                for (i = Math.acos(Se.clamp(r[0].dot(r[e]), -1, 1)),
                i /= e,
                0 < n[0].dot(o.crossVectors(r[0], r[e])) && (i = -i),
                c = 1; c <= e; c++)
                    r[c].applyMatrix4(s.makeRotationAxis(n[c], i * c)),
                    a[c].crossVectors(n[c], r[c]);
            return {
                tangents: n,
                normals: r,
                binormals: a
            }
        },
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(e) {
            return this.arcLengthDivisions = e.arcLengthDivisions,
            this
        },
        toJSON: function() {
            var e = {
                metadata: {
                    version: 4.5,
                    type: "Curve",
                    generator: "Curve.toJSON"
                }
            };
            return e.arcLengthDivisions = this.arcLengthDivisions,
            e.type = this.type,
            e
        },
        fromJSON: function(e) {
            return this.arcLengthDivisions = e.arcLengthDivisions,
            this
        }
    }),
    ((Cn.prototype = Object.create(l.prototype)).constructor = Cn).prototype.isEllipseCurve = !0,
    Cn.prototype.getPoint = function(e, t) {
        t = t || new Y;
        for (var i = 2 * Math.PI, n = this.aEndAngle - this.aStartAngle, r = Math.abs(n) < Number.EPSILON; n < 0; )
            n += i;
        for (; i < n; )
            n -= i;
        n < Number.EPSILON && (n = r ? 0 : i),
        !0 !== this.aClockwise || r || (n = n === i ? -i : n - i),
        i = this.aStartAngle + e * n,
        e = this.aX + this.xRadius * Math.cos(i);
        var a = this.aY + this.yRadius * Math.sin(i);
        return 0 !== this.aRotation && (i = Math.cos(this.aRotation),
        n = Math.sin(this.aRotation),
        e = (r = e - this.aX) * i - (a -= this.aY) * n + this.aX,
        a = r * n + a * i + this.aY),
        t.set(e, a)
    }
    ,
    Cn.prototype.copy = function(e) {
        return l.prototype.copy.call(this, e),
        this.aX = e.aX,
        this.aY = e.aY,
        this.xRadius = e.xRadius,
        this.yRadius = e.yRadius,
        this.aStartAngle = e.aStartAngle,
        this.aEndAngle = e.aEndAngle,
        this.aClockwise = e.aClockwise,
        this.aRotation = e.aRotation,
        this
    }
    ,
    Cn.prototype.toJSON = function() {
        var e = l.prototype.toJSON.call(this);
        return e.aX = this.aX,
        e.aY = this.aY,
        e.xRadius = this.xRadius,
        e.yRadius = this.yRadius,
        e.aStartAngle = this.aStartAngle,
        e.aEndAngle = this.aEndAngle,
        e.aClockwise = this.aClockwise,
        e.aRotation = this.aRotation,
        e
    }
    ,
    Cn.prototype.fromJSON = function(e) {
        return l.prototype.fromJSON.call(this, e),
        this.aX = e.aX,
        this.aY = e.aY,
        this.xRadius = e.xRadius,
        this.yRadius = e.yRadius,
        this.aStartAngle = e.aStartAngle,
        this.aEndAngle = e.aEndAngle,
        this.aClockwise = e.aClockwise,
        this.aRotation = e.aRotation,
        this
    }
    ,
    ((On.prototype = Object.create(Cn.prototype)).constructor = On).prototype.isArcCurve = !0,
    new Me), Hc = new In, kc = new In, Vc = new In, jc = (((i.prototype = Object.create(l.prototype)).constructor = i).prototype.isCatmullRomCurve3 = !0,
    i.prototype.getPoint = function(e, t) {
        t = t || new Me;
        var i, n, r = (c = this.points).length, a = (e *= r - (this.closed ? 0 : 1),
        Math.floor(e)), o = (e -= a,
        this.closed ? a += 0 < a ? 0 : (Math.floor(Math.abs(a) / r) + 1) * r : 0 === e && a === r - 1 && (a = r - 2,
        e = 1),
        i = this.closed || 0 < a ? c[(a - 1) % r] : (Fc.subVectors(c[0], c[1]).add(c[0]),
        Fc),
        c[a % r]), s = c[(a + 1) % r], c = this.closed || a + 2 < r ? c[(a + 2) % r] : (Fc.subVectors(c[r - 1], c[r - 2]).add(c[r - 1]),
        Fc);
        return "centripetal" === this.curveType || "chordal" === this.curveType ? (n = "chordal" === this.curveType ? .5 : .25,
        r = Math.pow(i.distanceToSquared(o), n),
        (a = Math.pow(o.distanceToSquared(s), n)) < 1e-4 && (a = 1),
        r < 1e-4 && (r = a),
        (n = Math.pow(s.distanceToSquared(c), n)) < 1e-4 && (n = a),
        Hc.initNonuniformCatmullRom(i.x, o.x, s.x, c.x, r, a, n),
        kc.initNonuniformCatmullRom(i.y, o.y, s.y, c.y, r, a, n),
        Vc.initNonuniformCatmullRom(i.z, o.z, s.z, c.z, r, a, n)) : "catmullrom" === this.curveType && (Hc.initCatmullRom(i.x, o.x, s.x, c.x, this.tension),
        kc.initCatmullRom(i.y, o.y, s.y, c.y, this.tension),
        Vc.initCatmullRom(i.z, o.z, s.z, c.z, this.tension)),
        t.set(Hc.calc(e), kc.calc(e), Vc.calc(e)),
        t
    }
    ,
    i.prototype.copy = function(e) {
        l.prototype.copy.call(this, e),
        this.points = [];
        for (var t = 0, i = e.points.length; t < i; t++)
            this.points.push(e.points[t].clone());
        return this.closed = e.closed,
        this.curveType = e.curveType,
        this.tension = e.tension,
        this
    }
    ,
    i.prototype.toJSON = function() {
        var e = l.prototype.toJSON.call(this);
        e.points = [];
        for (var t = 0, i = this.points.length; t < i; t++)
            e.points.push(this.points[t].toArray());
        return e.closed = this.closed,
        e.curveType = this.curveType,
        e.tension = this.tension,
        e
    }
    ,
    i.prototype.fromJSON = function(e) {
        l.prototype.fromJSON.call(this, e),
        this.points = [];
        for (var t = 0, i = e.points.length; t < i; t++) {
            var n = e.points[t];
            this.points.push((new Me).fromArray(n))
        }
        return this.closed = e.closed,
        this.curveType = e.curveType,
        this.tension = e.tension,
        this
    }
    ,
    ((zn.prototype = Object.create(l.prototype)).constructor = zn).prototype.isCubicBezierCurve = !0,
    zn.prototype.getPoint = function(e, t) {
        t = t || new Y;
        var i = this.v0
          , n = this.v1
          , r = this.v2
          , a = this.v3;
        return t.set(Nn(e, i.x, n.x, r.x, a.x), Nn(e, i.y, n.y, r.y, a.y)),
        t
    }
    ,
    zn.prototype.copy = function(e) {
        return l.prototype.copy.call(this, e),
        this.v0.copy(e.v0),
        this.v1.copy(e.v1),
        this.v2.copy(e.v2),
        this.v3.copy(e.v3),
        this
    }
    ,
    zn.prototype.toJSON = function() {
        var e = l.prototype.toJSON.call(this);
        return e.v0 = this.v0.toArray(),
        e.v1 = this.v1.toArray(),
        e.v2 = this.v2.toArray(),
        e.v3 = this.v3.toArray(),
        e
    }
    ,
    zn.prototype.fromJSON = function(e) {
        return l.prototype.fromJSON.call(this, e),
        this.v0.fromArray(e.v0),
        this.v1.fromArray(e.v1),
        this.v2.fromArray(e.v2),
        this.v3.fromArray(e.v3),
        this
    }
    ,
    ((Un.prototype = Object.create(l.prototype)).constructor = Un).prototype.isCubicBezierCurve3 = !0,
    Un.prototype.getPoint = function(e, t) {
        t = t || new Me;
        var i = this.v0
          , n = this.v1
          , r = this.v2
          , a = this.v3;
        return t.set(Nn(e, i.x, n.x, r.x, a.x), Nn(e, i.y, n.y, r.y, a.y), Nn(e, i.z, n.z, r.z, a.z)),
        t
    }
    ,
    Un.prototype.copy = function(e) {
        return l.prototype.copy.call(this, e),
        this.v0.copy(e.v0),
        this.v1.copy(e.v1),
        this.v2.copy(e.v2),
        this.v3.copy(e.v3),
        this
    }
    ,
    Un.prototype.toJSON = function() {
        var e = l.prototype.toJSON.call(this);
        return e.v0 = this.v0.toArray(),
        e.v1 = this.v1.toArray(),
        e.v2 = this.v2.toArray(),
        e.v3 = this.v3.toArray(),
        e
    }
    ,
    Un.prototype.fromJSON = function(e) {
        return l.prototype.fromJSON.call(this, e),
        this.v0.fromArray(e.v0),
        this.v1.fromArray(e.v1),
        this.v2.fromArray(e.v2),
        this.v3.fromArray(e.v3),
        this
    }
    ,
    ((Gn.prototype = Object.create(l.prototype)).constructor = Gn).prototype.isLineCurve = !0,
    Gn.prototype.getPoint = function(e, t) {
        return t = t || new Y,
        1 === e ? t.copy(this.v2) : (t.copy(this.v2).sub(this.v1),
        t.multiplyScalar(e).add(this.v1)),
        t
    }
    ,
    Gn.prototype.getPointAt = function(e, t) {
        return this.getPoint(e, t)
    }
    ,
    Gn.prototype.getTangent = function() {
        return this.v2.clone().sub(this.v1).normalize()
    }
    ,
    Gn.prototype.copy = function(e) {
        return l.prototype.copy.call(this, e),
        this.v1.copy(e.v1),
        this.v2.copy(e.v2),
        this
    }
    ,
    Gn.prototype.toJSON = function() {
        var e = l.prototype.toJSON.call(this);
        return e.v1 = this.v1.toArray(),
        e.v2 = this.v2.toArray(),
        e
    }
    ,
    Gn.prototype.fromJSON = function(e) {
        return l.prototype.fromJSON.call(this, e),
        this.v1.fromArray(e.v1),
        this.v2.fromArray(e.v2),
        this
    }
    ,
    ((Fn.prototype = Object.create(l.prototype)).constructor = Fn).prototype.isLineCurve3 = !0,
    Fn.prototype.getPoint = function(e, t) {
        return t = t || new Me,
        1 === e ? t.copy(this.v2) : (t.copy(this.v2).sub(this.v1),
        t.multiplyScalar(e).add(this.v1)),
        t
    }
    ,
    Fn.prototype.getPointAt = function(e, t) {
        return this.getPoint(e, t)
    }
    ,
    Fn.prototype.copy = function(e) {
        return l.prototype.copy.call(this, e),
        this.v1.copy(e.v1),
        this.v2.copy(e.v2),
        this
    }
    ,
    Fn.prototype.toJSON = function() {
        var e = l.prototype.toJSON.call(this);
        return e.v1 = this.v1.toArray(),
        e.v2 = this.v2.toArray(),
        e
    }
    ,
    Fn.prototype.fromJSON = function(e) {
        return l.prototype.fromJSON.call(this, e),
        this.v1.fromArray(e.v1),
        this.v2.fromArray(e.v2),
        this
    }
    ,
    ((Hn.prototype = Object.create(l.prototype)).constructor = Hn).prototype.isQuadraticBezierCurve = !0,
    Hn.prototype.getPoint = function(e, t) {
        t = t || new Y;
        var i = this.v0
          , n = this.v1
          , r = this.v2;
        return t.set(Bn(e, i.x, n.x, r.x), Bn(e, i.y, n.y, r.y)),
        t
    }
    ,
    Hn.prototype.copy = function(e) {
        return l.prototype.copy.call(this, e),
        this.v0.copy(e.v0),
        this.v1.copy(e.v1),
        this.v2.copy(e.v2),
        this
    }
    ,
    Hn.prototype.toJSON = function() {
        var e = l.prototype.toJSON.call(this);
        return e.v0 = this.v0.toArray(),
        e.v1 = this.v1.toArray(),
        e.v2 = this.v2.toArray(),
        e
    }
    ,
    Hn.prototype.fromJSON = function(e) {
        return l.prototype.fromJSON.call(this, e),
        this.v0.fromArray(e.v0),
        this.v1.fromArray(e.v1),
        this.v2.fromArray(e.v2),
        this
    }
    ,
    ((kn.prototype = Object.create(l.prototype)).constructor = kn).prototype.isQuadraticBezierCurve3 = !0,
    kn.prototype.getPoint = function(e, t) {
        t = t || new Me;
        var i = this.v0
          , n = this.v1
          , r = this.v2;
        return t.set(Bn(e, i.x, n.x, r.x), Bn(e, i.y, n.y, r.y), Bn(e, i.z, n.z, r.z)),
        t
    }
    ,
    kn.prototype.copy = function(e) {
        return l.prototype.copy.call(this, e),
        this.v0.copy(e.v0),
        this.v1.copy(e.v1),
        this.v2.copy(e.v2),
        this
    }
    ,
    kn.prototype.toJSON = function() {
        var e = l.prototype.toJSON.call(this);
        return e.v0 = this.v0.toArray(),
        e.v1 = this.v1.toArray(),
        e.v2 = this.v2.toArray(),
        e
    }
    ,
    kn.prototype.fromJSON = function(e) {
        return l.prototype.fromJSON.call(this, e),
        this.v0.fromArray(e.v0),
        this.v1.fromArray(e.v1),
        this.v2.fromArray(e.v2),
        this
    }
    ,
    ((Vn.prototype = Object.create(l.prototype)).constructor = Vn).prototype.isSplineCurve = !0,
    Vn.prototype.getPoint = function(e, t) {
        t = t || new Y;
        var i = ((o = this.points).length - 1) * e
          , n = o[0 === (e = Math.floor(i)) ? e : e - 1]
          , r = o[e]
          , a = o[e > o.length - 2 ? o.length - 1 : e + 1]
          , o = o[e > o.length - 3 ? o.length - 1 : e + 2];
        return t.set(Dn(i -= e, n.x, r.x, a.x, o.x), Dn(i, n.y, r.y, a.y, o.y)),
        t
    }
    ,
    Vn.prototype.copy = function(e) {
        l.prototype.copy.call(this, e),
        this.points = [];
        for (var t = 0, i = e.points.length; t < i; t++)
            this.points.push(e.points[t].clone());
        return this
    }
    ,
    Vn.prototype.toJSON = function() {
        var e = l.prototype.toJSON.call(this);
        e.points = [];
        for (var t = 0, i = this.points.length; t < i; t++)
            e.points.push(this.points[t].toArray());
        return e
    }
    ,
    Vn.prototype.fromJSON = function(e) {
        l.prototype.fromJSON.call(this, e),
        this.points = [];
        for (var t = 0, i = e.points.length; t < i; t++) {
            var n = e.points[t];
            this.points.push((new Y).fromArray(n))
        }
        return this
    }
    ,
    Object.freeze({
        ArcCurve: On,
        CatmullRomCurve3: i,
        CubicBezierCurve: zn,
        CubicBezierCurve3: Un,
        EllipseCurve: Cn,
        LineCurve: Gn,
        LineCurve3: Fn,
        QuadraticBezierCurve: Hn,
        QuadraticBezierCurve3: kn,
        SplineCurve: Vn
    })), Wc = (jn.prototype = Object.assign(Object.create(l.prototype), {
        constructor: jn,
        add: function(e) {
            this.curves.push(e)
        },
        closePath: function() {
            var e = this.curves[0].getPoint(0)
              , t = this.curves[this.curves.length - 1].getPoint(1);
            e.equals(t) || this.curves.push(new Gn(t,e))
        },
        getPoint: function(e) {
            var t = e * this.getLength()
              , i = this.getCurveLengths();
            for (e = 0; e < i.length; ) {
                if (i[e] >= t)
                    return t = i[e] - t,
                    i = (e = this.curves[e]).getLength(),
                    e.getPointAt(0 === i ? 0 : 1 - t / i);
                e++
            }
            return null
        },
        getLength: function() {
            var e = this.getCurveLengths();
            return e[e.length - 1]
        },
        updateArcLengths: function() {
            this.needsUpdate = !0,
            this.cacheLengths = null,
            this.getCurveLengths()
        },
        getCurveLengths: function() {
            if (this.cacheLengths && this.cacheLengths.length === this.curves.length)
                return this.cacheLengths;
            for (var e = [], t = 0, i = 0, n = this.curves.length; i < n; i++)
                t += this.curves[i].getLength(),
                e.push(t);
            return this.cacheLengths = e
        },
        getSpacedPoints: function(e) {
            void 0 === e && (e = 40);
            for (var t = [], i = 0; i <= e; i++)
                t.push(this.getPoint(i / e));
            return this.autoClose && t.push(t[0]),
            t
        },
        getPoints: function(e) {
            e = e || 12;
            for (var t, i = [], n = 0, r = this.curves; n < r.length; n++)
                for (var a = (a = r[n]).getPoints(a && a.isEllipseCurve ? 2 * e : a && (a.isLineCurve || a.isLineCurve3) ? 1 : a && a.isSplineCurve ? e * a.points.length : e), o = 0; o < a.length; o++) {
                    var s = a[o];
                    t && t.equals(s) || (i.push(s),
                    t = s)
                }
            return this.autoClose && 1 < i.length && !i[i.length - 1].equals(i[0]) && i.push(i[0]),
            i
        },
        copy: function(e) {
            l.prototype.copy.call(this, e),
            this.curves = [];
            for (var t = 0, i = e.curves.length; t < i; t++)
                this.curves.push(e.curves[t].clone());
            return this.autoClose = e.autoClose,
            this
        },
        toJSON: function() {
            var e = l.prototype.toJSON.call(this);
            e.autoClose = this.autoClose,
            e.curves = [];
            for (var t = 0, i = this.curves.length; t < i; t++)
                e.curves.push(this.curves[t].toJSON());
            return e
        },
        fromJSON: function(e) {
            l.prototype.fromJSON.call(this, e),
            this.autoClose = e.autoClose,
            this.curves = [];
            for (var t = 0, i = e.curves.length; t < i; t++) {
                var n = e.curves[t];
                this.curves.push((new jc[n.type]).fromJSON(n))
            }
            return this
        }
    }),
    Wn.prototype = Object.assign(Object.create(jn.prototype), {
        constructor: Wn,
        setFromPoints: function(e) {
            this.moveTo(e[0].x, e[0].y);
            for (var t = 1, i = e.length; t < i; t++)
                this.lineTo(e[t].x, e[t].y)
        },
        moveTo: function(e, t) {
            this.currentPoint.set(e, t)
        },
        lineTo: function(e, t) {
            var i = new Gn(this.currentPoint.clone(),new Y(e,t));
            this.curves.push(i),
            this.currentPoint.set(e, t)
        },
        quadraticCurveTo: function(e, t, i, n) {
            e = new Hn(this.currentPoint.clone(),new Y(e,t),new Y(i,n)),
            this.curves.push(e),
            this.currentPoint.set(i, n)
        },
        bezierCurveTo: function(e, t, i, n, r, a) {
            e = new zn(this.currentPoint.clone(),new Y(e,t),new Y(i,n),new Y(r,a)),
            this.curves.push(e),
            this.currentPoint.set(r, a)
        },
        splineThru: function(e) {
            var t = new Vn([this.currentPoint.clone()].concat(e));
            this.curves.push(t),
            this.currentPoint.copy(e[e.length - 1])
        },
        arc: function(e, t, i, n, r, a) {
            this.absarc(e + this.currentPoint.x, t + this.currentPoint.y, i, n, r, a)
        },
        absarc: function(e, t, i, n, r, a) {
            this.absellipse(e, t, i, i, n, r, a)
        },
        ellipse: function(e, t, i, n, r, a, o, s) {
            this.absellipse(e + this.currentPoint.x, t + this.currentPoint.y, i, n, r, a, o, s)
        },
        absellipse: function(e, t, i, n, r, a, o, s) {
            e = new Cn(e,t,i,n,r,a,o,s),
            0 < this.curves.length && ((t = e.getPoint(0)).equals(this.currentPoint) || this.lineTo(t.x, t.y)),
            this.curves.push(e),
            e = e.getPoint(1),
            this.currentPoint.copy(e)
        },
        copy: function(e) {
            return jn.prototype.copy.call(this, e),
            this.currentPoint.copy(e.currentPoint),
            this
        },
        toJSON: function() {
            var e = jn.prototype.toJSON.call(this);
            return e.currentPoint = this.currentPoint.toArray(),
            e
        },
        fromJSON: function(e) {
            return jn.prototype.fromJSON.call(this, e),
            this.currentPoint.fromArray(e.currentPoint),
            this
        }
    }),
    qn.prototype = Object.assign(Object.create(Wn.prototype), {
        constructor: qn,
        getPointsHoles: function(e) {
            for (var t = [], i = 0, n = this.holes.length; i < n; i++)
                t[i] = this.holes[i].getPoints(e);
            return t
        },
        extractPoints: function(e) {
            return {
                shape: this.getPoints(e),
                holes: this.getPointsHoles(e)
            }
        },
        copy: function(e) {
            Wn.prototype.copy.call(this, e),
            this.holes = [];
            for (var t = 0, i = e.holes.length; t < i; t++)
                this.holes.push(e.holes[t].clone());
            return this
        },
        toJSON: function() {
            var e = Wn.prototype.toJSON.call(this);
            e.uuid = this.uuid,
            e.holes = [];
            for (var t = 0, i = this.holes.length; t < i; t++)
                e.holes.push(this.holes[t].toJSON());
            return e
        },
        fromJSON: function(e) {
            Wn.prototype.fromJSON.call(this, e),
            this.uuid = e.uuid,
            this.holes = [];
            for (var t = 0, i = e.holes.length; t < i; t++) {
                var n = e.holes[t];
                this.holes.push((new Wn).fromJSON(n))
            }
            return this
        }
    }),
    _.prototype = Object.assign(Object.create(u.prototype), {
        constructor: _,
        isLight: !0,
        copy: function(e) {
            return u.prototype.copy.call(this, e),
            this.color.copy(e.color),
            this.intensity = e.intensity,
            this
        },
        toJSON: function(e) {
            return (e = u.prototype.toJSON.call(this, e)).object.color = this.color.getHex(),
            e.object.intensity = this.intensity,
            void 0 !== this.groundColor && (e.object.groundColor = this.groundColor.getHex()),
            void 0 !== this.distance && (e.object.distance = this.distance),
            void 0 !== this.angle && (e.object.angle = this.angle),
            void 0 !== this.decay && (e.object.decay = this.decay),
            void 0 !== this.penumbra && (e.object.penumbra = this.penumbra),
            void 0 !== this.shadow && (e.object.shadow = this.shadow.toJSON()),
            e
        }
    }),
    Xn.prototype = Object.assign(Object.create(_.prototype), {
        constructor: Xn,
        isHemisphereLight: !0,
        copy: function(e) {
            return _.prototype.copy.call(this, e),
            this.groundColor.copy(e.groundColor),
            this
        }
    }),
    Object.assign(Yn.prototype, {
        copy: function(e) {
            return this.camera = e.camera.clone(),
            this.bias = e.bias,
            this.radius = e.radius,
            this.mapSize.copy(e.mapSize),
            this
        },
        clone: function() {
            return (new this.constructor).copy(this)
        },
        toJSON: function() {
            var e = {};
            return 0 !== this.bias && (e.bias = this.bias),
            1 !== this.radius && (e.radius = this.radius),
            512 === this.mapSize.x && 512 === this.mapSize.y || (e.mapSize = this.mapSize.toArray()),
            e.camera = this.camera.toJSON(!1).object,
            delete e.camera.matrix,
            e
        }
    }),
    Jn.prototype = Object.assign(Object.create(Yn.prototype), {
        constructor: Jn,
        isSpotLightShadow: !0,
        update: function(e) {
            var t = this.camera
              , i = 2 * Se.RAD2DEG * e.angle
              , n = this.mapSize.width / this.mapSize.height;
            e = e.distance || t.far,
            i === t.fov && n === t.aspect && e === t.far || (t.fov = i,
            t.aspect = n,
            t.far = e,
            t.updateProjectionMatrix())
        }
    }),
    Zn.prototype = Object.assign(Object.create(_.prototype), {
        constructor: Zn,
        isSpotLight: !0,
        copy: function(e) {
            return _.prototype.copy.call(this, e),
            this.distance = e.distance,
            this.angle = e.angle,
            this.penumbra = e.penumbra,
            this.decay = e.decay,
            this.target = e.target.clone(),
            this.shadow = e.shadow.clone(),
            this
        }
    }),
    Qn.prototype = Object.assign(Object.create(_.prototype), {
        constructor: Qn,
        isPointLight: !0,
        copy: function(e) {
            return _.prototype.copy.call(this, e),
            this.distance = e.distance,
            this.decay = e.decay,
            this.shadow = e.shadow.clone(),
            this
        }
    }),
    Kn.prototype = Object.assign(Object.create(Pt.prototype), {
        constructor: Kn,
        isOrthographicCamera: !0,
        copy: function(e, t) {
            return Pt.prototype.copy.call(this, e, t),
            this.left = e.left,
            this.right = e.right,
            this.top = e.top,
            this.bottom = e.bottom,
            this.near = e.near,
            this.far = e.far,
            this.zoom = e.zoom,
            this.view = null === e.view ? null : Object.assign({}, e.view),
            this
        },
        setViewOffset: function(e, t, i, n, r, a) {
            null === this.view && (this.view = {
                enabled: !0,
                fullWidth: 1,
                fullHeight: 1,
                offsetX: 0,
                offsetY: 0,
                width: 1,
                height: 1
            }),
            this.view.enabled = !0,
            this.view.fullWidth = e,
            this.view.fullHeight = t,
            this.view.offsetX = i,
            this.view.offsetY = n,
            this.view.width = r,
            this.view.height = a,
            this.updateProjectionMatrix()
        },
        clearViewOffset: function() {
            null !== this.view && (this.view.enabled = !1),
            this.updateProjectionMatrix()
        },
        updateProjectionMatrix: function() {
            var e, t = (this.right - this.left) / (2 * this.zoom), i = (this.top - this.bottom) / (2 * this.zoom), n = (this.right + this.left) / 2, r = (this.top + this.bottom) / 2, a = n - t;
            n += t,
            t = r + i,
            i = r - i,
            null !== this.view && this.view.enabled && (n = this.zoom / (this.view.width / this.view.fullWidth),
            i = this.zoom / (this.view.height / this.view.fullHeight),
            e = (this.right - this.left) / this.view.width,
            r = (this.top - this.bottom) / this.view.height,
            n = (a += this.view.offsetX / n * e) + this.view.width / n * e,
            i = (t -= this.view.offsetY / i * r) - this.view.height / i * r),
            this.projectionMatrix.makeOrthographic(a, n, t, i, this.near, this.far),
            this.projectionMatrixInverse.getInverse(this.projectionMatrix)
        },
        toJSON: function(e) {
            return (e = u.prototype.toJSON.call(this, e)).object.zoom = this.zoom,
            e.object.left = this.left,
            e.object.right = this.right,
            e.object.top = this.top,
            e.object.bottom = this.bottom,
            e.object.near = this.near,
            e.object.far = this.far,
            null !== this.view && (e.object.view = Object.assign({}, this.view)),
            e
        }
    }),
    $n.prototype = Object.assign(Object.create(Yn.prototype), {
        constructor: $n
    }),
    er.prototype = Object.assign(Object.create(_.prototype), {
        constructor: er,
        isDirectionalLight: !0,
        copy: function(e) {
            return _.prototype.copy.call(this, e),
            this.target = e.target.clone(),
            this.shadow = e.shadow.clone(),
            this
        }
    }),
    tr.prototype = Object.assign(Object.create(_.prototype), {
        constructor: tr,
        isAmbientLight: !0
    }),
    ir.prototype = Object.assign(Object.create(_.prototype), {
        constructor: ir,
        isRectAreaLight: !0,
        copy: function(e) {
            return _.prototype.copy.call(this, e),
            this.width = e.width,
            this.height = e.height,
            this
        },
        toJSON: function(e) {
            return (e = _.prototype.toJSON.call(this, e)).object.width = this.width,
            e.object.height = this.height,
            e
        }
    }),
    Object.assign(nr.prototype, {
        load: function(e, t, i, n) {
            var r = this
              , a = new En(r.manager);
            a.setPath(r.path),
            a.load(e, function(e) {
                t(r.parse(JSON.parse(e)))
            }, i, n)
        },
        parse: function(e) {
            function t(e) {
                return void 0 === i[e] && console.warn("THREE.MaterialLoader: Undefined texture", e),
                i[e]
            }
            var i = this.textures
              , n = new Nc[e.type];
            if (void 0 !== e.uuid && (n.uuid = e.uuid),
            void 0 !== e.name && (n.name = e.name),
            void 0 !== e.color && n.color.setHex(e.color),
            void 0 !== e.roughness && (n.roughness = e.roughness),
            void 0 !== e.metalness && (n.metalness = e.metalness),
            void 0 !== e.emissive && n.emissive.setHex(e.emissive),
            void 0 !== e.specular && n.specular.setHex(e.specular),
            void 0 !== e.shininess && (n.shininess = e.shininess),
            void 0 !== e.clearCoat && (n.clearCoat = e.clearCoat),
            void 0 !== e.clearCoatRoughness && (n.clearCoatRoughness = e.clearCoatRoughness),
            void 0 !== e.vertexColors && (n.vertexColors = e.vertexColors),
            void 0 !== e.fog && (n.fog = e.fog),
            void 0 !== e.flatShading && (n.flatShading = e.flatShading),
            void 0 !== e.blending && (n.blending = e.blending),
            void 0 !== e.combine && (n.combine = e.combine),
            void 0 !== e.side && (n.side = e.side),
            void 0 !== e.opacity && (n.opacity = e.opacity),
            void 0 !== e.transparent && (n.transparent = e.transparent),
            void 0 !== e.alphaTest && (n.alphaTest = e.alphaTest),
            void 0 !== e.depthTest && (n.depthTest = e.depthTest),
            void 0 !== e.depthWrite && (n.depthWrite = e.depthWrite),
            void 0 !== e.colorWrite && (n.colorWrite = e.colorWrite),
            void 0 !== e.wireframe && (n.wireframe = e.wireframe),
            void 0 !== e.wireframeLinewidth && (n.wireframeLinewidth = e.wireframeLinewidth),
            void 0 !== e.wireframeLinecap && (n.wireframeLinecap = e.wireframeLinecap),
            void 0 !== e.wireframeLinejoin && (n.wireframeLinejoin = e.wireframeLinejoin),
            void 0 !== e.rotation && (n.rotation = e.rotation),
            1 !== e.linewidth && (n.linewidth = e.linewidth),
            void 0 !== e.dashSize && (n.dashSize = e.dashSize),
            void 0 !== e.gapSize && (n.gapSize = e.gapSize),
            void 0 !== e.scale && (n.scale = e.scale),
            void 0 !== e.polygonOffset && (n.polygonOffset = e.polygonOffset),
            void 0 !== e.polygonOffsetFactor && (n.polygonOffsetFactor = e.polygonOffsetFactor),
            void 0 !== e.polygonOffsetUnits && (n.polygonOffsetUnits = e.polygonOffsetUnits),
            void 0 !== e.skinning && (n.skinning = e.skinning),
            void 0 !== e.morphTargets && (n.morphTargets = e.morphTargets),
            void 0 !== e.dithering && (n.dithering = e.dithering),
            void 0 !== e.visible && (n.visible = e.visible),
            void 0 !== e.userData && (n.userData = e.userData),
            void 0 !== e.uniforms)
                for (var r in e.uniforms) {
                    var a = e.uniforms[r];
                    switch (n.uniforms[r] = {},
                    a.type) {
                    case "t":
                        n.uniforms[r].value = t(a.value);
                        break;
                    case "c":
                        n.uniforms[r].value = (new d).setHex(a.value);
                        break;
                    case "v2":
                        n.uniforms[r].value = (new Y).fromArray(a.value);
                        break;
                    case "v3":
                        n.uniforms[r].value = (new Me).fromArray(a.value);
                        break;
                    case "v4":
                        n.uniforms[r].value = (new Ee).fromArray(a.value);
                        break;
                    case "m3":
                        n.uniforms[r].value = (new g).fromArray(a.value);
                    case "m4":
                        n.uniforms[r].value = (new _e).fromArray(a.value);
                        break;
                    default:
                        n.uniforms[r].value = a.value
                    }
                }
            if (void 0 !== e.defines && (n.defines = e.defines),
            void 0 !== e.vertexShader && (n.vertexShader = e.vertexShader),
            void 0 !== e.fragmentShader && (n.fragmentShader = e.fragmentShader),
            void 0 !== e.extensions)
                for (var o in e.extensions)
                    n.extensions[o] = e.extensions[o];
            return void 0 !== e.shading && (n.flatShading = 1 === e.shading),
            void 0 !== e.size && (n.size = e.size),
            void 0 !== e.sizeAttenuation && (n.sizeAttenuation = e.sizeAttenuation),
            void 0 !== e.map && (n.map = t(e.map)),
            void 0 !== e.alphaMap && (n.alphaMap = t(e.alphaMap),
            n.transparent = !0),
            void 0 !== e.bumpMap && (n.bumpMap = t(e.bumpMap)),
            void 0 !== e.bumpScale && (n.bumpScale = e.bumpScale),
            void 0 !== e.normalMap && (n.normalMap = t(e.normalMap)),
            void 0 !== e.normalMapType && (n.normalMapType = e.normalMapType),
            void 0 !== e.normalScale && (r = e.normalScale,
            !1 === Array.isArray(r) && (r = [r, r]),
            n.normalScale = (new Y).fromArray(r)),
            void 0 !== e.displacementMap && (n.displacementMap = t(e.displacementMap)),
            void 0 !== e.displacementScale && (n.displacementScale = e.displacementScale),
            void 0 !== e.displacementBias && (n.displacementBias = e.displacementBias),
            void 0 !== e.roughnessMap && (n.roughnessMap = t(e.roughnessMap)),
            void 0 !== e.metalnessMap && (n.metalnessMap = t(e.metalnessMap)),
            void 0 !== e.emissiveMap && (n.emissiveMap = t(e.emissiveMap)),
            void 0 !== e.emissiveIntensity && (n.emissiveIntensity = e.emissiveIntensity),
            void 0 !== e.specularMap && (n.specularMap = t(e.specularMap)),
            void 0 !== e.envMap && (n.envMap = t(e.envMap)),
            void 0 !== e.envMapIntensity && (n.envMapIntensity = e.envMapIntensity),
            void 0 !== e.reflectivity && (n.reflectivity = e.reflectivity),
            void 0 !== e.lightMap && (n.lightMap = t(e.lightMap)),
            void 0 !== e.lightMapIntensity && (n.lightMapIntensity = e.lightMapIntensity),
            void 0 !== e.aoMap && (n.aoMap = t(e.aoMap)),
            void 0 !== e.aoMapIntensity && (n.aoMapIntensity = e.aoMapIntensity),
            void 0 !== e.gradientMap && (n.gradientMap = t(e.gradientMap)),
            n
        },
        setPath: function(e) {
            return this.path = e,
            this
        },
        setTextures: function(e) {
            return this.textures = e,
            this
        }
    }),
    {
        decodeText: function(e) {
            if ("undefined" != typeof TextDecoder)
                return (new TextDecoder).decode(e);
            for (var t = "", i = 0, n = e.length; i < n; i++)
                t += String.fromCharCode(e[i]);
            return decodeURIComponent(escape(t))
        },
        extractUrlBase: function(e) {
            var t = e.lastIndexOf("/");
            return -1 === t ? "./" : e.substr(0, t + 1)
        }
    }), qc = (Object.assign(rr.prototype, {
        load: function(e, t, i, n) {
            var r = this
              , a = new En(r.manager);
            a.setPath(r.path),
            a.load(e, function(e) {
                t(r.parse(JSON.parse(e)))
            }, i, n)
        },
        parse: function(e) {
            var t = new U
              , i = (void 0 !== (r = e.data.index) && (r = new qc[r.type](r.array),
            t.setIndex(new m(r,1))),
            e.data.attributes);
            for (a in i) {
                var n = i[a]
                  , r = new qc[n.type](n.array);
                t.addAttribute(a, new m(r,n.itemSize,n.normalized))
            }
            var a = e.data.groups || e.data.drawcalls || e.data.offsets;
            if (void 0 !== a)
                for (r = 0,
                i = a.length; r !== i; ++r)
                    n = a[r],
                    t.addGroup(n.start, n.count, n.materialIndex);
            return void 0 !== (a = e.data.boundingSphere) && (r = new Me,
            void 0 !== a.center && r.fromArray(a.center),
            t.boundingSphere = new I(r,a.radius)),
            e.name && (t.name = e.name),
            e.userData && (t.userData = e.userData),
            t
        },
        setPath: function(e) {
            return this.path = e,
            this
        }
    }),
    {
        Int8Array: Int8Array,
        Uint8Array: Uint8Array,
        Uint8ClampedArray: "undefined" != typeof Uint8ClampedArray ? Uint8ClampedArray : Uint8Array,
        Int16Array: Int16Array,
        Uint16Array: Uint16Array,
        Int32Array: Int32Array,
        Uint32Array: Uint32Array,
        Float32Array: Float32Array,
        Float64Array: Float64Array
    }), Xc = (Object.assign(ar.prototype, {
        crossOrigin: "anonymous",
        load: function(i, n, e, r) {
            var a = this
              , t = void 0 === this.path ? Wc.extractUrlBase(i) : this.path;
            this.resourcePath = this.resourcePath || t,
            (t = new En(a.manager)).setPath(this.path),
            t.load(i, function(e) {
                var t = null;
                try {
                    t = JSON.parse(e)
                } catch (e) {
                    return void 0 !== r && r(e),
                    void console.error("THREE:ObjectLoader: Can't parse " + i + ".", e.message)
                }
                void 0 === (e = t.metadata) || void 0 === e.type || "geometry" === e.type.toLowerCase() ? console.error("THREE.ObjectLoader: Can't load " + i) : a.parse(t, n)
            }, e, r)
        },
        setPath: function(e) {
            return this.path = e,
            this
        },
        setResourcePath: function(e) {
            return this.resourcePath = e,
            this
        },
        setCrossOrigin: function(e) {
            return this.crossOrigin = e,
            this
        },
        parse: function(e, t) {
            var i = this.parseShape(e.shapes)
              , i = this.parseGeometries(e.geometries, i)
              , n = this.parseImages(e.images, function() {
                void 0 !== t && t(r)
            })
              , n = this.parseTextures(e.textures, n)
              , r = (n = this.parseMaterials(e.materials, n),
            this.parseObject(e.object, i, n));
            return e.animations && (r.animations = this.parseAnimations(e.animations)),
            void 0 !== e.images && 0 !== e.images.length || void 0 === t || t(r),
            r
        },
        parseShape: function(e) {
            var t = {};
            if (void 0 !== e)
                for (var i = 0, n = e.length; i < n; i++) {
                    var r = (new qn).fromJSON(e[i]);
                    t[r.uuid] = r
                }
            return t
        },
        parseGeometries: function(e, t) {
            var i = {};
            if (void 0 !== e)
                for (var n = new rr, r = 0, a = e.length; r < a; r++) {
                    var o = e[r];
                    switch (o.type) {
                    case "PlaneGeometry":
                    case "PlaneBufferGeometry":
                        var s = new Bc[o.type](o.width,o.height,o.widthSegments,o.heightSegments);
                        break;
                    case "BoxGeometry":
                    case "BoxBufferGeometry":
                    case "CubeGeometry":
                        s = new Bc[o.type](o.width,o.height,o.depth,o.widthSegments,o.heightSegments,o.depthSegments);
                        break;
                    case "CircleGeometry":
                    case "CircleBufferGeometry":
                        s = new Bc[o.type](o.radius,o.segments,o.thetaStart,o.thetaLength);
                        break;
                    case "CylinderGeometry":
                    case "CylinderBufferGeometry":
                        s = new Bc[o.type](o.radiusTop,o.radiusBottom,o.height,o.radialSegments,o.heightSegments,o.openEnded,o.thetaStart,o.thetaLength);
                        break;
                    case "ConeGeometry":
                    case "ConeBufferGeometry":
                        s = new Bc[o.type](o.radius,o.height,o.radialSegments,o.heightSegments,o.openEnded,o.thetaStart,o.thetaLength);
                        break;
                    case "SphereGeometry":
                    case "SphereBufferGeometry":
                        s = new Bc[o.type](o.radius,o.widthSegments,o.heightSegments,o.phiStart,o.phiLength,o.thetaStart,o.thetaLength);
                        break;
                    case "DodecahedronGeometry":
                    case "DodecahedronBufferGeometry":
                    case "IcosahedronGeometry":
                    case "IcosahedronBufferGeometry":
                    case "OctahedronGeometry":
                    case "OctahedronBufferGeometry":
                    case "TetrahedronGeometry":
                    case "TetrahedronBufferGeometry":
                        s = new Bc[o.type](o.radius,o.detail);
                        break;
                    case "RingGeometry":
                    case "RingBufferGeometry":
                        s = new Bc[o.type](o.innerRadius,o.outerRadius,o.thetaSegments,o.phiSegments,o.thetaStart,o.thetaLength);
                        break;
                    case "TorusGeometry":
                    case "TorusBufferGeometry":
                        s = new Bc[o.type](o.radius,o.tube,o.radialSegments,o.tubularSegments,o.arc);
                        break;
                    case "TorusKnotGeometry":
                    case "TorusKnotBufferGeometry":
                        s = new Bc[o.type](o.radius,o.tube,o.tubularSegments,o.radialSegments,o.p,o.q);
                        break;
                    case "LatheGeometry":
                    case "LatheBufferGeometry":
                        s = new Bc[o.type](o.points,o.segments,o.phiStart,o.phiLength);
                        break;
                    case "PolyhedronGeometry":
                    case "PolyhedronBufferGeometry":
                        s = new Bc[o.type](o.vertices,o.indices,o.radius,o.details);
                        break;
                    case "ShapeGeometry":
                    case "ShapeBufferGeometry":
                        for (var s = [], c = 0, h = o.shapes.length; c < h; c++) {
                            var l = t[o.shapes[c]];
                            s.push(l)
                        }
                        s = new Bc[o.type](s,o.curveSegments);
                        break;
                    case "ExtrudeGeometry":
                    case "ExtrudeBufferGeometry":
                        for (s = [],
                        c = 0,
                        h = o.shapes.length; c < h; c++)
                            l = t[o.shapes[c]],
                            s.push(l);
                        void 0 !== (c = o.options.extrudePath) && (o.options.extrudePath = (new jc[c.type]).fromJSON(c)),
                        s = new Bc[o.type](s,o.options);
                        break;
                    case "BufferGeometry":
                        s = n.parse(o);
                        break;
                    case "Geometry":
                        "THREE"in window && "LegacyJSONLoader"in THREE ? s = (new THREE.LegacyJSONLoader).parse(o, this.resourcePath).geometry : console.error('THREE.ObjectLoader: You have to import LegacyJSONLoader in order load geometry data of type "Geometry".');
                        break;
                    default:
                        console.warn('THREE.ObjectLoader: Unsupported geometry type "' + o.type + '"');
                        continue
                    }
                    s.uuid = o.uuid,
                    void 0 !== o.name && (s.name = o.name),
                    !0 === s.isBufferGeometry && void 0 !== o.userData && (s.userData = o.userData),
                    i[o.uuid] = s
                }
            return i
        },
        parseMaterials: function(e, t) {
            var i = {}
              , n = {};
            if (void 0 !== e) {
                var r = new nr;
                r.setTextures(t),
                t = 0;
                for (var a = e.length; t < a; t++) {
                    var o = e[t];
                    if ("MultiMaterial" === o.type) {
                        for (var s = [], c = 0; c < o.materials.length; c++) {
                            var h = o.materials[c];
                            void 0 === i[h.uuid] && (i[h.uuid] = r.parse(h)),
                            s.push(i[h.uuid])
                        }
                        n[o.uuid] = s
                    } else
                        void 0 === i[o.uuid] && (i[o.uuid] = r.parse(o)),
                        n[o.uuid] = i[o.uuid]
                }
            }
            return n
        },
        parseAnimations: function(e) {
            for (var t = [], i = 0; i < e.length; i++) {
                var n = e[i]
                  , r = wn.parse(n);
                void 0 !== n.uuid && (r.uuid = n.uuid),
                t.push(r)
            }
            return t
        },
        parseImages: function(e, t) {
            function i(e) {
                return n.manager.itemStart(e),
                a.load(e, function() {
                    n.manager.itemEnd(e)
                }, void 0, function() {
                    n.manager.itemError(e),
                    n.manager.itemEnd(e)
                })
            }
            var n = this
              , r = {};
            if (void 0 !== e && 0 < e.length) {
                var a = new Ln(t = new Mn(t));
                a.setCrossOrigin(this.crossOrigin),
                t = 0;
                for (var o = e.length; t < o; t++) {
                    var s = e[t]
                      , c = s.url;
                    if (Array.isArray(c)) {
                        r[s.uuid] = [];
                        for (var h = 0, l = c.length; h < l; h++) {
                            var u = c[h]
                              , u = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(u) ? u : n.resourcePath + u;
                            r[s.uuid].push(i(u))
                        }
                    } else
                        u = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(s.url) ? s.url : n.resourcePath + s.url,
                        r[s.uuid] = i(u)
                }
            }
            return r
        },
        parseTextures: function(e, t) {
            function i(e, t) {
                return "number" == typeof e ? e : (console.warn("THREE.ObjectLoader.parseTexture: Constant should be in numeric form.", e),
                t[e])
            }
            var n = {};
            if (void 0 !== e)
                for (var r = 0, a = e.length; r < a; r++) {
                    var o = e[r]
                      , s = (void 0 === o.image && console.warn('THREE.ObjectLoader: No "image" specified for', o.uuid),
                    void 0 === t[o.image] && console.warn("THREE.ObjectLoader: Undefined image", o.image),
                    new (Array.isArray(t[o.image]) ? ae : p)(t[o.image]));
                    s.needsUpdate = !0,
                    s.uuid = o.uuid,
                    void 0 !== o.name && (s.name = o.name),
                    void 0 !== o.mapping && (s.mapping = i(o.mapping, Xc)),
                    void 0 !== o.offset && s.offset.fromArray(o.offset),
                    void 0 !== o.repeat && s.repeat.fromArray(o.repeat),
                    void 0 !== o.center && s.center.fromArray(o.center),
                    void 0 !== o.rotation && (s.rotation = o.rotation),
                    void 0 !== o.wrap && (s.wrapS = i(o.wrap[0], Yc),
                    s.wrapT = i(o.wrap[1], Yc)),
                    void 0 !== o.format && (s.format = o.format),
                    void 0 !== o.type && (s.type = o.type),
                    void 0 !== o.encoding && (s.encoding = o.encoding),
                    void 0 !== o.minFilter && (s.minFilter = i(o.minFilter, Jc)),
                    void 0 !== o.magFilter && (s.magFilter = i(o.magFilter, Jc)),
                    void 0 !== o.anisotropy && (s.anisotropy = o.anisotropy),
                    void 0 !== o.flipY && (s.flipY = o.flipY),
                    void 0 !== o.premultiplyAlpha && (s.premultiplyAlpha = o.premultiplyAlpha),
                    void 0 !== o.unpackAlignment && (s.unpackAlignment = o.unpackAlignment),
                    n[o.uuid] = s
                }
            return n
        },
        parseObject: function(e, t, a) {
            function i(e) {
                return void 0 === t[e] && console.warn("THREE.ObjectLoader: Undefined geometry", e),
                t[e]
            }
            function n(e) {
                if (void 0 !== e) {
                    if (Array.isArray(e)) {
                        for (var t = [], i = 0, n = e.length; i < n; i++) {
                            var r = e[i];
                            void 0 === a[r] && console.warn("THREE.ObjectLoader: Undefined material", r),
                            t.push(a[r])
                        }
                        return t
                    }
                    return void 0 === a[e] && console.warn("THREE.ObjectLoader: Undefined material", e),
                    a[e]
                }
            }
            switch (e.type) {
            case "Scene":
                var r = new zt;
                void 0 !== e.background && Number.isInteger(e.background) && (r.background = new d(e.background)),
                void 0 !== e.fog && ("Fog" === e.fog.type ? r.fog = new Nt(e.fog.color,e.fog.near,e.fog.far) : "FogExp2" === e.fog.type && (r.fog = new Bt(e.fog.color,e.fog.density)));
                break;
            case "PerspectiveCamera":
                r = new E(e.fov,e.aspect,e.near,e.far),
                void 0 !== e.focus && (r.focus = e.focus),
                void 0 !== e.zoom && (r.zoom = e.zoom),
                void 0 !== e.filmGauge && (r.filmGauge = e.filmGauge),
                void 0 !== e.filmOffset && (r.filmOffset = e.filmOffset),
                void 0 !== e.view && (r.view = Object.assign({}, e.view));
                break;
            case "OrthographicCamera":
                r = new Kn(e.left,e.right,e.top,e.bottom,e.near,e.far),
                void 0 !== e.zoom && (r.zoom = e.zoom),
                void 0 !== e.view && (r.view = Object.assign({}, e.view));
                break;
            case "AmbientLight":
                r = new tr(e.color,e.intensity);
                break;
            case "DirectionalLight":
                r = new er(e.color,e.intensity);
                break;
            case "PointLight":
                r = new Qn(e.color,e.intensity,e.distance,e.decay);
                break;
            case "RectAreaLight":
                r = new ir(e.color,e.intensity,e.width,e.height);
                break;
            case "SpotLight":
                r = new Zn(e.color,e.intensity,e.distance,e.angle,e.penumbra,e.decay);
                break;
            case "HemisphereLight":
                r = new Xn(e.color,e.groundColor,e.intensity);
                break;
            case "SkinnedMesh":
                console.warn("THREE.ObjectLoader.parseObject() does not support SkinnedMesh yet.");
            case "Mesh":
                var r = i(e.geometry)
                  , o = n(e.material);
                r = new (r.bones && 0 < r.bones.length ? Vt : v)(r,o),
                void 0 !== e.drawMode && r.setDrawMode(e.drawMode);
                break;
            case "LOD":
                r = new kt;
                break;
            case "Line":
                r = new h(i(e.geometry),n(e.material),e.mode);
                break;
            case "LineLoop":
                r = new qt(i(e.geometry),n(e.material));
                break;
            case "LineSegments":
                r = new x(i(e.geometry),n(e.material));
                break;
            case "PointCloud":
            case "Points":
                r = new Yt(i(e.geometry),n(e.material));
                break;
            case "Sprite":
                r = new Ht(n(e.material));
                break;
            case "Group":
                r = new Lt;
                break;
            default:
                r = new u
            }
            if (r.uuid = e.uuid,
            void 0 !== e.name && (r.name = e.name),
            void 0 !== e.matrix ? (r.matrix.fromArray(e.matrix),
            void 0 !== e.matrixAutoUpdate && (r.matrixAutoUpdate = e.matrixAutoUpdate),
            r.matrixAutoUpdate && r.matrix.decompose(r.position, r.quaternion, r.scale)) : (void 0 !== e.position && r.position.fromArray(e.position),
            void 0 !== e.rotation && r.rotation.fromArray(e.rotation),
            void 0 !== e.quaternion && r.quaternion.fromArray(e.quaternion),
            void 0 !== e.scale && r.scale.fromArray(e.scale)),
            void 0 !== e.castShadow && (r.castShadow = e.castShadow),
            void 0 !== e.receiveShadow && (r.receiveShadow = e.receiveShadow),
            e.shadow && (void 0 !== e.shadow.bias && (r.shadow.bias = e.shadow.bias),
            void 0 !== e.shadow.radius && (r.shadow.radius = e.shadow.radius),
            void 0 !== e.shadow.mapSize && r.shadow.mapSize.fromArray(e.shadow.mapSize),
            void 0 !== e.shadow.camera) && (r.shadow.camera = this.parseObject(e.shadow.camera)),
            void 0 !== e.visible && (r.visible = e.visible),
            void 0 !== e.frustumCulled && (r.frustumCulled = e.frustumCulled),
            void 0 !== e.renderOrder && (r.renderOrder = e.renderOrder),
            void 0 !== e.userData && (r.userData = e.userData),
            void 0 !== e.layers && (r.layers.mask = e.layers),
            void 0 !== e.children)
                for (var o = e.children, s = 0; s < o.length; s++)
                    r.add(this.parseObject(o[s], t, a));
            if ("LOD" === e.type)
                for (e = e.levels,
                o = 0; o < e.length; o++) {
                    var s = e[o]
                      , c = r.getObjectByProperty("uuid", s.object);
                    void 0 !== c && r.addLevel(c, s.distance)
                }
            return r
        }
    }),
    {
        UVMapping: 300,
        CubeReflectionMapping: 301,
        CubeRefractionMapping: 302,
        EquirectangularReflectionMapping: 303,
        EquirectangularRefractionMapping: 304,
        SphericalReflectionMapping: 305,
        CubeUVReflectionMapping: 306,
        CubeUVRefractionMapping: 307
    }), Yc = {
        RepeatWrapping: 1e3,
        ClampToEdgeWrapping: 1001,
        MirroredRepeatWrapping: 1002
    }, Jc = {
        NearestFilter: 1003,
        NearestMipMapNearestFilter: 1004,
        NearestMipMapLinearFilter: 1005,
        LinearFilter: 1006,
        LinearMipMapNearestFilter: 1007,
        LinearMipMapLinearFilter: 1008
    };
    or.prototype = {
        constructor: or,
        setOptions: function(e) {
            return this.options = e,
            this
        },
        load: function(t, i, e, n) {
            void 0 === t && (t = ""),
            void 0 !== this.path && (t = this.path + t),
            t = this.manager.resolveURL(t);
            var r = this
              , a = zc.get(t);
            if (void 0 !== a)
                return r.manager.itemStart(t),
                setTimeout(function() {
                    i && i(a),
                    r.manager.itemEnd(t)
                }, 0),
                a;
            fetch(t).then(function(e) {
                return e.blob()
            }).then(function(e) {
                return createImageBitmap(e, r.options)
            }).then(function(e) {
                zc.add(t, e),
                i && i(e),
                r.manager.itemEnd(t)
            }).catch(function(e) {
                n && n(e),
                r.manager.itemError(t),
                r.manager.itemEnd(t)
            })
        },
        setCrossOrigin: function() {
            return this
        },
        setPath: function(e) {
            return this.path = e,
            this
        }
    },
    Object.assign(sr.prototype, {
        moveTo: function(e, t) {
            this.currentPath = new Wn,
            this.subPaths.push(this.currentPath),
            this.currentPath.moveTo(e, t)
        },
        lineTo: function(e, t) {
            this.currentPath.lineTo(e, t)
        },
        quadraticCurveTo: function(e, t, i, n) {
            this.currentPath.quadraticCurveTo(e, t, i, n)
        },
        bezierCurveTo: function(e, t, i, n, r, a) {
            this.currentPath.bezierCurveTo(e, t, i, n, r, a)
        },
        splineThru: function(e) {
            this.currentPath.splineThru(e)
        },
        toShapes: function(e, t) {
            function i(e) {
                for (var t = [], i = 0, n = e.length; i < n; i++) {
                    var r = e[i]
                      , a = new qn;
                    a.curves = r.curves,
                    t.push(a)
                }
                return t
            }
            var n = Ic.isClockWise
              , r = this.subPaths;
            if (0 === r.length)
                return [];
            if (!0 === t)
                return i(r);
            if (t = [],
            1 === r.length)
                p = r[0],
                (o = new qn).curves = p.curves,
                t.push(o);
            else {
                var a = !n(r[0].getPoints())
                  , a = e ? !a : a
                  , o = []
                  , s = []
                  , c = []
                  , h = 0;
                s[h] = void 0,
                c[h] = [];
                for (var l = 0, u = r.length; l < u; l++) {
                    var p, d = (p = r[l]).getPoints(), f = n(d);
                    (f = e ? !f : f) ? (!a && s[h] && h++,
                    s[h] = {
                        s: new qn,
                        p: d
                    },
                    s[h].s.curves = p.curves,
                    a && h++,
                    c[h] = []) : c[h].push({
                        h: p,
                        p: d[0]
                    })
                }
                if (!s[0])
                    return i(r);
                if (1 < s.length) {
                    for (l = !1,
                    e = [],
                    n = 0,
                    r = s.length; n < r; n++)
                        o[n] = [];
                    for (n = 0,
                    r = s.length; n < r; n++)
                        for (p = c[n],
                        f = 0; f < p.length; f++) {
                            for (a = p[f],
                            h = !0,
                            d = 0; d < s.length; d++)
                                !function(e, t) {
                                    for (var i = t.length, n = !1, r = i - 1, a = 0; a < i; r = a++) {
                                        var o = t[r]
                                          , s = t[a]
                                          , c = s.x - o.x
                                          , h = s.y - o.y;
                                        if (Math.abs(h) > Number.EPSILON) {
                                            if (h < 0 && (o = t[a],
                                            c = -c,
                                            s = t[r],
                                            h = -h),
                                            !(e.y < o.y || e.y > s.y))
                                                if (e.y === o.y) {
                                                    if (e.x === o.x)
                                                        return 1
                                                } else {
                                                    if (0 === (r = h * (e.x - o.x) - c * (e.y - o.y)))
                                                        return 1;
                                                    r < 0 || (n = !n)
                                                }
                                        } else if (e.y === o.y && (s.x <= e.x && e.x <= o.x || o.x <= e.x && e.x <= s.x))
                                            return 1
                                    }
                                    return n
                                }(a.p, s[d].p) || (n !== d && e.push({
                                    froms: n,
                                    tos: d,
                                    hole: f
                                }),
                                h ? (h = !1,
                                o[d].push(a)) : l = !0);
                            h && o[n].push(a)
                        }
                    0 < e.length && (l || (c = o))
                }
                for (l = 0,
                n = s.length; l < n; l++)
                    for (o = s[l].s,
                    t.push(o),
                    r = 0,
                    p = (e = c[l]).length; r < p; r++)
                        o.holes.push(e[r].h)
            }
            return t
        }
    }),
    Object.assign(cr.prototype, {
        isFont: !0,
        generateShapes: function(e, t) {
            var i = []
              , n = t = void 0 === t ? 100 : t
              , r = (t = this.data,
            Array.from ? Array.from(e) : String(e).split(""))
              , a = (n /= t.resolution,
            (t.boundingBox.yMax - t.boundingBox.yMin + t.underlineThickness) * n);
            e = [];
            for (var o = 0, s = 0, c = 0; c < r.length; c++) {
                var h = r[c];
                if ("\n" === h)
                    o = 0,
                    s -= a;
                else {
                    var l = n
                      , u = o
                      , p = s;
                    if (h = t.glyphs[h] || t.glyphs["?"]) {
                        var d = new sr;
                        if (h.o)
                            for (var f = h._cachedOutline || (h._cachedOutline = h.o.split(" ")), m = 0, g = f.length; m < g; )
                                switch (f[m++]) {
                                case "m":
                                    var v = f[m++] * l + u
                                      , y = f[m++] * l + p;
                                    d.moveTo(v, y);
                                    break;
                                case "l":
                                    v = f[m++] * l + u,
                                    y = f[m++] * l + p,
                                    d.lineTo(v, y);
                                    break;
                                case "q":
                                    var x = f[m++] * l + u
                                      , b = f[m++] * l + p
                                      , w = f[m++] * l + u
                                      , _ = f[m++] * l + p;
                                    d.quadraticCurveTo(w, _, x, b);
                                    break;
                                case "b":
                                    x = f[m++] * l + u,
                                    b = f[m++] * l + p,
                                    w = f[m++] * l + u,
                                    _ = f[m++] * l + p,
                                    v = f[m++] * l + u,
                                    y = f[m++] * l + p,
                                    d.bezierCurveTo(w, _, v, y, x, b)
                                }
                        l = {
                            offsetX: h.ha * l,
                            path: d
                        }
                    } else
                        l = void 0;
                    o += l.offsetX,
                    e.push(l.path)
                }
            }
            for (t = 0,
            r = e.length; t < r; t++)
                Array.prototype.push.apply(i, e[t].toShapes());
            return i
        }
    }),
    Object.assign(hr.prototype, {
        load: function(e, n, t, i) {
            var r = this
              , a = new En(this.manager);
            a.setPath(this.path),
            a.load(e, function(t) {
                try {
                    var i = JSON.parse(t)
                } catch (e) {
                    console.warn("THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead."),
                    i = JSON.parse(t.substring(65, t.length - 2))
                }
                t = r.parse(i),
                n && n(t)
            }, t, i)
        },
        parse: function(e) {
            return new cr(e)
        },
        setPath: function(e) {
            return this.path = e,
            this
        }
    }),
    lr.Handlers = {
        handlers: [],
        add: function(e, t) {
            this.handlers.push(e, t)
        },
        get: function(e) {
            for (var t = this.handlers, i = 0, n = t.length; i < n; i += 2) {
                var r = t[i + 1];
                if (t[i].test(e))
                    return r
            }
            return null
        }
    },
    Object.assign(lr.prototype, {
        crossOrigin: "anonymous",
        onLoadStart: function() {},
        onLoadProgress: function() {},
        onLoadComplete: function() {},
        initMaterials: function(e, t, i) {
            for (var n = [], r = 0; r < e.length; ++r)
                n[r] = this.createMaterial(e[r], t, i);
            return n
        },
        createMaterial: (Lc = {
            NoBlending: 0,
            NormalBlending: 1,
            AdditiveBlending: 2,
            SubtractiveBlending: 3,
            MultiplyBlending: 4,
            CustomBlending: 5
        },
        Pc = new d,
        Rc = new Rn,
        Cc = new nr,
        function(e, o, s) {
            function t(e, t, i, n, r) {
                var a = lr.Handlers.get(e = o + e);
                return e = (null !== a ? a : (Rc.setCrossOrigin(s),
                Rc)).load(e),
                void 0 !== t && (e.repeat.fromArray(t),
                1 !== t[0] && (e.wrapS = 1e3),
                1 !== t[1]) && (e.wrapT = 1e3),
                void 0 !== i && e.offset.fromArray(i),
                void 0 !== n && ("repeat" === n[0] && (e.wrapS = 1e3),
                "mirror" === n[0] && (e.wrapS = 1002),
                "repeat" === n[1] && (e.wrapT = 1e3),
                "mirror" === n[1]) && (e.wrapT = 1002),
                void 0 !== r && (e.anisotropy = r),
                t = Se.generateUUID(),
                c[t] = e,
                t
            }
            var i, c = {}, n = {
                uuid: Se.generateUUID(),
                type: "MeshLambertMaterial"
            };
            for (i in e) {
                var r = e[i];
                switch (i) {
                case "DbgColor":
                case "DbgIndex":
                case "opticalDensity":
                case "illumination":
                    break;
                case "DbgName":
                    n.name = r;
                    break;
                case "blending":
                    n.blending = Lc[r];
                    break;
                case "colorAmbient":
                case "mapAmbient":
                    console.warn("THREE.Loader.createMaterial:", i, "is no longer supported.");
                    break;
                case "colorDiffuse":
                    n.color = Pc.fromArray(r).getHex();
                    break;
                case "colorSpecular":
                    n.specular = Pc.fromArray(r).getHex();
                    break;
                case "colorEmissive":
                    n.emissive = Pc.fromArray(r).getHex();
                    break;
                case "specularCoef":
                    n.shininess = r;
                    break;
                case "shading":
                    "basic" === r.toLowerCase() && (n.type = "MeshBasicMaterial"),
                    "phong" === r.toLowerCase() && (n.type = "MeshPhongMaterial"),
                    "standard" === r.toLowerCase() && (n.type = "MeshStandardMaterial");
                    break;
                case "mapDiffuse":
                    n.map = t(r, e.mapDiffuseRepeat, e.mapDiffuseOffset, e.mapDiffuseWrap, e.mapDiffuseAnisotropy);
                    break;
                case "mapDiffuseRepeat":
                case "mapDiffuseOffset":
                case "mapDiffuseWrap":
                case "mapDiffuseAnisotropy":
                    break;
                case "mapEmissive":
                    n.emissiveMap = t(r, e.mapEmissiveRepeat, e.mapEmissiveOffset, e.mapEmissiveWrap, e.mapEmissiveAnisotropy);
                    break;
                case "mapEmissiveRepeat":
                case "mapEmissiveOffset":
                case "mapEmissiveWrap":
                case "mapEmissiveAnisotropy":
                    break;
                case "mapLight":
                    n.lightMap = t(r, e.mapLightRepeat, e.mapLightOffset, e.mapLightWrap, e.mapLightAnisotropy);
                    break;
                case "mapLightRepeat":
                case "mapLightOffset":
                case "mapLightWrap":
                case "mapLightAnisotropy":
                    break;
                case "mapAO":
                    n.aoMap = t(r, e.mapAORepeat, e.mapAOOffset, e.mapAOWrap, e.mapAOAnisotropy);
                    break;
                case "mapAORepeat":
                case "mapAOOffset":
                case "mapAOWrap":
                case "mapAOAnisotropy":
                    break;
                case "mapBump":
                    n.bumpMap = t(r, e.mapBumpRepeat, e.mapBumpOffset, e.mapBumpWrap, e.mapBumpAnisotropy);
                    break;
                case "mapBumpScale":
                    n.bumpScale = r;
                    break;
                case "mapBumpRepeat":
                case "mapBumpOffset":
                case "mapBumpWrap":
                case "mapBumpAnisotropy":
                    break;
                case "mapNormal":
                    n.normalMap = t(r, e.mapNormalRepeat, e.mapNormalOffset, e.mapNormalWrap, e.mapNormalAnisotropy);
                    break;
                case "mapNormalFactor":
                    n.normalScale = r;
                    break;
                case "mapNormalRepeat":
                case "mapNormalOffset":
                case "mapNormalWrap":
                case "mapNormalAnisotropy":
                    break;
                case "mapSpecular":
                    n.specularMap = t(r, e.mapSpecularRepeat, e.mapSpecularOffset, e.mapSpecularWrap, e.mapSpecularAnisotropy);
                    break;
                case "mapSpecularRepeat":
                case "mapSpecularOffset":
                case "mapSpecularWrap":
                case "mapSpecularAnisotropy":
                    break;
                case "mapMetalness":
                    n.metalnessMap = t(r, e.mapMetalnessRepeat, e.mapMetalnessOffset, e.mapMetalnessWrap, e.mapMetalnessAnisotropy);
                    break;
                case "mapMetalnessRepeat":
                case "mapMetalnessOffset":
                case "mapMetalnessWrap":
                case "mapMetalnessAnisotropy":
                    break;
                case "mapRoughness":
                    n.roughnessMap = t(r, e.mapRoughnessRepeat, e.mapRoughnessOffset, e.mapRoughnessWrap, e.mapRoughnessAnisotropy);
                    break;
                case "mapRoughnessRepeat":
                case "mapRoughnessOffset":
                case "mapRoughnessWrap":
                case "mapRoughnessAnisotropy":
                    break;
                case "mapAlpha":
                    n.alphaMap = t(r, e.mapAlphaRepeat, e.mapAlphaOffset, e.mapAlphaWrap, e.mapAlphaAnisotropy);
                    break;
                case "mapAlphaRepeat":
                case "mapAlphaOffset":
                case "mapAlphaWrap":
                case "mapAlphaAnisotropy":
                    break;
                case "flipSided":
                    n.side = 1;
                    break;
                case "doubleSided":
                    n.side = 2;
                    break;
                case "transparency":
                    console.warn("THREE.Loader.createMaterial: transparency has been renamed to opacity"),
                    n.opacity = r;
                    break;
                case "depthTest":
                case "depthWrite":
                case "colorWrite":
                case "opacity":
                case "reflectivity":
                case "transparent":
                case "visible":
                case "wireframe":
                    n[i] = r;
                    break;
                case "vertexColors":
                    !0 === r && (n.vertexColors = 2),
                    "face" === r && (n.vertexColors = 1);
                    break;
                default:
                    console.error("THREE.Loader.createMaterial: Unsupported", i, r)
                }
            }
            return "MeshBasicMaterial" === n.type && delete n.emissive,
            "MeshPhongMaterial" !== n.type && delete n.specular,
            n.opacity < 1 && (n.transparent = !0),
            Cc.setTextures(c),
            Cc.parse(n)
        }
        )
    });
    var Zc, Qc, Kc, $c, eh, th, ih, nh, rh, ah, oh, sh, ch, hh, lh, uh, ph, dh, fh, mh, gh, vh, yh, xh, bh, wh, _h, Mh, Eh, Sh, Th, Ah, Lh, Ph, Rh, Ch, Oh, Ih, Dh, Bh, Nh, zh, Uh, Gh, Fh, Hh, kh, Vh, jh, Wh, qh, Xh, Yh, Jh, Zh, Qh, Kh, $h = {
        getContext: function() {
            return Zc = void 0 === Zc ? new (window.AudioContext || window.webkitAudioContext) : Zc
        },
        setContext: function(e) {
            Zc = e
        }
    };
    function n(e, t, i, n) {
        if (Wh.set(t, i, n).unproject(qh),
        void 0 !== (e = jh[e]))
            for (t = Vh.getAttribute("position"),
            i = 0,
            n = e.length; i < n; i++)
                t.setXYZ(e[i], Wh.x, Wh.y, Wh.z)
    }
    Object.assign(ur.prototype, {
        load: function(e, t, i, n) {
            var r = new En(this.manager);
            r.setResponseType("arraybuffer"),
            r.setPath(this.path),
            r.load(e, function(e) {
                e = e.slice(0),
                $h.getContext().decodeAudioData(e, function(e) {
                    t(e)
                })
            }, i, n)
        },
        setPath: function(e) {
            return this.path = e,
            this
        }
    }),
    Object.assign(pr.prototype, {
        update: (ah = new _e,
        oh = new _e,
        function(e) {
            var t, i, n, r, a;
            Qc === this && Kc === e.focus && $c === e.fov && eh === e.aspect * this.aspect && th === e.near && ih === e.far && nh === e.zoom && rh === this.eyeSep || (Qc = this,
            Kc = e.focus,
            $c = e.fov,
            eh = e.aspect * this.aspect,
            th = e.near,
            ih = e.far,
            nh = e.zoom,
            t = e.projectionMatrix.clone(),
            i = (rh = this.eyeSep / 2) * th / Kc,
            n = th * Math.tan(Se.DEG2RAD * $c * .5) / nh,
            oh.elements[12] = -rh,
            ah.elements[12] = rh,
            r = -n * eh + i,
            a = n * eh + i,
            t.elements[0] = 2 * th / (a - r),
            t.elements[8] = (a + r) / (a - r),
            this.cameraL.projectionMatrix.copy(t),
            r = -n * eh - i,
            a = n * eh - i,
            t.elements[0] = 2 * th / (a - r),
            t.elements[8] = (a + r) / (a - r),
            this.cameraR.projectionMatrix.copy(t)),
            this.cameraL.matrixWorld.copy(e.matrixWorld).multiply(oh),
            this.cameraR.matrixWorld.copy(e.matrixWorld).multiply(ah)
        }
        )
    }),
    (dr.prototype = Object.create(u.prototype)).constructor = dr,
    Object.assign(fr.prototype, {
        start: function() {
            this.oldTime = this.startTime = ("undefined" == typeof performance ? Date : performance).now(),
            this.elapsedTime = 0,
            this.running = !0
        },
        stop: function() {
            this.getElapsedTime(),
            this.autoStart = this.running = !1
        },
        getElapsedTime: function() {
            return this.getDelta(),
            this.elapsedTime
        },
        getDelta: function() {
            var e, t = 0;
            return this.autoStart && !this.running ? (this.start(),
            0) : (this.running && (t = ((e = ("undefined" == typeof performance ? Date : performance).now()) - this.oldTime) / 1e3,
            this.oldTime = e,
            this.elapsedTime += t),
            t)
        }
    }),
    mr.prototype = Object.assign(Object.create(u.prototype), {
        constructor: mr,
        getInput: function() {
            return this.gain
        },
        removeFilter: function() {
            return null !== this.filter && (this.gain.disconnect(this.filter),
            this.filter.disconnect(this.context.destination),
            this.gain.connect(this.context.destination),
            this.filter = null),
            this
        },
        getFilter: function() {
            return this.filter
        },
        setFilter: function(e) {
            return (null !== this.filter ? (this.gain.disconnect(this.filter),
            this.filter) : this.gain).disconnect(this.context.destination),
            this.filter = e,
            this.gain.connect(this.filter),
            this.filter.connect(this.context.destination),
            this
        },
        getMasterVolume: function() {
            return this.gain.gain.value
        },
        setMasterVolume: function(e) {
            return this.gain.gain.setTargetAtTime(e, this.context.currentTime, .01),
            this
        },
        updateMatrixWorld: (sh = new Me,
        ch = new M,
        hh = new Me,
        lh = new Me,
        uh = new fr,
        function(e) {
            u.prototype.updateMatrixWorld.call(this, e),
            e = this.context.listener;
            var t, i = this.up;
            this.timeDelta = uh.getDelta(),
            this.matrixWorld.decompose(sh, ch, hh),
            lh.set(0, 0, -1).applyQuaternion(ch),
            e.positionX ? (t = this.context.currentTime + this.timeDelta,
            e.positionX.linearRampToValueAtTime(sh.x, t),
            e.positionY.linearRampToValueAtTime(sh.y, t),
            e.positionZ.linearRampToValueAtTime(sh.z, t),
            e.forwardX.linearRampToValueAtTime(lh.x, t),
            e.forwardY.linearRampToValueAtTime(lh.y, t),
            e.forwardZ.linearRampToValueAtTime(lh.z, t),
            e.upX.linearRampToValueAtTime(i.x, t),
            e.upY.linearRampToValueAtTime(i.y, t),
            e.upZ.linearRampToValueAtTime(i.z, t)) : (e.setPosition(sh.x, sh.y, sh.z),
            e.setOrientation(lh.x, lh.y, lh.z, i.x, i.y, i.z))
        }
        )
    }),
    gr.prototype = Object.assign(Object.create(u.prototype), {
        constructor: gr,
        getOutput: function() {
            return this.gain
        },
        setNodeSource: function(e) {
            return this.hasPlaybackControl = !1,
            this.sourceType = "audioNode",
            this.source = e,
            this.connect(),
            this
        },
        setMediaElementSource: function(e) {
            return this.hasPlaybackControl = !1,
            this.sourceType = "mediaNode",
            this.source = this.context.createMediaElementSource(e),
            this.connect(),
            this
        },
        setBuffer: function(e) {
            return this.buffer = e,
            this.sourceType = "buffer",
            this.autoplay && this.play(),
            this
        },
        play: function() {
            if (!0 === this.isPlaying)
                console.warn("THREE.Audio: Audio is already playing.");
            else {
                var e;
                if (!1 !== this.hasPlaybackControl)
                    return (e = this.context.createBufferSource()).buffer = this.buffer,
                    e.loop = this.loop,
                    e.onended = this.onEnded.bind(this),
                    this.startTime = this.context.currentTime,
                    e.start(this.startTime, this.offset),
                    this.isPlaying = !0,
                    this.source = e,
                    this.setDetune(this.detune),
                    this.setPlaybackRate(this.playbackRate),
                    this.connect();
                console.warn("THREE.Audio: this Audio has no playback control.")
            }
        },
        pause: function() {
            if (!1 !== this.hasPlaybackControl)
                return !0 === this.isPlaying && (this.source.stop(),
                this.source.onended = null,
                this.offset += (this.context.currentTime - this.startTime) * this.playbackRate,
                this.isPlaying = !1),
                this;
            console.warn("THREE.Audio: this Audio has no playback control.")
        },
        stop: function() {
            if (!1 !== this.hasPlaybackControl)
                return this.source.stop(),
                this.source.onended = null,
                this.offset = 0,
                this.isPlaying = !1,
                this;
            console.warn("THREE.Audio: this Audio has no playback control.")
        },
        connect: function() {
            if (0 < this.filters.length) {
                this.source.connect(this.filters[0]);
                for (var e = 1, t = this.filters.length; e < t; e++)
                    this.filters[e - 1].connect(this.filters[e]);
                this.filters[this.filters.length - 1].connect(this.getOutput())
            } else
                this.source.connect(this.getOutput());
            return this
        },
        disconnect: function() {
            if (0 < this.filters.length) {
                this.source.disconnect(this.filters[0]);
                for (var e = 1, t = this.filters.length; e < t; e++)
                    this.filters[e - 1].disconnect(this.filters[e]);
                this.filters[this.filters.length - 1].disconnect(this.getOutput())
            } else
                this.source.disconnect(this.getOutput());
            return this
        },
        getFilters: function() {
            return this.filters
        },
        setFilters: function(e) {
            return e = e || [],
            !0 === this.isPlaying ? (this.disconnect(),
            this.filters = e,
            this.connect()) : this.filters = e,
            this
        },
        setDetune: function(e) {
            if (this.detune = e,
            void 0 !== this.source.detune)
                return !0 === this.isPlaying && this.source.detune.setTargetAtTime(this.detune, this.context.currentTime, .01),
                this
        },
        getDetune: function() {
            return this.detune
        },
        getFilter: function() {
            return this.getFilters()[0]
        },
        setFilter: function(e) {
            return this.setFilters(e ? [e] : [])
        },
        setPlaybackRate: function(e) {
            if (!1 !== this.hasPlaybackControl)
                return this.playbackRate = e,
                !0 === this.isPlaying && this.source.playbackRate.setTargetAtTime(this.playbackRate, this.context.currentTime, .01),
                this;
            console.warn("THREE.Audio: this Audio has no playback control.")
        },
        getPlaybackRate: function() {
            return this.playbackRate
        },
        onEnded: function() {
            this.isPlaying = !1
        },
        getLoop: function() {
            return !1 === this.hasPlaybackControl ? (console.warn("THREE.Audio: this Audio has no playback control."),
            !1) : this.loop
        },
        setLoop: function(e) {
            if (!1 !== this.hasPlaybackControl)
                return this.loop = e,
                !0 === this.isPlaying && (this.source.loop = this.loop),
                this;
            console.warn("THREE.Audio: this Audio has no playback control.")
        },
        getVolume: function() {
            return this.gain.gain.value
        },
        setVolume: function(e) {
            return this.gain.gain.setTargetAtTime(e, this.context.currentTime, .01),
            this
        }
    }),
    vr.prototype = Object.assign(Object.create(gr.prototype), {
        constructor: vr,
        getOutput: function() {
            return this.panner
        },
        getRefDistance: function() {
            return this.panner.refDistance
        },
        setRefDistance: function(e) {
            return this.panner.refDistance = e,
            this
        },
        getRolloffFactor: function() {
            return this.panner.rolloffFactor
        },
        setRolloffFactor: function(e) {
            return this.panner.rolloffFactor = e,
            this
        },
        getDistanceModel: function() {
            return this.panner.distanceModel
        },
        setDistanceModel: function(e) {
            return this.panner.distanceModel = e,
            this
        },
        getMaxDistance: function() {
            return this.panner.maxDistance
        },
        setMaxDistance: function(e) {
            return this.panner.maxDistance = e,
            this
        },
        setDirectionalCone: function(e, t, i) {
            return this.panner.coneInnerAngle = e,
            this.panner.coneOuterAngle = t,
            this.panner.coneOuterGain = i,
            this
        },
        updateMatrixWorld: (ph = new Me,
        dh = new M,
        fh = new Me,
        mh = new Me,
        function(e) {
            var t;
            u.prototype.updateMatrixWorld.call(this, e),
            !1 !== this.isPlaying && (this.matrixWorld.decompose(ph, dh, fh),
            mh.set(0, 0, 1).applyQuaternion(dh),
            (e = this.panner).positionX ? (t = this.context.currentTime + this.listener.timeDelta,
            e.positionX.linearRampToValueAtTime(ph.x, t),
            e.positionY.linearRampToValueAtTime(ph.y, t),
            e.positionZ.linearRampToValueAtTime(ph.z, t),
            e.orientationX.linearRampToValueAtTime(mh.x, t),
            e.orientationY.linearRampToValueAtTime(mh.y, t),
            e.orientationZ.linearRampToValueAtTime(mh.z, t)) : (e.setPosition(ph.x, ph.y, ph.z),
            e.setOrientation(mh.x, mh.y, mh.z)))
        }
        )
    }),
    Object.assign(yr.prototype, {
        getFrequencyData: function() {
            return this.analyser.getByteFrequencyData(this.data),
            this.data
        },
        getAverageFrequency: function() {
            for (var e = 0, t = this.getFrequencyData(), i = 0; i < t.length; i++)
                e += t[i];
            return e / t.length
        }
    }),
    Object.assign(xr.prototype, {
        accumulate: function(e, t) {
            var i = this.buffer
              , n = this.valueSize
              , r = (e = e * n + n,
            this.cumulativeWeight);
            if (0 === r) {
                for (r = 0; r !== n; ++r)
                    i[e + r] = i[r];
                r = t
            } else
                this._mixBufferRegion(i, e, 0, t / (r += t), n);
            this.cumulativeWeight = r
        },
        apply: function(e) {
            var t = this.valueSize
              , i = this.buffer
              , n = (e = e * t + t,
            this.cumulativeWeight)
              , r = this.binding;
            this.cumulativeWeight = 0,
            n < 1 && this._mixBufferRegion(i, e, 3 * t, 1 - n, t);
            for (var n = t, a = t + t; n !== a; ++n)
                if (i[n] !== i[n + t]) {
                    r.setValue(i, e);
                    break
                }
        },
        saveOriginalState: function() {
            var e = this.buffer
              , t = this.valueSize
              , i = 3 * t;
            this.binding.getValue(e, i);
            for (var n = t; n !== i; ++n)
                e[n] = e[i + n % t];
            this.cumulativeWeight = 0
        },
        restoreOriginalState: function() {
            this.binding.setValue(this.buffer, 3 * this.valueSize)
        },
        _select: function(e, t, i, n, r) {
            if (.5 <= n)
                for (n = 0; n !== r; ++n)
                    e[t + n] = e[i + n]
        },
        _slerp: function(e, t, i, n) {
            M.slerpFlat(e, t, e, t, e, i, n)
        },
        _lerp: function(e, t, i, n, r) {
            for (var a = 1 - n, o = 0; o !== r; ++o) {
                var s = t + o;
                e[s] = e[s] * a + e[i + o] * n
            }
        }
    }),
    Object.assign(br.prototype, {
        getValue: function(e, t) {
            this.bind();
            var i = this._bindings[this._targetGroup.nCachedObjects_];
            void 0 !== i && i.getValue(e, t)
        },
        setValue: function(e, t) {
            for (var i = this._bindings, n = this._targetGroup.nCachedObjects_, r = i.length; n !== r; ++n)
                i[n].setValue(e, t)
        },
        bind: function() {
            for (var e = this._bindings, t = this._targetGroup.nCachedObjects_, i = e.length; t !== i; ++t)
                e[t].bind()
        },
        unbind: function() {
            for (var e = this._bindings, t = this._targetGroup.nCachedObjects_, i = e.length; t !== i; ++t)
                e[t].unbind()
        }
    }),
    Object.assign(S, {
        Composite: br,
        create: function(e, t, i) {
            return new (e && e.isAnimationObjectGroup ? S.Composite : S)(e,t,i)
        },
        sanitizeNodeName: (_h = /[\[\]\.:\/]/g,
        function(e) {
            return e.replace(/\s/g, "_").replace(_h, "")
        }
        ),
        parseTrackName: (gh = "[^" + "\\[\\]\\.:\\/".replace("\\.", "") + "]",
        vh = /((?:WC+[\/:])*)/.source.replace("WC", "[^\\[\\]\\.:\\/]"),
        gh = /(WCOD+)?/.source.replace("WCOD", gh),
        yh = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", "[^\\[\\]\\.:\\/]"),
        xh = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", "[^\\[\\]\\.:\\/]"),
        bh = new RegExp("^" + vh + gh + yh + xh + "$"),
        wh = ["material", "materials", "bones"],
        function(e) {
            var t = bh.exec(e);
            if (!t)
                throw Error("PropertyBinding: Cannot parse trackName: " + e);
            var i, n = (t = {
                nodeName: t[2],
                objectName: t[3],
                objectIndex: t[4],
                propertyName: t[5],
                propertyIndex: t[6]
            }).nodeName && t.nodeName.lastIndexOf(".");
            if (void 0 !== n && -1 !== n && (i = t.nodeName.substring(n + 1),
            -1 !== wh.indexOf(i)) && (t.nodeName = t.nodeName.substring(0, n),
            t.objectName = i),
            null === t.propertyName || 0 === t.propertyName.length)
                throw Error("PropertyBinding: can not parse propertyName from trackName: " + e);
            return t
        }
        ),
        findNode: function(e, n) {
            if (!n || "" === n || "root" === n || "." === n || -1 === n || n === e.name || n === e.uuid)
                return e;
            if (e.skeleton) {
                var t = e.skeleton.getBoneByName(n);
                if (void 0 !== t)
                    return t
            }
            if (e.children) {
                function r(e) {
                    for (var t = 0; t < e.length; t++) {
                        var i = e[t];
                        if (i.name === n || i.uuid === n || (i = r(i.children)))
                            return i
                    }
                    return null
                }
                if (e = r(e.children))
                    return e
            }
            return null
        }
    }),
    Object.assign(S.prototype, {
        _getValue_unavailable: function() {},
        _setValue_unavailable: function() {},
        BindingType: {
            Direct: 0,
            EntireArray: 1,
            ArrayElement: 2,
            HasFromToArray: 3
        },
        Versioning: {
            None: 0,
            NeedsUpdate: 1,
            MatrixWorldNeedsUpdate: 2
        },
        GetterByBindingType: [function(e, t) {
            e[t] = this.node[this.propertyName]
        }
        , function(e, t) {
            for (var i = this.resolvedProperty, n = 0, r = i.length; n !== r; ++n)
                e[t++] = i[n]
        }
        , function(e, t) {
            e[t] = this.resolvedProperty[this.propertyIndex]
        }
        , function(e, t) {
            this.resolvedProperty.toArray(e, t)
        }
        ],
        SetterByBindingTypeAndVersioning: [[function(e, t) {
            this.targetObject[this.propertyName] = e[t]
        }
        , function(e, t) {
            this.targetObject[this.propertyName] = e[t],
            this.targetObject.needsUpdate = !0
        }
        , function(e, t) {
            this.targetObject[this.propertyName] = e[t],
            this.targetObject.matrixWorldNeedsUpdate = !0
        }
        ], [function(e, t) {
            for (var i = this.resolvedProperty, n = 0, r = i.length; n !== r; ++n)
                i[n] = e[t++]
        }
        , function(e, t) {
            for (var i = this.resolvedProperty, n = 0, r = i.length; n !== r; ++n)
                i[n] = e[t++];
            this.targetObject.needsUpdate = !0
        }
        , function(e, t) {
            for (var i = this.resolvedProperty, n = 0, r = i.length; n !== r; ++n)
                i[n] = e[t++];
            this.targetObject.matrixWorldNeedsUpdate = !0
        }
        ], [function(e, t) {
            this.resolvedProperty[this.propertyIndex] = e[t]
        }
        , function(e, t) {
            this.resolvedProperty[this.propertyIndex] = e[t],
            this.targetObject.needsUpdate = !0
        }
        , function(e, t) {
            this.resolvedProperty[this.propertyIndex] = e[t],
            this.targetObject.matrixWorldNeedsUpdate = !0
        }
        ], [function(e, t) {
            this.resolvedProperty.fromArray(e, t)
        }
        , function(e, t) {
            this.resolvedProperty.fromArray(e, t),
            this.targetObject.needsUpdate = !0
        }
        , function(e, t) {
            this.resolvedProperty.fromArray(e, t),
            this.targetObject.matrixWorldNeedsUpdate = !0
        }
        ]],
        getValue: function(e, t) {
            this.bind(),
            this.getValue(e, t)
        },
        setValue: function(e, t) {
            this.bind(),
            this.setValue(e, t)
        },
        bind: function() {
            var e = this.node
              , t = this.parsedPath
              , i = t.objectName
              , n = t.propertyName
              , r = t.propertyIndex;
            if (e || (this.node = e = S.findNode(this.rootNode, t.nodeName) || this.rootNode),
            this.getValue = this._getValue_unavailable,
            this.setValue = this._setValue_unavailable,
            e) {
                if (i) {
                    var a = t.objectIndex;
                    switch (i) {
                    case "materials":
                        if (!e.material)
                            return void console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
                        if (!e.material.materials)
                            return void console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this);
                        e = e.material.materials;
                        break;
                    case "bones":
                        if (!e.skeleton)
                            return void console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this);
                        for (e = e.skeleton.bones,
                        i = 0; i < e.length; i++)
                            if (e[i].name === a) {
                                a = i;
                                break
                            }
                        break;
                    default:
                        if (void 0 === e[i])
                            return void console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this);
                        e = e[i]
                    }
                    if (void 0 !== a) {
                        if (void 0 === e[a])
                            return void console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, e);
                        e = e[a]
                    }
                }
                if (void 0 === (a = e[n]))
                    console.error("THREE.PropertyBinding: Trying to update property for track: " + t.nodeName + "." + n + " but it wasn't found.", e);
                else {
                    if (t = this.Versioning.None,
                    void 0 !== (this.targetObject = e).needsUpdate ? t = this.Versioning.NeedsUpdate : void 0 !== e.matrixWorldNeedsUpdate && (t = this.Versioning.MatrixWorldNeedsUpdate),
                    i = this.BindingType.Direct,
                    void 0 !== r) {
                        if ("morphTargetInfluences" === n) {
                            if (!e.geometry)
                                return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this);
                            if (e.geometry.isBufferGeometry) {
                                if (!e.geometry.morphAttributes)
                                    return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this);
                                for (i = 0; i < this.node.geometry.morphAttributes.position.length; i++)
                                    if (e.geometry.morphAttributes.position[i].name === r) {
                                        r = i;
                                        break
                                    }
                            } else {
                                if (!e.geometry.morphTargets)
                                    return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphTargets.", this);
                                for (i = 0; i < this.node.geometry.morphTargets.length; i++)
                                    if (e.geometry.morphTargets[i].name === r) {
                                        r = i;
                                        break
                                    }
                            }
                        }
                        i = this.BindingType.ArrayElement,
                        this.resolvedProperty = a,
                        this.propertyIndex = r
                    } else
                        void 0 !== a.fromArray && void 0 !== a.toArray ? (i = this.BindingType.HasFromToArray,
                        this.resolvedProperty = a) : Array.isArray(a) ? (i = this.BindingType.EntireArray,
                        this.resolvedProperty = a) : this.propertyName = n;
                    this.getValue = this.GetterByBindingType[i],
                    this.setValue = this.SetterByBindingTypeAndVersioning[i][t]
                }
            } else
                console.error("THREE.PropertyBinding: Trying to update node for track: " + this.path + " but it wasn't found.")
        },
        unbind: function() {
            this.node = null,
            this.getValue = this._getValue_unbound,
            this.setValue = this._setValue_unbound
        }
    }),
    Object.assign(S.prototype, {
        _getValue_unbound: S.prototype.getValue,
        _setValue_unbound: S.prototype.setValue
    }),
    Object.assign(wr.prototype, {
        isAnimationObjectGroup: !0,
        add: function() {
            for (var e = this._objects, t = e.length, i = this.nCachedObjects_, n = this._indicesByUUID, r = this._paths, a = this._parsedPaths, o = this._bindings, s = o.length, c = void 0, h = 0, l = arguments.length; h !== l; ++h) {
                var u = arguments[h]
                  , p = n[d = u.uuid];
                if (void 0 === p) {
                    p = t++,
                    n[d] = p,
                    e.push(u);
                    for (var d = 0, f = s; d !== f; ++d)
                        o[d].push(new S(u,r[d],a[d]))
                } else if (p < i) {
                    var c = e[p]
                      , m = --i;
                    for (e[n[(f = e[m]).uuid] = p] = f,
                    e[n[d] = m] = u,
                    d = 0,
                    f = s; d !== f; ++d) {
                        var g = o[d]
                          , v = g[p];
                        g[p] = g[m],
                        void 0 === v && (v = new S(u,r[d],a[d])),
                        g[m] = v
                    }
                } else
                    e[p] !== c && console.error("THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.")
            }
            this.nCachedObjects_ = i
        },
        remove: function() {
            for (var e = this._objects, t = this.nCachedObjects_, i = this._indicesByUUID, n = this._bindings, r = n.length, a = 0, o = arguments.length; a !== o; ++a) {
                var s = arguments[a]
                  , c = s.uuid
                  , h = i[c];
                if (void 0 !== h && t <= h) {
                    var l = t++;
                    for (e[i[(u = e[l]).uuid] = h] = u,
                    e[i[c] = l] = s,
                    s = 0,
                    c = r; s !== c; ++s) {
                        var u, p = (u = n[s])[h];
                        u[h] = u[l],
                        u[l] = p
                    }
                }
            }
            this.nCachedObjects_ = t
        },
        uncache: function() {
            for (var e = this._objects, t = e.length, i = this.nCachedObjects_, n = this._indicesByUUID, r = this._bindings, a = r.length, o = 0, s = arguments.length; o !== s; ++o) {
                var c = n[h = arguments[o].uuid];
                if (void 0 !== c)
                    if (delete n[h],
                    c < i) {
                        var h, l = e[h = --i], u = --t, p = e[u];
                        for (e[n[l.uuid] = c] = l,
                        e[n[p.uuid] = h] = p,
                        e.pop(),
                        l = 0,
                        p = a; l !== p; ++l) {
                            var d = r[l]
                              , f = d[u];
                            d[c] = d[h],
                            d[h] = f,
                            d.pop()
                        }
                    } else
                        for (e[n[(p = e[u = --t]).uuid] = c] = p,
                        e.pop(),
                        l = 0,
                        p = a; l !== p; ++l)
                            (d = r[l])[c] = d[u],
                            d.pop()
            }
            this.nCachedObjects_ = i
        },
        subscribe_: function(e, t) {
            var i = this._bindingsIndicesByPath
              , n = i[e]
              , r = this._bindings;
            if (void 0 !== n)
                return r[n];
            var a = this._paths
              , o = this._parsedPaths
              , s = this._objects
              , c = this.nCachedObjects_
              , h = Array(s.length)
              , n = r.length;
            for (i[e] = n,
            a.push(e),
            o.push(t),
            r.push(h),
            i = c,
            n = s.length; i !== n; ++i)
                h[i] = new S(s[i],e,t);
            return h
        },
        unsubscribe_: function(e) {
            var t, i, n, r, a, o = this._bindingsIndicesByPath, s = o[e];
            void 0 !== s && (t = this._paths,
            i = this._parsedPaths,
            a = (n = this._bindings)[r = n.length - 1],
            n[o[e[r]] = s] = a,
            n.pop(),
            i[s] = i[r],
            i.pop(),
            t[s] = t[r],
            t.pop())
        }
    }),
    Object.assign(_r.prototype, {
        play: function() {
            return this._mixer._activateAction(this),
            this
        },
        stop: function() {
            return this._mixer._deactivateAction(this),
            this.reset()
        },
        reset: function() {
            return this.paused = !1,
            this.enabled = !0,
            this.time = 0,
            this._loopCount = -1,
            this._startTime = null,
            this.stopFading().stopWarping()
        },
        isRunning: function() {
            return this.enabled && !this.paused && 0 !== this.timeScale && null === this._startTime && this._mixer._isActiveAction(this)
        },
        isScheduled: function() {
            return this._mixer._isActiveAction(this)
        },
        startAt: function(e) {
            return this._startTime = e,
            this
        },
        setLoop: function(e, t) {
            return this.loop = e,
            this.repetitions = t,
            this
        },
        setEffectiveWeight: function(e) {
            return this.weight = e,
            this._effectiveWeight = this.enabled ? e : 0,
            this.stopFading()
        },
        getEffectiveWeight: function() {
            return this._effectiveWeight
        },
        fadeIn: function(e) {
            return this._scheduleFading(e, 0, 1)
        },
        fadeOut: function(e) {
            return this._scheduleFading(e, 1, 0)
        },
        crossFadeFrom: function(e, t, i) {
            var n, r;
            return e.fadeOut(t),
            this.fadeIn(t),
            i && (r = (i = this._clip.duration) / (n = e._clip.duration),
            e.warp(1, n / i, t),
            this.warp(r, 1, t)),
            this
        },
        crossFadeTo: function(e, t, i) {
            return e.crossFadeFrom(this, t, i)
        },
        stopFading: function() {
            var e = this._weightInterpolant;
            return null !== e && (this._weightInterpolant = null,
            this._mixer._takeBackControlInterpolant(e)),
            this
        },
        setEffectiveTimeScale: function(e) {
            return this.timeScale = e,
            this._effectiveTimeScale = this.paused ? 0 : e,
            this.stopWarping()
        },
        getEffectiveTimeScale: function() {
            return this._effectiveTimeScale
        },
        setDuration: function(e) {
            return this.timeScale = this._clip.duration / e,
            this.stopWarping()
        },
        syncWith: function(e) {
            return this.time = e.time,
            this.timeScale = e.timeScale,
            this.stopWarping()
        },
        halt: function(e) {
            return this.warp(this._effectiveTimeScale, 0, e)
        },
        warp: function(e, t, i) {
            var n = this._mixer
              , r = n.time
              , a = this._timeScaleInterpolant
              , o = this.timeScale;
            return null === a && (this._timeScaleInterpolant = a = n._lendControlInterpolant()),
            n = a.parameterPositions,
            a = a.sampleValues,
            n[0] = r,
            n[1] = r + i,
            a[0] = e / o,
            a[1] = t / o,
            this
        },
        stopWarping: function() {
            var e = this._timeScaleInterpolant;
            return null !== e && (this._timeScaleInterpolant = null,
            this._mixer._takeBackControlInterpolant(e)),
            this
        },
        getMixer: function() {
            return this._mixer
        },
        getClip: function() {
            return this._clip
        },
        getRoot: function() {
            return this._localRoot || this._mixer._root
        },
        _update: function(e, t, i, n) {
            if (this.enabled) {
                if (null !== (r = this._startTime)) {
                    if ((t = (e - r) * i) < 0 || 0 === i)
                        return;
                    this._startTime = null,
                    t *= i
                }
                if (t *= this._updateTimeScale(e),
                i = this._updateTime(t),
                0 < (e = this._updateWeight(e))) {
                    t = this._interpolants;
                    for (var r = this._propertyBindings, a = 0, o = t.length; a !== o; ++a)
                        t[a].evaluate(i),
                        r[a].accumulate(n, e)
                }
            } else
                this._updateWeight(e)
        },
        _updateWeight: function(e) {
            var t, i, n = 0;
            return this.enabled && (n = this.weight,
            null !== (t = this._weightInterpolant)) && (n *= i = t.evaluate(e)[0],
            e > t.parameterPositions[1]) && (this.stopFading(),
            0 === i) && (this.enabled = !1),
            this._effectiveWeight = n
        },
        _updateTimeScale: function(e) {
            var t, i = 0;
            return this.paused || (i = this.timeScale,
            null !== (t = this._timeScaleInterpolant) && (i *= t.evaluate(e)[0],
            e > t.parameterPositions[1]) && (this.stopWarping(),
            0 === i ? this.paused = !0 : this.timeScale = i)),
            this._effectiveTimeScale = i
        },
        _updateTime: function(e) {
            var t, i = this.time + e, n = this._clip.duration, r = this.loop, a = this._loopCount, o = 2202 === r;
            if (0 === e)
                return -1 !== a && o && 1 == (1 & a) ? n - i : i;
            if (2200 === r)
                e: {
                    if (-1 === a && (this._loopCount = 0,
                    this._setEndings(!0, !0, !1)),
                    n <= i)
                        i = n;
                    else {
                        if (!(i < 0))
                            break e;
                        i = 0
                    }
                    this.clampWhenFinished ? this.paused = !0 : this.enabled = !1,
                    this._mixer.dispatchEvent({
                        type: "finished",
                        action: this,
                        direction: e < 0 ? -1 : 1
                    })
                }
            else if (-1 === a && (0 <= e ? this._setEndings(!(a = 0), 0 === this.repetitions, o) : this._setEndings(0 === this.repetitions, !0, o)),
            (n <= i || i < 0) && (i -= n * (r = Math.floor(i / n)),
            a += Math.abs(r),
            (t = this.repetitions - a) <= 0 ? (this.clampWhenFinished ? this.paused = !0 : this.enabled = !1,
            i = 0 < e ? n : 0,
            this._mixer.dispatchEvent({
                type: "finished",
                action: this,
                direction: 0 < e ? 1 : -1
            })) : (1 == t ? this._setEndings(e = e < 0, !e, o) : this._setEndings(!1, !1, o),
            this._loopCount = a,
            this._mixer.dispatchEvent({
                type: "loop",
                action: this,
                loopDelta: r
            }))),
            o && 1 == (1 & a))
                return n - (this.time = i);
            return this.time = i
        },
        _setEndings: function(e, t, i) {
            var n = this._interpolantSettings;
            i ? (n.endingStart = 2401,
            n.endingEnd = 2401) : (n.endingStart = e ? this.zeroSlopeAtStart ? 2401 : 2400 : 2402,
            n.endingEnd = t ? this.zeroSlopeAtEnd ? 2401 : 2400 : 2402)
        },
        _scheduleFading: function(e, t, i) {
            var n = this._mixer
              , r = n.time
              , a = this._weightInterpolant;
            return null === a && (this._weightInterpolant = a = n._lendControlInterpolant()),
            n = a.parameterPositions,
            a = a.sampleValues,
            n[0] = r,
            a[0] = t,
            n[1] = r + e,
            a[1] = i,
            this
        }
    }),
    Mr.prototype = Object.assign(Object.create(L.prototype), {
        constructor: Mr,
        _bindAction: function(e, t) {
            var i = e._localRoot || this._root
              , n = e._clip.tracks
              , r = n.length
              , a = e._propertyBindings
              , o = (e = e._interpolants,
            i.uuid)
              , s = this._bindingsByRootAndName
              , c = s[o];
            for (void 0 === c && (s[o] = c = {}),
            s = 0; s !== r; ++s) {
                var h = n[s]
                  , l = h.name
                  , u = c[l];
                if (void 0 === u) {
                    if (void 0 !== (u = a[s])) {
                        null === u._cacheIndex && (++u.referenceCount,
                        this._addInactiveBinding(u, o, l));
                        continue
                    }
                    ++(u = new xr(S.create(i, l, t && t._propertyBindings[s].binding.parsedPath),h.ValueTypeName,h.getValueSize())).referenceCount,
                    this._addInactiveBinding(u, o, l)
                }
                a[s] = u,
                e[s].resultBuffer = u.buffer
            }
        },
        _activateAction: function(e) {
            if (!this._isActiveAction(e)) {
                var t, i, n;
                for (null === e._cacheIndex && (t = (e._localRoot || this._root).uuid,
                i = e._clip.uuid,
                n = this._actionsByClip[i],
                this._bindAction(e, n && n.knownActions[0]),
                this._addInactiveAction(e, i, t)),
                i = 0,
                n = (t = e._propertyBindings).length; i !== n; ++i) {
                    var r = t[i];
                    0 == r.useCount++ && (this._lendBinding(r),
                    r.saveOriginalState())
                }
                this._lendAction(e)
            }
        },
        _deactivateAction: function(e) {
            if (this._isActiveAction(e)) {
                for (var t = e._propertyBindings, i = 0, n = t.length; i !== n; ++i) {
                    var r = t[i];
                    0 == --r.useCount && (r.restoreOriginalState(),
                    this._takeBackBinding(r))
                }
                this._takeBackAction(e)
            }
        },
        _initMemoryManager: function() {
            this._actions = [],
            this._nActiveActions = 0,
            this._actionsByClip = {},
            this._bindings = [],
            this._nActiveBindings = 0,
            this._bindingsByRootAndName = {},
            this._controlInterpolants = [],
            this._nActiveControlInterpolants = 0;
            var e = this;
            this.stats = {
                actions: {
                    get total() {
                        return e._actions.length
                    },
                    get inUse() {
                        return e._nActiveActions
                    }
                },
                bindings: {
                    get total() {
                        return e._bindings.length
                    },
                    get inUse() {
                        return e._nActiveBindings
                    }
                },
                controlInterpolants: {
                    get total() {
                        return e._controlInterpolants.length
                    },
                    get inUse() {
                        return e._nActiveControlInterpolants
                    }
                }
            }
        },
        _isActiveAction: function(e) {
            return null !== (e = e._cacheIndex) && e < this._nActiveActions
        },
        _addInactiveAction: function(e, t, i) {
            var n = this._actions
              , r = this._actionsByClip
              , a = r[t];
            void 0 === a ? (a = {
                knownActions: [e],
                actionByRoot: {}
            },
            e._byClipCacheIndex = 0,
            r[t] = a) : (t = a.knownActions,
            e._byClipCacheIndex = t.length,
            t.push(e)),
            e._cacheIndex = n.length,
            n.push(e),
            a.actionByRoot[i] = e
        },
        _removeInactiveAction: function(e) {
            var t = this._actions
              , i = t[t.length - 1]
              , n = e._cacheIndex
              , r = (t[i._cacheIndex = n] = i,
            t.pop(),
            e._cacheIndex = null,
            t = e._clip.uuid,
            (n = (i = this._actionsByClip)[t]).knownActions)
              , a = r[r.length - 1]
              , o = e._byClipCacheIndex;
            r[a._byClipCacheIndex = o] = a,
            r.pop(),
            e._byClipCacheIndex = null,
            delete n.actionByRoot[(e._localRoot || this._root).uuid],
            0 === r.length && delete i[t],
            this._removeInactiveBindingsForAction(e)
        },
        _removeInactiveBindingsForAction: function(e) {
            for (var t = 0, i = (e = e._propertyBindings).length; t !== i; ++t) {
                var n = e[t];
                0 == --n.referenceCount && this._removeInactiveBinding(n)
            }
        },
        _lendAction: function(e) {
            var t = this._actions
              , i = e._cacheIndex
              , n = this._nActiveActions++
              , r = t[n];
            t[e._cacheIndex = n] = e,
            t[r._cacheIndex = i] = r
        },
        _takeBackAction: function(e) {
            var t = this._actions
              , i = e._cacheIndex
              , n = --this._nActiveActions
              , r = t[n];
            t[e._cacheIndex = n] = e,
            t[r._cacheIndex = i] = r
        },
        _addInactiveBinding: function(e, t, i) {
            var n = this._bindingsByRootAndName
              , r = n[t]
              , a = this._bindings;
            void 0 === r && (n[t] = r = {}),
            (r[i] = e)._cacheIndex = a.length,
            a.push(e)
        },
        _removeInactiveBinding: function(e) {
            var t = this._bindings
              , i = (n = e.binding).rootNode.uuid
              , n = n.path
              , r = this._bindingsByRootAndName
              , a = r[i]
              , o = t[t.length - 1];
            e = e._cacheIndex,
            t[o._cacheIndex = e] = o,
            t.pop(),
            delete a[n];
            e: {
                for (var s in a)
                    break e;
                delete r[i]
            }
        },
        _lendBinding: function(e) {
            var t = this._bindings
              , i = e._cacheIndex
              , n = this._nActiveBindings++
              , r = t[n];
            t[e._cacheIndex = n] = e,
            t[r._cacheIndex = i] = r
        },
        _takeBackBinding: function(e) {
            var t = this._bindings
              , i = e._cacheIndex
              , n = --this._nActiveBindings
              , r = t[n];
            t[e._cacheIndex = n] = e,
            t[r._cacheIndex = i] = r
        },
        _lendControlInterpolant: function() {
            var e = this._controlInterpolants
              , t = this._nActiveControlInterpolants++
              , i = e[t];
            return void 0 === i && (e[(i = new pn(new Float32Array(2),new Float32Array(2),1,this._controlInterpolantsResultBuffer)).__cacheIndex = t] = i),
            i
        },
        _takeBackControlInterpolant: function(e) {
            var t = this._controlInterpolants
              , i = e.__cacheIndex
              , n = --this._nActiveControlInterpolants
              , r = t[n];
            t[e.__cacheIndex = n] = e,
            t[r.__cacheIndex = i] = r
        },
        _controlInterpolantsResultBuffer: new Float32Array(1),
        clipAction: function(e, t) {
            var i = t || this._root
              , n = i.uuid
              , r = (e = null !== (i = "string" == typeof e ? wn.findByName(i, e) : e) ? i.uuid : e,
            this._actionsByClip[e])
              , a = null;
            if (void 0 !== r) {
                if (void 0 !== (a = r.actionByRoot[n]))
                    return a;
                a = r.knownActions[0],
                null === i && (i = a._clip)
            }
            return null === i ? null : (t = new _r(this,i,t),
            this._bindAction(t, a),
            this._addInactiveAction(t, e, n),
            t)
        },
        existingAction: function(e, t) {
            var i = t || this._root;
            return t = i.uuid,
            i = "string" == typeof e ? wn.findByName(i, e) : e,
            void 0 !== (e = this._actionsByClip[i ? i.uuid : e]) && e.actionByRoot[t] || null
        },
        stopAllAction: function() {
            for (var e = this._actions, t = this._nActiveActions, i = this._bindings, n = this._nActiveBindings, r = this._nActiveBindings = this._nActiveActions = 0; r !== t; ++r)
                e[r].reset();
            for (r = 0; r !== n; ++r)
                i[r].useCount = 0;
            return this
        },
        update: function(e) {
            e *= this.timeScale;
            for (var t = this._actions, i = this._nActiveActions, n = this.time += e, r = Math.sign(e), a = this._accuIndex ^= 1, o = 0; o !== i; ++o)
                t[o]._update(n, e, r, a);
            for (e = this._bindings,
            t = this._nActiveBindings,
            o = 0; o !== t; ++o)
                e[o].apply(a);
            return this
        },
        getRoot: function() {
            return this._root
        },
        uncacheClip: function(e) {
            var t = this._actions
              , i = (e = e.uuid,
            this._actionsByClip);
            if (void 0 !== (n = i[e])) {
                for (var n, r = 0, a = (n = n.knownActions).length; r !== a; ++r) {
                    var o = n[r]
                      , s = (this._deactivateAction(o),
                    o._cacheIndex)
                      , c = t[t.length - 1];
                    o._cacheIndex = null,
                    o._byClipCacheIndex = null,
                    t[c._cacheIndex = s] = c,
                    t.pop(),
                    this._removeInactiveBindingsForAction(o)
                }
                delete i[e]
            }
        },
        uncacheRoot: function(e) {
            e = e.uuid;
            var t = this._actionsByClip;
            for (n in t) {
                var i = t[n].actionByRoot[e];
                void 0 !== i && (this._deactivateAction(i),
                this._removeInactiveAction(i))
            }
            var n = this._bindingsByRootAndName[e];
            if (void 0 !== n)
                for (var r in n)
                    e = n[r],
                    e.restoreOriginalState(),
                    this._removeInactiveBinding(e)
        },
        uncacheAction: function(e, t) {
            null !== (e = this.existingAction(e, t)) && (this._deactivateAction(e),
            this._removeInactiveAction(e))
        }
    }),
    Er.prototype.clone = function() {
        return new Er(void 0 === this.value.clone ? this.value : this.value.clone())
    }
    ,
    Sr.prototype = Object.assign(Object.create(U.prototype), {
        constructor: Sr,
        isInstancedBufferGeometry: !0,
        copy: function(e) {
            return U.prototype.copy.call(this, e),
            this.maxInstancedCount = e.maxInstancedCount,
            this
        },
        clone: function() {
            return (new this.constructor).copy(this)
        }
    }),
    Tr.prototype = Object.assign(Object.create(Ut.prototype), {
        constructor: Tr,
        isInstancedInterleavedBuffer: !0,
        copy: function(e) {
            return Ut.prototype.copy.call(this, e),
            this.meshPerAttribute = e.meshPerAttribute,
            this
        }
    }),
    Ar.prototype = Object.assign(Object.create(m.prototype), {
        constructor: Ar,
        isInstancedBufferAttribute: !0,
        copy: function(e) {
            return m.prototype.copy.call(this, e),
            this.meshPerAttribute = e.meshPerAttribute,
            this
        }
    }),
    Object.assign(Lr.prototype, {
        linePrecision: 1,
        set: function(e, t) {
            this.ray.set(e, t)
        },
        setFromCamera: function(e, t) {
            t && t.isPerspectiveCamera ? (this.ray.origin.setFromMatrixPosition(t.matrixWorld),
            this.ray.direction.set(e.x, e.y, .5).unproject(t).sub(this.ray.origin).normalize()) : t && t.isOrthographicCamera ? (this.ray.origin.set(e.x, e.y, (t.near + t.far) / (t.near - t.far)).unproject(t),
            this.ray.direction.set(0, 0, -1).transformDirection(t.matrixWorld)) : console.error("THREE.Raycaster: Unsupported camera type.")
        },
        intersectObject: function(e, t, i) {
            return Rr(e, this, i = i || [], t),
            i.sort(Pr),
            i
        },
        intersectObjects: function(e, t, i) {
            if (i = i || [],
            !1 === Array.isArray(e))
                console.warn("THREE.Raycaster.intersectObjects: objects is not an Array.");
            else {
                for (var n = 0, r = e.length; n < r; n++)
                    Rr(e[n], this, i, t);
                i.sort(Pr)
            }
            return i
        }
    }),
    Object.assign(Cr.prototype, {
        set: function(e, t, i) {
            return this.radius = e,
            this.phi = t,
            this.theta = i,
            this
        },
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(e) {
            return this.radius = e.radius,
            this.phi = e.phi,
            this.theta = e.theta,
            this
        },
        makeSafe: function() {
            return this.phi = Math.max(1e-6, Math.min(Math.PI - 1e-6, this.phi)),
            this
        },
        setFromVector3: function(e) {
            return this.setFromCartesianCoords(e.x, e.y, e.z)
        },
        setFromCartesianCoords: function(e, t, i) {
            return this.radius = Math.sqrt(e * e + t * t + i * i),
            0 === this.radius ? this.phi = this.theta = 0 : (this.theta = Math.atan2(e, i),
            this.phi = Math.acos(Se.clamp(t / this.radius, -1, 1))),
            this
        }
    }),
    Object.assign(Or.prototype, {
        set: function(e, t, i) {
            return this.radius = e,
            this.theta = t,
            this.y = i,
            this
        },
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(e) {
            return this.radius = e.radius,
            this.theta = e.theta,
            this.y = e.y,
            this
        },
        setFromVector3: function(e) {
            return this.setFromCartesianCoords(e.x, e.y, e.z)
        },
        setFromCartesianCoords: function(e, t, i) {
            return this.radius = Math.sqrt(e * e + i * i),
            this.theta = Math.atan2(e, i),
            this.y = t,
            this
        }
    }),
    Object.assign(Ir.prototype, {
        set: function(e, t) {
            return this.min.copy(e),
            this.max.copy(t),
            this
        },
        setFromPoints: function(e) {
            this.makeEmpty();
            for (var t = 0, i = e.length; t < i; t++)
                this.expandByPoint(e[t]);
            return this
        },
        setFromCenterAndSize: (Eh = new Y,
        function(e, t) {
            return t = Eh.copy(t).multiplyScalar(.5),
            this.min.copy(e).sub(t),
            this.max.copy(e).add(t),
            this
        }
        ),
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(e) {
            return this.min.copy(e.min),
            this.max.copy(e.max),
            this
        },
        makeEmpty: function() {
            return this.min.x = this.min.y = 1 / 0,
            this.max.x = this.max.y = -1 / 0,
            this
        },
        isEmpty: function() {
            return this.max.x < this.min.x || this.max.y < this.min.y
        },
        getCenter: function(e) {
            return void 0 === e && (console.warn("THREE.Box2: .getCenter() target is now required"),
            e = new Y),
            this.isEmpty() ? e.set(0, 0) : e.addVectors(this.min, this.max).multiplyScalar(.5)
        },
        getSize: function(e) {
            return void 0 === e && (console.warn("THREE.Box2: .getSize() target is now required"),
            e = new Y),
            this.isEmpty() ? e.set(0, 0) : e.subVectors(this.max, this.min)
        },
        expandByPoint: function(e) {
            return this.min.min(e),
            this.max.max(e),
            this
        },
        expandByVector: function(e) {
            return this.min.sub(e),
            this.max.add(e),
            this
        },
        expandByScalar: function(e) {
            return this.min.addScalar(-e),
            this.max.addScalar(e),
            this
        },
        containsPoint: function(e) {
            return !(e.x < this.min.x || e.x > this.max.x || e.y < this.min.y || e.y > this.max.y)
        },
        containsBox: function(e) {
            return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y
        },
        getParameter: function(e, t) {
            return void 0 === t && (console.warn("THREE.Box2: .getParameter() target is now required"),
            t = new Y),
            t.set((e.x - this.min.x) / (this.max.x - this.min.x), (e.y - this.min.y) / (this.max.y - this.min.y))
        },
        intersectsBox: function(e) {
            return !(e.max.x < this.min.x || e.min.x > this.max.x || e.max.y < this.min.y || e.min.y > this.max.y)
        },
        clampPoint: function(e, t) {
            return void 0 === t && (console.warn("THREE.Box2: .clampPoint() target is now required"),
            t = new Y),
            t.copy(e).clamp(this.min, this.max)
        },
        distanceToPoint: (Mh = new Y,
        function(e) {
            return Mh.copy(e).clamp(this.min, this.max).sub(e).length()
        }
        ),
        intersect: function(e) {
            return this.min.max(e.min),
            this.max.min(e.max),
            this
        },
        union: function(e) {
            return this.min.min(e.min),
            this.max.max(e.max),
            this
        },
        translate: function(e) {
            return this.min.add(e),
            this.max.add(e),
            this
        },
        equals: function(e) {
            return e.min.equals(this.min) && e.max.equals(this.max)
        }
    }),
    Object.assign(Dr.prototype, {
        set: function(e, t) {
            return this.start.copy(e),
            this.end.copy(t),
            this
        },
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(e) {
            return this.start.copy(e.start),
            this.end.copy(e.end),
            this
        },
        getCenter: function(e) {
            return void 0 === e && (console.warn("THREE.Line3: .getCenter() target is now required"),
            e = new Me),
            e.addVectors(this.start, this.end).multiplyScalar(.5)
        },
        delta: function(e) {
            return void 0 === e && (console.warn("THREE.Line3: .delta() target is now required"),
            e = new Me),
            e.subVectors(this.end, this.start)
        },
        distanceSq: function() {
            return this.start.distanceToSquared(this.end)
        },
        distance: function() {
            return this.start.distanceTo(this.end)
        },
        at: function(e, t) {
            return void 0 === t && (console.warn("THREE.Line3: .at() target is now required"),
            t = new Me),
            this.delta(t).multiplyScalar(e).add(this.start)
        },
        closestPointToPointParameter: (Sh = new Me,
        Th = new Me,
        function(e, t) {
            return Sh.subVectors(e, this.start),
            Th.subVectors(this.end, this.start),
            e = Th.dot(Th),
            e = Th.dot(Sh) / e,
            e = t ? Se.clamp(e, 0, 1) : e
        }
        ),
        closestPointToPoint: function(e, t, i) {
            return e = this.closestPointToPointParameter(e, t),
            void 0 === i && (console.warn("THREE.Line3: .closestPointToPoint() target is now required"),
            i = new Me),
            this.delta(i).multiplyScalar(e).add(this.start)
        },
        applyMatrix4: function(e) {
            return this.start.applyMatrix4(e),
            this.end.applyMatrix4(e),
            this
        },
        equals: function(e) {
            return e.start.equals(this.start) && e.end.equals(this.end)
        }
    }),
    ((Br.prototype = Object.create(u.prototype)).constructor = Br).prototype.isImmediateRenderObject = !0,
    ((Nr.prototype = Object.create(x.prototype)).constructor = Nr).prototype.update = (Ah = new Me,
    Lh = new Me,
    Ph = new g,
    function() {
        var e = ["a", "b", "c"]
          , t = (this.object.updateMatrixWorld(!0),
        Ph.getNormalMatrix(this.object.matrixWorld),
        this.object.matrixWorld)
          , i = this.geometry.attributes.position
          , n = this.object.geometry;
        if (n && n.isGeometry)
            for (var r = n.vertices, a = n.faces, o = n = 0, s = a.length; o < s; o++)
                for (var c = a[o], h = 0, l = c.vertexNormals.length; h < l; h++) {
                    var u = c.vertexNormals[h];
                    Ah.copy(r[c[e[h]]]).applyMatrix4(t),
                    Lh.copy(u).applyMatrix3(Ph).normalize().multiplyScalar(this.size).add(Ah),
                    i.setXYZ(n, Ah.x, Ah.y, Ah.z),
                    n += 1,
                    i.setXYZ(n, Lh.x, Lh.y, Lh.z),
                    n += 1
                }
        else if (n && n.isBufferGeometry)
            for (e = n.attributes.position,
            r = n.attributes.normal,
            h = n = 0,
            l = e.count; h < l; h++)
                Ah.set(e.getX(h), e.getY(h), e.getZ(h)).applyMatrix4(t),
                Lh.set(r.getX(h), r.getY(h), r.getZ(h)),
                Lh.applyMatrix3(Ph).normalize().multiplyScalar(this.size).add(Ah),
                i.setXYZ(n, Ah.x, Ah.y, Ah.z),
                i.setXYZ(n += 1, Lh.x, Lh.y, Lh.z),
                n += 1;
        i.needsUpdate = !0
    }
    ),
    ((zr.prototype = Object.create(u.prototype)).constructor = zr).prototype.dispose = function() {
        this.cone.geometry.dispose(),
        this.cone.material.dispose()
    }
    ,
    zr.prototype.update = (Rh = new Me,
    function() {
        this.light.updateMatrixWorld();
        var e = this.light.distance || 1e3
          , t = e * Math.tan(this.light.angle);
        this.cone.scale.set(t, t, e),
        Rh.setFromMatrixPosition(this.light.target.matrixWorld),
        this.cone.lookAt(Rh),
        void 0 !== this.color ? this.cone.material.color.set(this.color) : this.cone.material.color.copy(this.light.color)
    }
    ),
    ((Ur.prototype = Object.create(x.prototype)).constructor = Ur).prototype.updateMatrixWorld = (Ch = new Me,
    Oh = new _e,
    Ih = new _e,
    function(e) {
        var t = this.bones
          , i = this.geometry
          , n = i.getAttribute("position");
        Ih.getInverse(this.root.matrixWorld);
        for (var r = 0, a = 0; r < t.length; r++) {
            var o = t[r];
            o.parent && o.parent.isBone && (Oh.multiplyMatrices(Ih, o.matrixWorld),
            Ch.setFromMatrixPosition(Oh),
            n.setXYZ(a, Ch.x, Ch.y, Ch.z),
            Oh.multiplyMatrices(Ih, o.parent.matrixWorld),
            Ch.setFromMatrixPosition(Oh),
            n.setXYZ(a + 1, Ch.x, Ch.y, Ch.z),
            a += 2)
        }
        i.getAttribute("position").needsUpdate = !0,
        u.prototype.updateMatrixWorld.call(this, e)
    }
    ),
    ((Gr.prototype = Object.create(v.prototype)).constructor = Gr).prototype.dispose = function() {
        this.geometry.dispose(),
        this.material.dispose()
    }
    ,
    Gr.prototype.update = function() {
        void 0 !== this.color ? this.material.color.set(this.color) : this.material.color.copy(this.light.color)
    }
    ,
    ((Fr.prototype = Object.create(h.prototype)).constructor = Fr).prototype.update = function() {
        var e, t;
        this.scale.set(.5 * this.light.width, .5 * this.light.height, 1),
        void 0 !== this.color ? (this.material.color.set(this.color),
        this.children[0].material.color.set(this.color)) : (this.material.color.copy(this.light.color).multiplyScalar(this.light.intensity),
        e = this.material.color,
        1 < (t = Math.max(e.r, e.g, e.b)) && e.multiplyScalar(1 / t),
        this.children[0].material.color.copy(this.material.color))
    }
    ,
    Fr.prototype.dispose = function() {
        this.geometry.dispose(),
        this.material.dispose(),
        this.children[0].geometry.dispose(),
        this.children[0].material.dispose()
    }
    ,
    ((Hr.prototype = Object.create(u.prototype)).constructor = Hr).prototype.dispose = function() {
        this.children[0].geometry.dispose(),
        this.children[0].material.dispose()
    }
    ,
    Hr.prototype.update = (Dh = new Me,
    Bh = new d,
    Nh = new d,
    function() {
        var e = this.children[0];
        if (void 0 !== this.color)
            this.material.color.set(this.color);
        else {
            var t = e.geometry.getAttribute("color");
            Bh.copy(this.light.color),
            Nh.copy(this.light.groundColor);
            for (var i = 0, n = t.count; i < n; i++) {
                var r = i < n / 2 ? Bh : Nh;
                t.setXYZ(i, r.r, r.g, r.b)
            }
            t.needsUpdate = !0
        }
        e.lookAt(Dh.setFromMatrixPosition(this.light.matrixWorld).negate())
    }
    ),
    (kr.prototype = Object.create(x.prototype)).constructor = kr,
    (Vr.prototype = Object.create(x.prototype)).constructor = Vr,
    ((jr.prototype = Object.create(x.prototype)).constructor = jr).prototype.update = (zh = new Me,
    Uh = new Me,
    Gh = new g,
    function() {
        this.object.updateMatrixWorld(!0),
        Gh.getNormalMatrix(this.object.matrixWorld);
        for (var e = this.object.matrixWorld, t = this.geometry.attributes.position, i = this.object.geometry, n = i.vertices, r = 0, a = 0, o = (i = i.faces).length; a < o; a++) {
            var s = i[a]
              , c = s.normal;
            zh.copy(n[s.a]).add(n[s.b]).add(n[s.c]).divideScalar(3).applyMatrix4(e),
            Uh.copy(c).applyMatrix3(Gh).normalize().multiplyScalar(this.size).add(zh),
            t.setXYZ(r, zh.x, zh.y, zh.z),
            r += 1,
            t.setXYZ(r, Uh.x, Uh.y, Uh.z),
            r += 1
        }
        t.needsUpdate = !0
    }
    ),
    ((Wr.prototype = Object.create(u.prototype)).constructor = Wr).prototype.dispose = function() {
        this.lightPlane.geometry.dispose(),
        this.lightPlane.material.dispose(),
        this.targetLine.geometry.dispose(),
        this.targetLine.material.dispose()
    }
    ,
    Wr.prototype.update = (Fh = new Me,
    Hh = new Me,
    kh = new Me,
    function() {
        Fh.setFromMatrixPosition(this.light.matrixWorld),
        Hh.setFromMatrixPosition(this.light.target.matrixWorld),
        kh.subVectors(Hh, Fh),
        this.lightPlane.lookAt(Hh),
        void 0 !== this.color ? (this.lightPlane.material.color.set(this.color),
        this.targetLine.material.color.set(this.color)) : (this.lightPlane.material.color.copy(this.light.color),
        this.targetLine.material.color.copy(this.light.color)),
        this.targetLine.lookAt(Hh),
        this.targetLine.scale.z = kh.length()
    }
    ),
    ((qr.prototype = Object.create(x.prototype)).constructor = qr).prototype.update = (Wh = new Me,
    qh = new Pt,
    function() {
        Vh = this.geometry,
        jh = this.pointMap,
        qh.projectionMatrix.copy(this.camera.projectionMatrix),
        n("c", 0, 0, -1),
        n("t", 0, 0, 1),
        n("n1", -1, -1, -1),
        n("n2", 1, -1, -1),
        n("n3", -1, 1, -1),
        n("n4", 1, 1, -1),
        n("f1", -1, -1, 1),
        n("f2", 1, -1, 1),
        n("f3", -1, 1, 1),
        n("f4", 1, 1, 1),
        n("u1", .7, 1.1, -1),
        n("u2", -.7, 1.1, -1),
        n("u3", 0, 2, -1),
        n("cf1", -1, 0, 1),
        n("cf2", 1, 0, 1),
        n("cf3", 0, -1, 1),
        n("cf4", 0, 1, 1),
        n("cn1", -1, 0, -1),
        n("cn2", 1, 0, -1),
        n("cn3", 0, -1, -1),
        n("cn4", 0, 1, -1),
        Vh.getAttribute("position").needsUpdate = !0
    }
    ),
    ((Xr.prototype = Object.create(x.prototype)).constructor = Xr).prototype.update = (Xh = new O,
    function(e) {
        var t, i, n;
        void 0 !== e && console.warn("THREE.BoxHelper: .update() has no longer arguments."),
        void 0 !== this.object && Xh.setFromObject(this.object),
        Xh.isEmpty() || (e = Xh.min,
        t = Xh.max,
        (n = (i = this.geometry.attributes.position).array)[0] = t.x,
        n[1] = t.y,
        n[2] = t.z,
        n[3] = e.x,
        n[4] = t.y,
        n[5] = t.z,
        n[6] = e.x,
        n[7] = e.y,
        n[8] = t.z,
        n[9] = t.x,
        n[10] = e.y,
        n[11] = t.z,
        n[12] = t.x,
        n[13] = t.y,
        n[14] = e.z,
        n[15] = e.x,
        n[16] = t.y,
        n[17] = e.z,
        n[18] = e.x,
        n[19] = e.y,
        n[20] = e.z,
        n[21] = t.x,
        n[22] = e.y,
        n[23] = e.z,
        i.needsUpdate = !0,
        this.geometry.computeBoundingSphere())
    }
    ),
    Xr.prototype.setFromObject = function(e) {
        return this.object = e,
        this.update(),
        this
    }
    ,
    Xr.prototype.copy = function(e) {
        return x.prototype.copy.call(this, e),
        this.object = e.object,
        this
    }
    ,
    Xr.prototype.clone = function() {
        return (new this.constructor).copy(this)
    }
    ,
    ((Yr.prototype = Object.create(x.prototype)).constructor = Yr).prototype.updateMatrixWorld = function(e) {
        var t = this.box;
        t.isEmpty() || (t.getCenter(this.position),
        t.getSize(this.scale),
        this.scale.multiplyScalar(.5),
        u.prototype.updateMatrixWorld.call(this, e))
    }
    ,
    ((Jr.prototype = Object.create(h.prototype)).constructor = Jr).prototype.updateMatrixWorld = function(e) {
        var t = -this.plane.constant;
        Math.abs(t) < 1e-8 && (t = 1e-8),
        this.scale.set(.5 * this.size, .5 * this.size, t),
        this.children[0].material.side = t < 0 ? 1 : 0,
        this.lookAt(this.plane.normal),
        u.prototype.updateMatrixWorld.call(this, e)
    }
    ,
    ((Zr.prototype = Object.create(u.prototype)).constructor = Zr).prototype.setDirection = (Qh = new Me,
    function(e) {
        .99999 < e.y ? this.quaternion.set(0, 0, 0, 1) : e.y < -.99999 ? this.quaternion.set(1, 0, 0, 0) : (Qh.set(e.z, 0, -e.x).normalize(),
        Zh = Math.acos(e.y),
        this.quaternion.setFromAxisAngle(Qh, Zh))
    }
    ),
    Zr.prototype.setLength = function(e, t, i) {
        void 0 === t && (t = .2 * e),
        void 0 === i && (i = .2 * t),
        this.line.scale.set(1, Math.max(0, e - t), 1),
        this.line.updateMatrix(),
        this.cone.scale.set(i, t, i),
        this.cone.position.y = e,
        this.cone.updateMatrix()
    }
    ,
    Zr.prototype.setColor = function(e) {
        this.line.material.color.copy(e),
        this.cone.material.color.copy(e)
    }
    ,
    Zr.prototype.copy = function(e) {
        return u.prototype.copy.call(this, e, !1),
        this.line.copy(e.line),
        this.cone.copy(e.cone),
        this
    }
    ,
    Zr.prototype.clone = function() {
        return (new this.constructor).copy(this)
    }
    ,
    (Qr.prototype = Object.create(x.prototype)).constructor = Qr,
    l.create = function(e, t) {
        return console.log("THREE.Curve.create() has been deprecated"),
        e.prototype = Object.create(l.prototype),
        (e.prototype.constructor = e).prototype.getPoint = t,
        e
    }
    ,
    Object.assign(jn.prototype, {
        createPointsGeometry: function(e) {
            return console.warn("THREE.CurvePath: .createPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead."),
            e = this.getPoints(e),
            this.createGeometry(e)
        },
        createSpacedPointsGeometry: function(e) {
            return console.warn("THREE.CurvePath: .createSpacedPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead."),
            e = this.getSpacedPoints(e),
            this.createGeometry(e)
        },
        createGeometry: function(e) {
            console.warn("THREE.CurvePath: .createGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.");
            for (var t = new f, i = 0, n = e.length; i < n; i++) {
                var r = e[i];
                t.vertices.push(new Me(r.x,r.y,r.z || 0))
            }
            return t
        }
    }),
    Object.assign(Wn.prototype, {
        fromPoints: function(e) {
            console.warn("THREE.Path: .fromPoints() has been renamed to .setFromPoints()."),
            this.setFromPoints(e)
        }
    }),
    Kr.prototype = Object.create(i.prototype),
    $r.prototype = Object.create(i.prototype),
    ea.prototype = Object.create(i.prototype),
    Object.assign(ea.prototype, {
        initFromArray: function() {
            console.error("THREE.Spline: .initFromArray() has been removed.")
        },
        getControlPointsArray: function() {
            console.error("THREE.Spline: .getControlPointsArray() has been removed.")
        },
        reparametrizeByArcLength: function() {
            console.error("THREE.Spline: .reparametrizeByArcLength() has been removed.")
        }
    }),
    kr.prototype.setColors = function() {
        console.error("THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.")
    }
    ,
    Ur.prototype.update = function() {
        console.error("THREE.SkeletonHelper: update() no longer needs to be called.")
    }
    ,
    Object.assign(lr.prototype, {
        extractUrlBase: function(e) {
            return console.warn("THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead."),
            Wc.extractUrlBase(e)
        }
    }),
    Object.assign(ar.prototype, {
        setTexturePath: function(e) {
            return console.warn("THREE.ObjectLoader: .setTexturePath() has been renamed to .setResourcePath()."),
            this.setResourcePath(e)
        }
    }),
    Object.assign(Ir.prototype, {
        center: function(e) {
            return console.warn("THREE.Box2: .center() has been renamed to .getCenter()."),
            this.getCenter(e)
        },
        empty: function() {
            return console.warn("THREE.Box2: .empty() has been renamed to .isEmpty()."),
            this.isEmpty()
        },
        isIntersectionBox: function(e) {
            return console.warn("THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox()."),
            this.intersectsBox(e)
        },
        size: function(e) {
            return console.warn("THREE.Box2: .size() has been renamed to .getSize()."),
            this.getSize(e)
        }
    }),
    Object.assign(O.prototype, {
        center: function(e) {
            return console.warn("THREE.Box3: .center() has been renamed to .getCenter()."),
            this.getCenter(e)
        },
        empty: function() {
            return console.warn("THREE.Box3: .empty() has been renamed to .isEmpty()."),
            this.isEmpty()
        },
        isIntersectionBox: function(e) {
            return console.warn("THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox()."),
            this.intersectsBox(e)
        },
        isIntersectionSphere: function(e) {
            return console.warn("THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere()."),
            this.intersectsSphere(e)
        },
        size: function(e) {
            return console.warn("THREE.Box3: .size() has been renamed to .getSize()."),
            this.getSize(e)
        }
    }),
    Dr.prototype.center = function(e) {
        return console.warn("THREE.Line3: .center() has been renamed to .getCenter()."),
        this.getCenter(e)
    }
    ,
    Object.assign(Se, {
        random16: function() {
            return console.warn("THREE.Math: .random16() has been deprecated. Use Math.random() instead."),
            Math.random()
        },
        nearestPowerOfTwo: function(e) {
            return console.warn("THREE.Math: .nearestPowerOfTwo() has been renamed to .floorPowerOfTwo()."),
            Se.floorPowerOfTwo(e)
        },
        nextPowerOfTwo: function(e) {
            return console.warn("THREE.Math: .nextPowerOfTwo() has been renamed to .ceilPowerOfTwo()."),
            Se.ceilPowerOfTwo(e)
        }
    }),
    Object.assign(g.prototype, {
        flattenToArrayOffset: function(e, t) {
            return console.warn("THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."),
            this.toArray(e, t)
        },
        multiplyVector3: function(e) {
            return console.warn("THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead."),
            e.applyMatrix3(this)
        },
        multiplyVector3Array: function() {
            console.error("THREE.Matrix3: .multiplyVector3Array() has been removed.")
        },
        applyToBuffer: function(e) {
            return console.warn("THREE.Matrix3: .applyToBuffer() has been removed. Use matrix.applyToBufferAttribute( attribute ) instead."),
            this.applyToBufferAttribute(e)
        },
        applyToVector3Array: function() {
            console.error("THREE.Matrix3: .applyToVector3Array() has been removed.")
        }
    }),
    Object.assign(_e.prototype, {
        extractPosition: function(e) {
            return console.warn("THREE.Matrix4: .extractPosition() has been renamed to .copyPosition()."),
            this.copyPosition(e)
        },
        flattenToArrayOffset: function(e, t) {
            return console.warn("THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."),
            this.toArray(e, t)
        },
        getPosition: function() {
            return void 0 === Kh && (Kh = new Me),
            console.warn("THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead."),
            Kh.setFromMatrixColumn(this, 3)
        },
        setRotationFromQuaternion: function(e) {
            return console.warn("THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion()."),
            this.makeRotationFromQuaternion(e)
        },
        multiplyToArray: function() {
            console.warn("THREE.Matrix4: .multiplyToArray() has been removed.")
        },
        multiplyVector3: function(e) {
            return console.warn("THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead."),
            e.applyMatrix4(this)
        },
        multiplyVector4: function(e) {
            return console.warn("THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead."),
            e.applyMatrix4(this)
        },
        multiplyVector3Array: function() {
            console.error("THREE.Matrix4: .multiplyVector3Array() has been removed.")
        },
        rotateAxis: function(e) {
            console.warn("THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead."),
            e.transformDirection(this)
        },
        crossVector: function(e) {
            return console.warn("THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead."),
            e.applyMatrix4(this)
        },
        translate: function() {
            console.error("THREE.Matrix4: .translate() has been removed.")
        },
        rotateX: function() {
            console.error("THREE.Matrix4: .rotateX() has been removed.")
        },
        rotateY: function() {
            console.error("THREE.Matrix4: .rotateY() has been removed.")
        },
        rotateZ: function() {
            console.error("THREE.Matrix4: .rotateZ() has been removed.")
        },
        rotateByAxis: function() {
            console.error("THREE.Matrix4: .rotateByAxis() has been removed.")
        },
        applyToBuffer: function(e) {
            return console.warn("THREE.Matrix4: .applyToBuffer() has been removed. Use matrix.applyToBufferAttribute( attribute ) instead."),
            this.applyToBufferAttribute(e)
        },
        applyToVector3Array: function() {
            console.error("THREE.Matrix4: .applyToVector3Array() has been removed.")
        },
        makeFrustum: function(e, t, i, n, r, a) {
            return console.warn("THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead."),
            this.makePerspective(e, t, n, i, r, a)
        }
    }),
    D.prototype.isIntersectionLine = function(e) {
        return console.warn("THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine()."),
        this.intersectsLine(e)
    }
    ,
    M.prototype.multiplyVector3 = function(e) {
        return console.warn("THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead."),
        e.applyQuaternion(this)
    }
    ,
    Object.assign(ie.prototype, {
        isIntersectionBox: function(e) {
            return console.warn("THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox()."),
            this.intersectsBox(e)
        },
        isIntersectionPlane: function(e) {
            return console.warn("THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane()."),
            this.intersectsPlane(e)
        },
        isIntersectionSphere: function(e) {
            return console.warn("THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere()."),
            this.intersectsSphere(e)
        }
    }),
    Object.assign(w.prototype, {
        area: function() {
            return console.warn("THREE.Triangle: .area() has been renamed to .getArea()."),
            this.getArea()
        },
        barycoordFromPoint: function(e, t) {
            return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."),
            this.getBarycoord(e, t)
        },
        midpoint: function(e) {
            return console.warn("THREE.Triangle: .midpoint() has been renamed to .getMidpoint()."),
            this.getMidpoint(e)
        },
        normal: function(e) {
            return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."),
            this.getNormal(e)
        },
        plane: function(e) {
            return console.warn("THREE.Triangle: .plane() has been renamed to .getPlane()."),
            this.getPlane(e)
        }
    }),
    Object.assign(w, {
        barycoordFromPoint: function(e, t, i, n, r) {
            return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."),
            w.getBarycoord(e, t, i, n, r)
        },
        normal: function(e, t, i, n) {
            return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."),
            w.getNormal(e, t, i, n)
        }
    }),
    Object.assign(qn.prototype, {
        extractAllPoints: function(e) {
            return console.warn("THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead."),
            this.extractPoints(e)
        },
        extrude: function(e) {
            return console.warn("THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead."),
            new Oi(this,e)
        },
        makeGeometry: function(e) {
            return console.warn("THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead."),
            new Vi(this,e)
        }
    }),
    Object.assign(Y.prototype, {
        fromAttribute: function(e, t, i) {
            return console.warn("THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute()."),
            this.fromBufferAttribute(e, t, i)
        },
        distanceToManhattan: function(e) {
            return console.warn("THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."),
            this.manhattanDistanceTo(e)
        },
        lengthManhattan: function() {
            return console.warn("THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength()."),
            this.manhattanLength()
        }
    }),
    Object.assign(Me.prototype, {
        setEulerFromRotationMatrix: function() {
            console.error("THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.")
        },
        setEulerFromQuaternion: function() {
            console.error("THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.")
        },
        getPositionFromMatrix: function(e) {
            return console.warn("THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition()."),
            this.setFromMatrixPosition(e)
        },
        getScaleFromMatrix: function(e) {
            return console.warn("THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale()."),
            this.setFromMatrixScale(e)
        },
        getColumnFromMatrix: function(e, t) {
            return console.warn("THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn()."),
            this.setFromMatrixColumn(t, e)
        },
        applyProjection: function(e) {
            return console.warn("THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead."),
            this.applyMatrix4(e)
        },
        fromAttribute: function(e, t, i) {
            return console.warn("THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute()."),
            this.fromBufferAttribute(e, t, i)
        },
        distanceToManhattan: function(e) {
            return console.warn("THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."),
            this.manhattanDistanceTo(e)
        },
        lengthManhattan: function() {
            return console.warn("THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength()."),
            this.manhattanLength()
        }
    }),
    Object.assign(Ee.prototype, {
        fromAttribute: function(e, t, i) {
            return console.warn("THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute()."),
            this.fromBufferAttribute(e, t, i)
        },
        lengthManhattan: function() {
            return console.warn("THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength()."),
            this.manhattanLength()
        }
    }),
    Object.assign(f.prototype, {
        computeTangents: function() {
            console.error("THREE.Geometry: .computeTangents() has been removed.")
        },
        computeLineDistances: function() {
            console.error("THREE.Geometry: .computeLineDistances() has been removed. Use THREE.Line.computeLineDistances() instead.")
        }
    }),
    Object.assign(u.prototype, {
        getChildByName: function(e) {
            return console.warn("THREE.Object3D: .getChildByName() has been renamed to .getObjectByName()."),
            this.getObjectByName(e)
        },
        renderDepth: function() {
            console.warn("THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.")
        },
        translate: function(e, t) {
            return console.warn("THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead."),
            this.translateOnAxis(t, e)
        },
        getWorldRotation: function() {
            console.error("THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead.")
        }
    }),
    Object.defineProperties(u.prototype, {
        eulerOrder: {
            get: function() {
                return console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."),
                this.rotation.order
            },
            set: function(e) {
                console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."),
                this.rotation.order = e
            }
        },
        useQuaternion: {
            get: function() {
                console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")
            },
            set: function() {
                console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")
            }
        }
    }),
    Object.defineProperties(kt.prototype, {
        objects: {
            get: function() {
                return console.warn("THREE.LOD: .objects has been renamed to .levels."),
                this.levels
            }
        }
    }),
    Object.defineProperty(jt.prototype, "useVertexTexture", {
        get: function() {
            console.warn("THREE.Skeleton: useVertexTexture has been removed.")
        },
        set: function() {
            console.warn("THREE.Skeleton: useVertexTexture has been removed.")
        }
    }),
    Vt.prototype.initBones = function() {
        console.error("THREE.SkinnedMesh: initBones() has been removed.")
    }
    ,
    Object.defineProperty(l.prototype, "__arcLengthDivisions", {
        get: function() {
            return console.warn("THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions."),
            this.arcLengthDivisions
        },
        set: function(e) {
            console.warn("THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions."),
            this.arcLengthDivisions = e
        }
    }),
    E.prototype.setLens = function(e, t) {
        console.warn("THREE.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup."),
        void 0 !== t && (this.filmGauge = t),
        this.setFocalLength(e)
    }
    ,
    Object.defineProperties(_.prototype, {
        onlyShadow: {
            set: function() {
                console.warn("THREE.Light: .onlyShadow has been removed.")
            }
        },
        shadowCameraFov: {
            set: function(e) {
                console.warn("THREE.Light: .shadowCameraFov is now .shadow.camera.fov."),
                this.shadow.camera.fov = e
            }
        },
        shadowCameraLeft: {
            set: function(e) {
                console.warn("THREE.Light: .shadowCameraLeft is now .shadow.camera.left."),
                this.shadow.camera.left = e
            }
        },
        shadowCameraRight: {
            set: function(e) {
                console.warn("THREE.Light: .shadowCameraRight is now .shadow.camera.right."),
                this.shadow.camera.right = e
            }
        },
        shadowCameraTop: {
            set: function(e) {
                console.warn("THREE.Light: .shadowCameraTop is now .shadow.camera.top."),
                this.shadow.camera.top = e
            }
        },
        shadowCameraBottom: {
            set: function(e) {
                console.warn("THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom."),
                this.shadow.camera.bottom = e
            }
        },
        shadowCameraNear: {
            set: function(e) {
                console.warn("THREE.Light: .shadowCameraNear is now .shadow.camera.near."),
                this.shadow.camera.near = e
            }
        },
        shadowCameraFar: {
            set: function(e) {
                console.warn("THREE.Light: .shadowCameraFar is now .shadow.camera.far."),
                this.shadow.camera.far = e
            }
        },
        shadowCameraVisible: {
            set: function() {
                console.warn("THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.")
            }
        },
        shadowBias: {
            set: function(e) {
                console.warn("THREE.Light: .shadowBias is now .shadow.bias."),
                this.shadow.bias = e
            }
        },
        shadowDarkness: {
            set: function() {
                console.warn("THREE.Light: .shadowDarkness has been removed.")
            }
        },
        shadowMapWidth: {
            set: function(e) {
                console.warn("THREE.Light: .shadowMapWidth is now .shadow.mapSize.width."),
                this.shadow.mapSize.width = e
            }
        },
        shadowMapHeight: {
            set: function(e) {
                console.warn("THREE.Light: .shadowMapHeight is now .shadow.mapSize.height."),
                this.shadow.mapSize.height = e
            }
        }
    }),
    Object.defineProperties(m.prototype, {
        length: {
            get: function() {
                return console.warn("THREE.BufferAttribute: .length has been deprecated. Use .count instead."),
                this.array.length
            }
        },
        copyIndicesArray: function() {
            console.error("THREE.BufferAttribute: .copyIndicesArray() has been removed.")
        }
    }),
    Object.assign(U.prototype, {
        addIndex: function(e) {
            console.warn("THREE.BufferGeometry: .addIndex() has been renamed to .setIndex()."),
            this.setIndex(e)
        },
        addDrawCall: function(e, t, i) {
            void 0 !== i && console.warn("THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset."),
            console.warn("THREE.BufferGeometry: .addDrawCall() is now .addGroup()."),
            this.addGroup(e, t)
        },
        clearDrawCalls: function() {
            console.warn("THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups()."),
            this.clearGroups()
        },
        computeTangents: function() {
            console.warn("THREE.BufferGeometry: .computeTangents() has been removed.")
        },
        computeOffsets: function() {
            console.warn("THREE.BufferGeometry: .computeOffsets() has been removed.")
        }
    }),
    Object.defineProperties(U.prototype, {
        drawcalls: {
            get: function() {
                return console.error("THREE.BufferGeometry: .drawcalls has been renamed to .groups."),
                this.groups
            }
        },
        offsets: {
            get: function() {
                return console.warn("THREE.BufferGeometry: .offsets has been renamed to .groups."),
                this.groups
            }
        }
    }),
    Object.assign(Ii.prototype, {
        getArrays: function() {
            console.error("THREE.ExtrudeBufferGeometry: .getArrays() has been removed.")
        },
        addShapeList: function() {
            console.error("THREE.ExtrudeBufferGeometry: .addShapeList() has been removed.")
        },
        addShape: function() {
            console.error("THREE.ExtrudeBufferGeometry: .addShape() has been removed.")
        }
    }),
    Object.defineProperties(Er.prototype, {
        dynamic: {
            set: function() {
                console.warn("THREE.Uniform: .dynamic has been removed. Use object.onBeforeRender() instead.")
            }
        },
        onUpdate: {
            value: function() {
                return console.warn("THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead."),
                this
            }
        }
    }),
    Object.defineProperties(a.prototype, {
        wrapAround: {
            get: function() {
                console.warn("THREE.Material: .wrapAround has been removed.")
            },
            set: function() {
                console.warn("THREE.Material: .wrapAround has been removed.")
            }
        },
        overdraw: {
            get: function() {
                console.warn("THREE.Material: .overdraw has been removed.")
            },
            set: function() {
                console.warn("THREE.Material: .overdraw has been removed.")
            }
        },
        wrapRGB: {
            get: function() {
                return console.warn("THREE.Material: .wrapRGB has been removed."),
                new d
            }
        },
        shading: {
            get: function() {
                console.error("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead.")
            },
            set: function(e) {
                console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead."),
                this.flatShading = 1 === e
            }
        }
    }),
    Object.defineProperties(rn.prototype, {
        metal: {
            get: function() {
                return console.warn("THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead."),
                !1
            },
            set: function() {
                console.warn("THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead")
            }
        }
    }),
    Object.defineProperties(te.prototype, {
        derivatives: {
            get: function() {
                return console.warn("THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives."),
                this.extensions.derivatives
            },
            set: function(e) {
                console.warn("THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives."),
                this.extensions.derivatives = e
            }
        }
    }),
    Object.assign(Dt.prototype, {
        clearTarget: function(e, t, i, n) {
            console.warn("THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead."),
            this.setRenderTarget(e),
            this.clear(t, i, n)
        },
        animate: function(e) {
            console.warn("THREE.WebGLRenderer: .animate() is now .setAnimationLoop()."),
            this.setAnimationLoop(e)
        },
        getCurrentRenderTarget: function() {
            return console.warn("THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget()."),
            this.getRenderTarget()
        },
        getMaxAnisotropy: function() {
            return console.warn("THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy()."),
            this.capabilities.getMaxAnisotropy()
        },
        getPrecision: function() {
            return console.warn("THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision."),
            this.capabilities.precision
        },
        resetGLState: function() {
            return console.warn("THREE.WebGLRenderer: .resetGLState() is now .state.reset()."),
            this.state.reset()
        },
        supportsFloatTextures: function() {
            return console.warn("THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' )."),
            this.extensions.get("OES_texture_float")
        },
        supportsHalfFloatTextures: function() {
            return console.warn("THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' )."),
            this.extensions.get("OES_texture_half_float")
        },
        supportsStandardDerivatives: function() {
            return console.warn("THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' )."),
            this.extensions.get("OES_standard_derivatives")
        },
        supportsCompressedTextureS3TC: function() {
            return console.warn("THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' )."),
            this.extensions.get("WEBGL_compressed_texture_s3tc")
        },
        supportsCompressedTexturePVRTC: function() {
            return console.warn("THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' )."),
            this.extensions.get("WEBGL_compressed_texture_pvrtc")
        },
        supportsBlendMinMax: function() {
            return console.warn("THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' )."),
            this.extensions.get("EXT_blend_minmax")
        },
        supportsVertexTextures: function() {
            return console.warn("THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures."),
            this.capabilities.vertexTextures
        },
        supportsInstancedArrays: function() {
            return console.warn("THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' )."),
            this.extensions.get("ANGLE_instanced_arrays")
        },
        enableScissorTest: function(e) {
            console.warn("THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest()."),
            this.setScissorTest(e)
        },
        initMaterial: function() {
            console.warn("THREE.WebGLRenderer: .initMaterial() has been removed.")
        },
        addPrePlugin: function() {
            console.warn("THREE.WebGLRenderer: .addPrePlugin() has been removed.")
        },
        addPostPlugin: function() {
            console.warn("THREE.WebGLRenderer: .addPostPlugin() has been removed.")
        },
        updateShadowMap: function() {
            console.warn("THREE.WebGLRenderer: .updateShadowMap() has been removed.")
        },
        setFaceCulling: function() {
            console.warn("THREE.WebGLRenderer: .setFaceCulling() has been removed.")
        }
    }),
    Object.defineProperties(Dt.prototype, {
        shadowMapEnabled: {
            get: function() {
                return this.shadowMap.enabled
            },
            set: function(e) {
                console.warn("THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled."),
                this.shadowMap.enabled = e
            }
        },
        shadowMapType: {
            get: function() {
                return this.shadowMap.type
            },
            set: function(e) {
                console.warn("THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type."),
                this.shadowMap.type = e
            }
        },
        shadowMapCullFace: {
            get: function() {
                console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.")
            },
            set: function() {
                console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.")
            }
        }
    }),
    Object.defineProperties(Et.prototype, {
        cullFace: {
            get: function() {
                console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.")
            },
            set: function() {
                console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.")
            }
        },
        renderReverseSided: {
            get: function() {
                console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.")
            },
            set: function() {
                console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.")
            }
        },
        renderSingleSided: {
            get: function() {
                console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.")
            },
            set: function() {
                console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.")
            }
        }
    }),
    Object.defineProperties(P.prototype, {
        wrapS: {
            get: function() {
                return console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."),
                this.texture.wrapS
            },
            set: function(e) {
                console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."),
                this.texture.wrapS = e
            }
        },
        wrapT: {
            get: function() {
                return console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."),
                this.texture.wrapT
            },
            set: function(e) {
                console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."),
                this.texture.wrapT = e
            }
        },
        magFilter: {
            get: function() {
                return console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."),
                this.texture.magFilter
            },
            set: function(e) {
                console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."),
                this.texture.magFilter = e
            }
        },
        minFilter: {
            get: function() {
                return console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."),
                this.texture.minFilter
            },
            set: function(e) {
                console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."),
                this.texture.minFilter = e
            }
        },
        anisotropy: {
            get: function() {
                return console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."),
                this.texture.anisotropy
            },
            set: function(e) {
                console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."),
                this.texture.anisotropy = e
            }
        },
        offset: {
            get: function() {
                return console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."),
                this.texture.offset
            },
            set: function(e) {
                console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."),
                this.texture.offset = e
            }
        },
        repeat: {
            get: function() {
                return console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."),
                this.texture.repeat
            },
            set: function(e) {
                console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."),
                this.texture.repeat = e
            }
        },
        format: {
            get: function() {
                return console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."),
                this.texture.format
            },
            set: function(e) {
                console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."),
                this.texture.format = e
            }
        },
        type: {
            get: function() {
                return console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."),
                this.texture.type
            },
            set: function(e) {
                console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."),
                this.texture.type = e
            }
        },
        generateMipmaps: {
            get: function() {
                return console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."),
                this.texture.generateMipmaps
            },
            set: function(e) {
                console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."),
                this.texture.generateMipmaps = e
            }
        }
    }),
    Object.defineProperties(Ot.prototype, {
        standing: {
            set: function() {
                console.warn("THREE.WebVRManager: .standing has been removed.")
            }
        },
        userHeight: {
            set: function() {
                console.warn("THREE.WebVRManager: .userHeight has been removed.")
            }
        }
    }),
    gr.prototype.load = function(e) {
        console.warn("THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.");
        var t = this;
        return (new ur).load(e, function(e) {
            t.setBuffer(e)
        }),
        this
    }
    ,
    yr.prototype.getData = function() {
        return console.warn("THREE.AudioAnalyser: .getData() is now .getFrequencyData()."),
        this.getFrequencyData()
    }
    ,
    dr.prototype.updateCubeMap = function(e, t) {
        return console.warn("THREE.CubeCamera: .updateCubeMap() is now .update()."),
        this.update(e, t)
    }
    ,
    Ka.crossOrigin = void 0,
    Ka.loadTexture = function(e, t, i, n) {
        console.warn("THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.");
        var r = new Rn;
        return r.setCrossOrigin(this.crossOrigin),
        e = r.load(e, i, void 0, n),
        t && (e.mapping = t),
        e
    }
    ,
    Ka.loadTextureCube = function(e, t, i, n) {
        console.warn("THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.");
        var r = new Pn;
        return r.setCrossOrigin(this.crossOrigin),
        e = r.load(e, i, void 0, n),
        t && (e.mapping = t),
        e
    }
    ,
    Ka.loadCompressedTexture = function() {
        console.error("THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.")
    }
    ,
    Ka.loadCompressedTextureCube = function() {
        console.error("THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.")
    }
    ,
    e.WebGLMultisampleRenderTarget = R,
    e.WebGLRenderTargetCube = C,
    e.WebGLRenderTarget = P,
    e.WebGLRenderer = Dt,
    e.ShaderLib = Is,
    e.UniformsLib = Te,
    e.UniformsUtils = ao,
    e.ShaderChunk = T,
    e.FogExp2 = Bt,
    e.Fog = Nt,
    e.Scene = zt,
    e.Sprite = Ht,
    e.LOD = kt,
    e.SkinnedMesh = Vt,
    e.Skeleton = jt,
    e.Bone = Wt,
    e.Mesh = v,
    e.LineSegments = x,
    e.LineLoop = qt,
    e.Line = h,
    e.Points = Yt,
    e.Group = Lt,
    e.VideoTexture = Jt,
    e.DataTexture = Ae,
    e.DataTexture3D = oe,
    e.CompressedTexture = Zt,
    e.CubeTexture = ae,
    e.CanvasTexture = Qt,
    e.DepthTexture = Kt,
    e.Texture = p,
    e.AnimationLoader = Sn,
    e.CompressedTextureLoader = Tn,
    e.DataTextureLoader = An,
    e.CubeTextureLoader = Pn,
    e.TextureLoader = Rn,
    e.ObjectLoader = ar,
    e.MaterialLoader = nr,
    e.BufferGeometryLoader = rr,
    e.DefaultLoadingManager = Uc,
    e.LoadingManager = Mn,
    e.ImageLoader = Ln,
    e.ImageBitmapLoader = or,
    e.FontLoader = hr,
    e.FileLoader = En,
    e.Loader = lr,
    e.LoaderUtils = Wc,
    e.Cache = zc,
    e.AudioLoader = ur,
    e.SpotLightShadow = Jn,
    e.SpotLight = Zn,
    e.PointLight = Qn,
    e.RectAreaLight = ir,
    e.HemisphereLight = Xn,
    e.DirectionalLightShadow = $n,
    e.DirectionalLight = er,
    e.AmbientLight = tr,
    e.LightShadow = Yn,
    e.Light = _,
    e.StereoCamera = pr,
    e.PerspectiveCamera = E,
    e.OrthographicCamera = Kn,
    e.CubeCamera = dr,
    e.ArrayCamera = Rt,
    e.Camera = Pt,
    e.AudioListener = mr,
    e.PositionalAudio = vr,
    e.AudioContext = $h,
    e.AudioAnalyser = yr,
    e.Audio = gr,
    e.VectorKeyframeTrack = bn,
    e.StringKeyframeTrack = xn,
    e.QuaternionKeyframeTrack = yn,
    e.NumberKeyframeTrack = gn,
    e.ColorKeyframeTrack = mn,
    e.BooleanKeyframeTrack = fn,
    e.PropertyMixer = xr,
    e.PropertyBinding = S,
    e.KeyframeTrack = c,
    e.AnimationUtils = A,
    e.AnimationObjectGroup = wr,
    e.AnimationMixer = Mr,
    e.AnimationClip = wn,
    e.Uniform = Er,
    e.InstancedBufferGeometry = Sr,
    e.BufferGeometry = U,
    e.Geometry = f,
    e.InterleavedBufferAttribute = Gt,
    e.InstancedInterleavedBuffer = Tr,
    e.InterleavedBuffer = Ut,
    e.InstancedBufferAttribute = Ar,
    e.Face3 = B,
    e.Object3D = u,
    e.Raycaster = Lr,
    e.Layers = G,
    e.EventDispatcher = L,
    e.Clock = fr,
    e.QuaternionLinearInterpolant = vn,
    e.LinearInterpolant = pn,
    e.DiscreteInterpolant = dn,
    e.CubicInterpolant = un,
    e.Interpolant = ln,
    e.Triangle = w,
    e.Math = Se,
    e.Spherical = Cr,
    e.Cylindrical = Or,
    e.Plane = D,
    e.Frustum = Le,
    e.Sphere = I,
    e.Ray = ie,
    e.Matrix4 = _e,
    e.Matrix3 = g,
    e.Box3 = O,
    e.Box2 = Ir,
    e.Line3 = Dr,
    e.Euler = N,
    e.Vector4 = Ee,
    e.Vector3 = Me,
    e.Vector2 = Y,
    e.Quaternion = M,
    e.Color = d,
    e.ImmediateRenderObject = Br,
    e.VertexNormalsHelper = Nr,
    e.SpotLightHelper = zr,
    e.SkeletonHelper = Ur,
    e.PointLightHelper = Gr,
    e.RectAreaLightHelper = Fr,
    e.HemisphereLightHelper = Hr,
    e.GridHelper = kr,
    e.PolarGridHelper = Vr,
    e.FaceNormalsHelper = jr,
    e.DirectionalLightHelper = Wr,
    e.CameraHelper = qr,
    e.BoxHelper = Xr,
    e.Box3Helper = Yr,
    e.PlaneHelper = Jr,
    e.ArrowHelper = Zr,
    e.AxesHelper = Qr,
    e.Shape = qn,
    e.Path = Wn,
    e.ShapePath = sr,
    e.Font = cr,
    e.CurvePath = jn,
    e.Curve = l,
    e.ImageUtils = Ka,
    e.ShapeUtils = Ic,
    e.WebGLUtils = At,
    e.WireframeGeometry = $t,
    e.ParametricGeometry = ei,
    e.ParametricBufferGeometry = ti,
    e.TetrahedronGeometry = ri,
    e.TetrahedronBufferGeometry = ai,
    e.OctahedronGeometry = oi,
    e.OctahedronBufferGeometry = si,
    e.IcosahedronGeometry = ci,
    e.IcosahedronBufferGeometry = hi,
    e.DodecahedronGeometry = li,
    e.DodecahedronBufferGeometry = ui,
    e.PolyhedronGeometry = ii,
    e.PolyhedronBufferGeometry = ni,
    e.TubeGeometry = pi,
    e.TubeBufferGeometry = di,
    e.TorusKnotGeometry = fi,
    e.TorusKnotBufferGeometry = mi,
    e.TorusGeometry = gi,
    e.TorusBufferGeometry = vi,
    e.TextGeometry = Bi,
    e.TextBufferGeometry = Ni,
    e.SphereGeometry = zi,
    e.SphereBufferGeometry = Ui,
    e.RingGeometry = Gi,
    e.RingBufferGeometry = Fi,
    e.PlaneGeometry = $,
    e.PlaneBufferGeometry = ee,
    e.LatheGeometry = Hi,
    e.LatheBufferGeometry = ki,
    e.ShapeGeometry = Vi,
    e.ShapeBufferGeometry = ji,
    e.ExtrudeGeometry = Oi,
    e.ExtrudeBufferGeometry = Ii,
    e.EdgesGeometry = qi,
    e.ConeGeometry = Ji,
    e.ConeBufferGeometry = Zi,
    e.CylinderGeometry = Xi,
    e.CylinderBufferGeometry = Yi,
    e.CircleGeometry = Qi,
    e.CircleBufferGeometry = Ki,
    e.BoxGeometry = Q,
    e.BoxBufferGeometry = K,
    e.ShadowMaterial = $i,
    e.SpriteMaterial = Ft,
    e.RawShaderMaterial = en,
    e.ShaderMaterial = te,
    e.PointsMaterial = Xt,
    e.MeshPhysicalMaterial = nn,
    e.MeshStandardMaterial = tn,
    e.MeshPhongMaterial = rn,
    e.MeshToonMaterial = an,
    e.MeshNormalMaterial = on,
    e.MeshLambertMaterial = sn,
    e.MeshDepthMaterial = _t,
    e.MeshDistanceMaterial = Mt,
    e.MeshBasicMaterial = ne,
    e.MeshMatcapMaterial = cn,
    e.LineDashedMaterial = hn,
    e.LineBasicMaterial = y,
    e.Material = a,
    e.Float64BufferAttribute = X,
    e.Float32BufferAttribute = z,
    e.Uint32BufferAttribute = q,
    e.Int32BufferAttribute = W,
    e.Uint16BufferAttribute = j,
    e.Int16BufferAttribute = V,
    e.Uint8ClampedBufferAttribute = k,
    e.Uint8BufferAttribute = H,
    e.Int8BufferAttribute = F,
    e.BufferAttribute = m,
    e.ArcCurve = On,
    e.CatmullRomCurve3 = i,
    e.CubicBezierCurve = zn,
    e.CubicBezierCurve3 = Un,
    e.EllipseCurve = Cn,
    e.LineCurve = Gn,
    e.LineCurve3 = Fn,
    e.QuadraticBezierCurve = Hn,
    e.QuadraticBezierCurve3 = kn,
    e.SplineCurve = Vn,
    e.REVISION = "101",
    e.MOUSE = {
        LEFT: 0,
        MIDDLE: 1,
        RIGHT: 2
    },
    e.CullFaceNone = 0,
    e.CullFaceBack = 1,
    e.CullFaceFront = 2,
    e.CullFaceFrontBack = 3,
    e.FrontFaceDirectionCW = 0,
    e.FrontFaceDirectionCCW = 1,
    e.BasicShadowMap = 0,
    e.PCFShadowMap = 1,
    e.PCFSoftShadowMap = 2,
    e.FrontSide = 0,
    e.BackSide = 1,
    e.DoubleSide = 2,
    e.FlatShading = 1,
    e.SmoothShading = 2,
    e.NoColors = 0,
    e.FaceColors = 1,
    e.VertexColors = 2,
    e.NoBlending = 0,
    e.NormalBlending = 1,
    e.AdditiveBlending = 2,
    e.SubtractiveBlending = 3,
    e.MultiplyBlending = 4,
    e.CustomBlending = 5,
    e.AddEquation = 100,
    e.SubtractEquation = 101,
    e.ReverseSubtractEquation = 102,
    e.MinEquation = 103,
    e.MaxEquation = 104,
    e.ZeroFactor = 200,
    e.OneFactor = 201,
    e.SrcColorFactor = 202,
    e.OneMinusSrcColorFactor = 203,
    e.SrcAlphaFactor = 204,
    e.OneMinusSrcAlphaFactor = 205,
    e.DstAlphaFactor = 206,
    e.OneMinusDstAlphaFactor = 207,
    e.DstColorFactor = 208,
    e.OneMinusDstColorFactor = 209,
    e.SrcAlphaSaturateFactor = 210,
    e.NeverDepth = 0,
    e.AlwaysDepth = 1,
    e.LessDepth = 2,
    e.LessEqualDepth = 3,
    e.EqualDepth = 4,
    e.GreaterEqualDepth = 5,
    e.GreaterDepth = 6,
    e.NotEqualDepth = 7,
    e.MultiplyOperation = 0,
    e.MixOperation = 1,
    e.AddOperation = 2,
    e.NoToneMapping = 0,
    e.LinearToneMapping = 1,
    e.ReinhardToneMapping = 2,
    e.Uncharted2ToneMapping = 3,
    e.CineonToneMapping = 4,
    e.ACESFilmicToneMapping = 5,
    e.UVMapping = 300,
    e.CubeReflectionMapping = 301,
    e.CubeRefractionMapping = 302,
    e.EquirectangularReflectionMapping = 303,
    e.EquirectangularRefractionMapping = 304,
    e.SphericalReflectionMapping = 305,
    e.CubeUVReflectionMapping = 306,
    e.CubeUVRefractionMapping = 307,
    e.RepeatWrapping = 1e3,
    e.ClampToEdgeWrapping = 1001,
    e.MirroredRepeatWrapping = 1002,
    e.NearestFilter = 1003,
    e.NearestMipMapNearestFilter = 1004,
    e.NearestMipMapLinearFilter = 1005,
    e.LinearFilter = 1006,
    e.LinearMipMapNearestFilter = 1007,
    e.LinearMipMapLinearFilter = 1008,
    e.UnsignedByteType = 1009,
    e.ByteType = 1010,
    e.ShortType = 1011,
    e.UnsignedShortType = 1012,
    e.IntType = 1013,
    e.UnsignedIntType = 1014,
    e.FloatType = 1015,
    e.HalfFloatType = 1016,
    e.UnsignedShort4444Type = 1017,
    e.UnsignedShort5551Type = 1018,
    e.UnsignedShort565Type = 1019,
    e.UnsignedInt248Type = 1020,
    e.AlphaFormat = 1021,
    e.RGBFormat = 1022,
    e.RGBAFormat = 1023,
    e.LuminanceFormat = 1024,
    e.LuminanceAlphaFormat = 1025,
    e.RGBEFormat = 1023,
    e.DepthFormat = 1026,
    e.DepthStencilFormat = 1027,
    e.RedFormat = 1028,
    e.RGB_S3TC_DXT1_Format = 33776,
    e.RGBA_S3TC_DXT1_Format = 33777,
    e.RGBA_S3TC_DXT3_Format = 33778,
    e.RGBA_S3TC_DXT5_Format = 33779,
    e.RGB_PVRTC_4BPPV1_Format = 35840,
    e.RGB_PVRTC_2BPPV1_Format = 35841,
    e.RGBA_PVRTC_4BPPV1_Format = 35842,
    e.RGBA_PVRTC_2BPPV1_Format = 35843,
    e.RGB_ETC1_Format = 36196,
    e.RGBA_ASTC_4x4_Format = 37808,
    e.RGBA_ASTC_5x4_Format = 37809,
    e.RGBA_ASTC_5x5_Format = 37810,
    e.RGBA_ASTC_6x5_Format = 37811,
    e.RGBA_ASTC_6x6_Format = 37812,
    e.RGBA_ASTC_8x5_Format = 37813,
    e.RGBA_ASTC_8x6_Format = 37814,
    e.RGBA_ASTC_8x8_Format = 37815,
    e.RGBA_ASTC_10x5_Format = 37816,
    e.RGBA_ASTC_10x6_Format = 37817,
    e.RGBA_ASTC_10x8_Format = 37818,
    e.RGBA_ASTC_10x10_Format = 37819,
    e.RGBA_ASTC_12x10_Format = 37820,
    e.RGBA_ASTC_12x12_Format = 37821,
    e.LoopOnce = 2200,
    e.LoopRepeat = 2201,
    e.LoopPingPong = 2202,
    e.InterpolateDiscrete = 2300,
    e.InterpolateLinear = 2301,
    e.InterpolateSmooth = 2302,
    e.ZeroCurvatureEnding = 2400,
    e.ZeroSlopeEnding = 2401,
    e.WrapAroundEnding = 2402,
    e.TrianglesDrawMode = 0,
    e.TriangleStripDrawMode = 1,
    e.TriangleFanDrawMode = 2,
    e.LinearEncoding = 3e3,
    e.sRGBEncoding = 3001,
    e.GammaEncoding = 3007,
    e.RGBEEncoding = 3002,
    e.LogLuvEncoding = 3003,
    e.RGBM7Encoding = 3004,
    e.RGBM16Encoding = 3005,
    e.RGBDEncoding = 3006,
    e.BasicDepthPacking = 3200,
    e.RGBADepthPacking = 3201,
    e.TangentSpaceNormalMap = 0,
    e.ObjectSpaceNormalMap = 1,
    e.CubeGeometry = Q,
    e.Face4 = function(e, t, i, n, r, a, o) {
        return console.warn("THREE.Face4 has been removed. A THREE.Face3 will be created instead."),
        new B(e,t,i,r,a,o)
    }
    ,
    e.LineStrip = 0,
    e.LinePieces = 1,
    e.MeshFaceMaterial = function(e) {
        return console.warn("THREE.MeshFaceMaterial has been removed. Use an Array instead."),
        e
    }
    ,
    e.MultiMaterial = function(e) {
        return void 0 === e && (e = []),
        console.warn("THREE.MultiMaterial has been removed. Use an Array instead."),
        e.isMultiMaterial = !0,
        (e.materials = e).clone = function() {
            return e.slice()
        }
        ,
        e
    }
    ,
    e.PointCloud = function(e, t) {
        return console.warn("THREE.PointCloud has been renamed to THREE.Points."),
        new Yt(e,t)
    }
    ,
    e.Particle = function(e) {
        return console.warn("THREE.Particle has been renamed to THREE.Sprite."),
        new Ht(e)
    }
    ,
    e.ParticleSystem = function(e, t) {
        return console.warn("THREE.ParticleSystem has been renamed to THREE.Points."),
        new Yt(e,t)
    }
    ,
    e.PointCloudMaterial = function(e) {
        return console.warn("THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial."),
        new Xt(e)
    }
    ,
    e.ParticleBasicMaterial = function(e) {
        return console.warn("THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial."),
        new Xt(e)
    }
    ,
    e.ParticleSystemMaterial = function(e) {
        return console.warn("THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial."),
        new Xt(e)
    }
    ,
    e.Vertex = function(e, t, i) {
        return console.warn("THREE.Vertex has been removed. Use THREE.Vector3 instead."),
        new Me(e,t,i)
    }
    ,
    e.DynamicBufferAttribute = function(e, t) {
        return console.warn("THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setDynamic( true ) instead."),
        new m(e,t).setDynamic(!0)
    }
    ,
    e.Int8Attribute = function(e, t) {
        return console.warn("THREE.Int8Attribute has been removed. Use new THREE.Int8BufferAttribute() instead."),
        new F(e,t)
    }
    ,
    e.Uint8Attribute = function(e, t) {
        return console.warn("THREE.Uint8Attribute has been removed. Use new THREE.Uint8BufferAttribute() instead."),
        new H(e,t)
    }
    ,
    e.Uint8ClampedAttribute = function(e, t) {
        return console.warn("THREE.Uint8ClampedAttribute has been removed. Use new THREE.Uint8ClampedBufferAttribute() instead."),
        new k(e,t)
    }
    ,
    e.Int16Attribute = function(e, t) {
        return console.warn("THREE.Int16Attribute has been removed. Use new THREE.Int16BufferAttribute() instead."),
        new V(e,t)
    }
    ,
    e.Uint16Attribute = function(e, t) {
        return console.warn("THREE.Uint16Attribute has been removed. Use new THREE.Uint16BufferAttribute() instead."),
        new j(e,t)
    }
    ,
    e.Int32Attribute = function(e, t) {
        return console.warn("THREE.Int32Attribute has been removed. Use new THREE.Int32BufferAttribute() instead."),
        new W(e,t)
    }
    ,
    e.Uint32Attribute = function(e, t) {
        return console.warn("THREE.Uint32Attribute has been removed. Use new THREE.Uint32BufferAttribute() instead."),
        new q(e,t)
    }
    ,
    e.Float32Attribute = function(e, t) {
        return console.warn("THREE.Float32Attribute has been removed. Use new THREE.Float32BufferAttribute() instead."),
        new z(e,t)
    }
    ,
    e.Float64Attribute = function(e, t) {
        return console.warn("THREE.Float64Attribute has been removed. Use new THREE.Float64BufferAttribute() instead."),
        new X(e,t)
    }
    ,
    e.ClosedSplineCurve3 = Kr,
    e.SplineCurve3 = $r,
    e.Spline = ea,
    e.AxisHelper = function(e) {
        return console.warn("THREE.AxisHelper has been renamed to THREE.AxesHelper."),
        new Qr(e)
    }
    ,
    e.BoundingBoxHelper = function(e, t) {
        return console.warn("THREE.BoundingBoxHelper has been deprecated. Creating a THREE.BoxHelper instead."),
        new Xr(e,t)
    }
    ,
    e.EdgesHelper = function(e, t) {
        return console.warn("THREE.EdgesHelper has been removed. Use THREE.EdgesGeometry instead."),
        new x(new qi(e.geometry),new y({
            color: void 0 !== t ? t : 16777215
        }))
    }
    ,
    e.WireframeHelper = function(e, t) {
        return console.warn("THREE.WireframeHelper has been removed. Use THREE.WireframeGeometry instead."),
        new x(new $t(e.geometry),new y({
            color: void 0 !== t ? t : 16777215
        }))
    }
    ,
    e.XHRLoader = function(e) {
        return console.warn("THREE.XHRLoader has been renamed to THREE.FileLoader."),
        new En(e)
    }
    ,
    e.BinaryTextureLoader = function(e) {
        return console.warn("THREE.BinaryTextureLoader has been renamed to THREE.DataTextureLoader."),
        new An(e)
    }
    ,
    e.GeometryUtils = {
        merge: function(e, t, i) {
            var n;
            console.warn("THREE.GeometryUtils: .merge() has been moved to Geometry. Use geometry.merge( geometry2, matrix, materialIndexOffset ) instead."),
            t.isMesh && (t.matrixAutoUpdate && t.updateMatrix(),
            n = t.matrix,
            t = t.geometry),
            e.merge(t, n, i)
        },
        center: function(e) {
            return console.warn("THREE.GeometryUtils: .center() has been moved to Geometry. Use geometry.center() instead."),
            e.center()
        }
    },
    e.Projector = function() {
        console.error("THREE.Projector has been moved to /examples/js/renderers/Projector.js."),
        this.projectVector = function(e, t) {
            console.warn("THREE.Projector: .projectVector() is now vector.project()."),
            e.project(t)
        }
        ,
        this.unprojectVector = function(e, t) {
            console.warn("THREE.Projector: .unprojectVector() is now vector.unproject()."),
            e.unproject(t)
        }
        ,
        this.pickingRay = function() {
            console.error("THREE.Projector: .pickingRay() is now raycaster.setFromCamera().")
        }
    }
    ,
    e.CanvasRenderer = function() {
        console.error("THREE.CanvasRenderer has been removed")
    }
    ,
    e.JSONLoader = function() {
        console.error("THREE.JSONLoader has been removed.")
    }
    ,
    e.SceneUtils = {
        createMultiMaterialObject: function() {
            console.error("THREE.SceneUtils has been moved to /examples/js/utils/SceneUtils.js")
        },
        detach: function() {
            console.error("THREE.SceneUtils has been moved to /examples/js/utils/SceneUtils.js")
        },
        attach: function() {
            console.error("THREE.SceneUtils has been moved to /examples/js/utils/SceneUtils.js")
        }
    },
    e.LensFlare = function() {
        console.error("THREE.LensFlare has been moved to /examples/js/objects/Lensflare.js")
    }
    ,
    Object.defineProperty(e, "__esModule", {
        value: !0
    })
});